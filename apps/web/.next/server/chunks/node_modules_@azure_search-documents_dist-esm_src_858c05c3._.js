module.exports = {

"[project]/node_modules/@azure/search-documents/dist-esm/src/odata.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
__turbopack_context__.s({
    "odata": (()=>odata)
});
function formatNullAndUndefined(input) {
    if (input === null || input === undefined) {
        return "null";
    }
    return input;
}
function escapeQuotesIfString(input, previous) {
    let result = input;
    if (typeof input === "string") {
        result = input.replace(/'/g, "''");
        // check if we need to escape this literal
        if (!previous.trim().endsWith("'")) {
            result = `'${result}'`;
        }
    }
    return result;
}
function odata(strings, ...values) {
    const results = [];
    for(let i = 0; i < strings.length; i++){
        results.push(strings[i]);
        if (i < values.length) {
            if (values[i] === null || values[i] === undefined) {
                results.push(formatNullAndUndefined(values[i]));
            } else {
                results.push(escapeQuotesIfString(values[i], strings[i]));
            }
        }
    }
    return results.join("");
} //# sourceMappingURL=odata.js.map
}}),
"[project]/node_modules/@azure/search-documents/dist-esm/src/base64.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Encodes a string in base64 format.
 * @param value - The string to encode.
 */ __turbopack_context__.s({
    "decode": (()=>decode),
    "encode": (()=>encode)
});
function encode(value) {
    return Buffer.from(value).toString("base64");
}
function decode(value) {
    return Buffer.from(value, "base64").toString();
} //# sourceMappingURL=base64.js.map
}}),
"[project]/node_modules/@azure/search-documents/dist-esm/src/generated/data/models/mappers.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */ __turbopack_context__.s({
    "AutocompleteItem": (()=>AutocompleteItem),
    "AutocompleteRequest": (()=>AutocompleteRequest),
    "AutocompleteResult": (()=>AutocompleteResult),
    "ErrorAdditionalInfo": (()=>ErrorAdditionalInfo),
    "ErrorDetail": (()=>ErrorDetail),
    "ErrorResponse": (()=>ErrorResponse),
    "FacetResult": (()=>FacetResult),
    "IndexAction": (()=>IndexAction),
    "IndexBatch": (()=>IndexBatch),
    "IndexDocumentsResult": (()=>IndexDocumentsResult),
    "IndexingResult": (()=>IndexingResult),
    "QueryAnswerResult": (()=>QueryAnswerResult),
    "QueryCaptionResult": (()=>QueryCaptionResult),
    "SearchDocumentsResult": (()=>SearchDocumentsResult),
    "SearchRequest": (()=>SearchRequest),
    "SearchResult": (()=>SearchResult),
    "SuggestDocumentsResult": (()=>SuggestDocumentsResult),
    "SuggestRequest": (()=>SuggestRequest),
    "SuggestResult": (()=>SuggestResult),
    "VectorQuery": (()=>VectorQuery),
    "VectorizableTextQuery": (()=>VectorizableTextQuery),
    "VectorizedQuery": (()=>VectorizedQuery),
    "discriminators": (()=>discriminators)
});
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetail"
                }
            }
        }
    }
};
const ErrorDetail = {
    type: {
        name: "Composite",
        className: "ErrorDetail",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorDetail"
                        }
                    }
                }
            },
            additionalInfo: {
                serializedName: "additionalInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorAdditionalInfo"
                        }
                    }
                }
            }
        }
    }
};
const ErrorAdditionalInfo = {
    type: {
        name: "Composite",
        className: "ErrorAdditionalInfo",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            info: {
                serializedName: "info",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "any"
                        }
                    }
                }
            }
        }
    }
};
const SearchDocumentsResult = {
    type: {
        name: "Composite",
        className: "SearchDocumentsResult",
        modelProperties: {
            count: {
                serializedName: "@odata\\.count",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            coverage: {
                serializedName: "@search\\.coverage",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            facets: {
                serializedName: "@search\\.facets",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Composite",
                                    className: "FacetResult"
                                }
                            }
                        }
                    }
                }
            },
            answers: {
                serializedName: "@search\\.answers",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QueryAnswerResult"
                        }
                    }
                }
            },
            nextPageParameters: {
                serializedName: "@search\\.nextPageParameters",
                type: {
                    name: "Composite",
                    className: "SearchRequest"
                }
            },
            results: {
                serializedName: "value",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchResult"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "@odata\\.nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            semanticPartialResponseReason: {
                serializedName: "@search\\.semanticPartialResponseReason",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            semanticPartialResponseType: {
                serializedName: "@search\\.semanticPartialResponseType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FacetResult = {
    type: {
        name: "Composite",
        className: "FacetResult",
        additionalProperties: {
            type: {
                name: "Object"
            }
        },
        modelProperties: {
            count: {
                serializedName: "count",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const QueryAnswerResult = {
    type: {
        name: "Composite",
        className: "QueryAnswerResult",
        additionalProperties: {
            type: {
                name: "Object"
            }
        },
        modelProperties: {
            score: {
                serializedName: "score",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            key: {
                serializedName: "key",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            highlights: {
                serializedName: "highlights",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SearchRequest = {
    type: {
        name: "Composite",
        className: "SearchRequest",
        modelProperties: {
            includeTotalResultCount: {
                serializedName: "count",
                type: {
                    name: "Boolean"
                }
            },
            facets: {
                serializedName: "facets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            filter: {
                serializedName: "filter",
                type: {
                    name: "String"
                }
            },
            highlightFields: {
                serializedName: "highlight",
                type: {
                    name: "String"
                }
            },
            highlightPostTag: {
                serializedName: "highlightPostTag",
                type: {
                    name: "String"
                }
            },
            highlightPreTag: {
                serializedName: "highlightPreTag",
                type: {
                    name: "String"
                }
            },
            minimumCoverage: {
                serializedName: "minimumCoverage",
                type: {
                    name: "Number"
                }
            },
            orderBy: {
                serializedName: "orderby",
                type: {
                    name: "String"
                }
            },
            queryType: {
                serializedName: "queryType",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "simple",
                        "full",
                        "semantic"
                    ]
                }
            },
            scoringStatistics: {
                serializedName: "scoringStatistics",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "local",
                        "global"
                    ]
                }
            },
            sessionId: {
                serializedName: "sessionId",
                type: {
                    name: "String"
                }
            },
            scoringParameters: {
                serializedName: "scoringParameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            scoringProfile: {
                serializedName: "scoringProfile",
                type: {
                    name: "String"
                }
            },
            searchText: {
                serializedName: "search",
                type: {
                    name: "String"
                }
            },
            searchFields: {
                serializedName: "searchFields",
                type: {
                    name: "String"
                }
            },
            searchMode: {
                serializedName: "searchMode",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "any",
                        "all"
                    ]
                }
            },
            select: {
                serializedName: "select",
                type: {
                    name: "String"
                }
            },
            skip: {
                serializedName: "skip",
                type: {
                    name: "Number"
                }
            },
            top: {
                serializedName: "top",
                type: {
                    name: "Number"
                }
            },
            semanticConfigurationName: {
                serializedName: "semanticConfiguration",
                type: {
                    name: "String"
                }
            },
            semanticErrorHandling: {
                serializedName: "semanticErrorHandling",
                type: {
                    name: "String"
                }
            },
            semanticMaxWaitInMilliseconds: {
                constraints: {
                    InclusiveMinimum: 700
                },
                serializedName: "semanticMaxWaitInMilliseconds",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            semanticQuery: {
                serializedName: "semanticQuery",
                type: {
                    name: "String"
                }
            },
            answers: {
                serializedName: "answers",
                type: {
                    name: "String"
                }
            },
            captions: {
                serializedName: "captions",
                type: {
                    name: "String"
                }
            },
            vectorQueries: {
                serializedName: "vectorQueries",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VectorQuery"
                        }
                    }
                }
            },
            vectorFilterMode: {
                serializedName: "vectorFilterMode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VectorQuery = {
    type: {
        name: "Composite",
        className: "VectorQuery",
        uberParent: "VectorQuery",
        polymorphicDiscriminator: {
            serializedName: "kind",
            clientName: "kind"
        },
        modelProperties: {
            kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String"
                }
            },
            kNearestNeighborsCount: {
                serializedName: "k",
                type: {
                    name: "Number"
                }
            },
            fields: {
                serializedName: "fields",
                type: {
                    name: "String"
                }
            },
            exhaustive: {
                serializedName: "exhaustive",
                type: {
                    name: "Boolean"
                }
            },
            oversampling: {
                serializedName: "oversampling",
                type: {
                    name: "Number"
                }
            },
            weight: {
                serializedName: "weight",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SearchResult = {
    type: {
        name: "Composite",
        className: "SearchResult",
        additionalProperties: {
            type: {
                name: "Object"
            }
        },
        modelProperties: {
            _score: {
                serializedName: "@search\\.score",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            _rerankerScore: {
                serializedName: "@search\\.rerankerScore",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            _highlights: {
                serializedName: "@search\\.highlights",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    }
                }
            },
            _captions: {
                serializedName: "@search\\.captions",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QueryCaptionResult"
                        }
                    }
                }
            }
        }
    }
};
const QueryCaptionResult = {
    type: {
        name: "Composite",
        className: "QueryCaptionResult",
        additionalProperties: {
            type: {
                name: "Object"
            }
        },
        modelProperties: {
            text: {
                serializedName: "text",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            highlights: {
                serializedName: "highlights",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SuggestDocumentsResult = {
    type: {
        name: "Composite",
        className: "SuggestDocumentsResult",
        modelProperties: {
            results: {
                serializedName: "value",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SuggestResult"
                        }
                    }
                }
            },
            coverage: {
                serializedName: "@search\\.coverage",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SuggestResult = {
    type: {
        name: "Composite",
        className: "SuggestResult",
        additionalProperties: {
            type: {
                name: "Object"
            }
        },
        modelProperties: {
            _text: {
                serializedName: "@search\\.text",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SuggestRequest = {
    type: {
        name: "Composite",
        className: "SuggestRequest",
        modelProperties: {
            filter: {
                serializedName: "filter",
                type: {
                    name: "String"
                }
            },
            useFuzzyMatching: {
                serializedName: "fuzzy",
                type: {
                    name: "Boolean"
                }
            },
            highlightPostTag: {
                serializedName: "highlightPostTag",
                type: {
                    name: "String"
                }
            },
            highlightPreTag: {
                serializedName: "highlightPreTag",
                type: {
                    name: "String"
                }
            },
            minimumCoverage: {
                serializedName: "minimumCoverage",
                type: {
                    name: "Number"
                }
            },
            orderBy: {
                serializedName: "orderby",
                type: {
                    name: "String"
                }
            },
            searchText: {
                serializedName: "search",
                required: true,
                type: {
                    name: "String"
                }
            },
            searchFields: {
                serializedName: "searchFields",
                type: {
                    name: "String"
                }
            },
            select: {
                serializedName: "select",
                type: {
                    name: "String"
                }
            },
            suggesterName: {
                serializedName: "suggesterName",
                required: true,
                type: {
                    name: "String"
                }
            },
            top: {
                serializedName: "top",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const IndexBatch = {
    type: {
        name: "Composite",
        className: "IndexBatch",
        modelProperties: {
            actions: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IndexAction"
                        }
                    }
                }
            }
        }
    }
};
const IndexAction = {
    type: {
        name: "Composite",
        className: "IndexAction",
        additionalProperties: {
            type: {
                name: "Object"
            }
        },
        modelProperties: {
            __actionType: {
                serializedName: "@search\\.action",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "upload",
                        "merge",
                        "mergeOrUpload",
                        "delete"
                    ]
                }
            }
        }
    }
};
const IndexDocumentsResult = {
    type: {
        name: "Composite",
        className: "IndexDocumentsResult",
        modelProperties: {
            results: {
                serializedName: "value",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IndexingResult"
                        }
                    }
                }
            }
        }
    }
};
const IndexingResult = {
    type: {
        name: "Composite",
        className: "IndexingResult",
        modelProperties: {
            key: {
                serializedName: "key",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            errorMessage: {
                serializedName: "errorMessage",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            succeeded: {
                serializedName: "status",
                required: true,
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            statusCode: {
                serializedName: "statusCode",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AutocompleteResult = {
    type: {
        name: "Composite",
        className: "AutocompleteResult",
        modelProperties: {
            coverage: {
                serializedName: "@search\\.coverage",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            results: {
                serializedName: "value",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AutocompleteItem"
                        }
                    }
                }
            }
        }
    }
};
const AutocompleteItem = {
    type: {
        name: "Composite",
        className: "AutocompleteItem",
        modelProperties: {
            text: {
                serializedName: "text",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            queryPlusText: {
                serializedName: "queryPlusText",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AutocompleteRequest = {
    type: {
        name: "Composite",
        className: "AutocompleteRequest",
        modelProperties: {
            searchText: {
                serializedName: "search",
                required: true,
                type: {
                    name: "String"
                }
            },
            autocompleteMode: {
                serializedName: "autocompleteMode",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "oneTerm",
                        "twoTerms",
                        "oneTermWithContext"
                    ]
                }
            },
            filter: {
                serializedName: "filter",
                type: {
                    name: "String"
                }
            },
            useFuzzyMatching: {
                serializedName: "fuzzy",
                type: {
                    name: "Boolean"
                }
            },
            highlightPostTag: {
                serializedName: "highlightPostTag",
                type: {
                    name: "String"
                }
            },
            highlightPreTag: {
                serializedName: "highlightPreTag",
                type: {
                    name: "String"
                }
            },
            minimumCoverage: {
                serializedName: "minimumCoverage",
                type: {
                    name: "Number"
                }
            },
            searchFields: {
                serializedName: "searchFields",
                type: {
                    name: "String"
                }
            },
            suggesterName: {
                serializedName: "suggesterName",
                required: true,
                type: {
                    name: "String"
                }
            },
            top: {
                serializedName: "top",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const VectorizedQuery = {
    serializedName: "vector",
    type: {
        name: "Composite",
        className: "VectorizedQuery",
        uberParent: "VectorQuery",
        polymorphicDiscriminator: VectorQuery.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, VectorQuery.type.modelProperties), {
            vector: {
                serializedName: "vector",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            }
        })
    }
};
const VectorizableTextQuery = {
    serializedName: "text",
    type: {
        name: "Composite",
        className: "VectorizableTextQuery",
        uberParent: "VectorQuery",
        polymorphicDiscriminator: VectorQuery.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, VectorQuery.type.modelProperties), {
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            }
        })
    }
};
let discriminators = {
    VectorQuery: VectorQuery,
    "VectorQuery.vector": VectorizedQuery,
    "VectorQuery.text": VectorizableTextQuery
}; //# sourceMappingURL=mappers.js.map
}}),
"[project]/node_modules/@azure/search-documents/dist-esm/src/generated/data/models/parameters.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */ __turbopack_context__.s({
    "accept": (()=>accept),
    "answers": (()=>answers),
    "apiVersion": (()=>apiVersion),
    "autocompleteMode": (()=>autocompleteMode),
    "autocompleteRequest": (()=>autocompleteRequest),
    "batch": (()=>batch),
    "captions": (()=>captions),
    "contentType": (()=>contentType),
    "endpoint": (()=>endpoint),
    "facets": (()=>facets),
    "filter": (()=>filter),
    "filter1": (()=>filter1),
    "filter2": (()=>filter2),
    "highlightFields": (()=>highlightFields),
    "highlightPostTag": (()=>highlightPostTag),
    "highlightPostTag1": (()=>highlightPostTag1),
    "highlightPostTag2": (()=>highlightPostTag2),
    "highlightPreTag": (()=>highlightPreTag),
    "highlightPreTag1": (()=>highlightPreTag1),
    "highlightPreTag2": (()=>highlightPreTag2),
    "includeTotalResultCount": (()=>includeTotalResultCount),
    "indexName": (()=>indexName),
    "key": (()=>key),
    "minimumCoverage": (()=>minimumCoverage),
    "minimumCoverage1": (()=>minimumCoverage1),
    "minimumCoverage2": (()=>minimumCoverage2),
    "orderBy": (()=>orderBy),
    "orderBy1": (()=>orderBy1),
    "queryType": (()=>queryType),
    "scoringParameters": (()=>scoringParameters),
    "scoringProfile": (()=>scoringProfile),
    "scoringStatistics": (()=>scoringStatistics),
    "searchFields": (()=>searchFields),
    "searchFields1": (()=>searchFields1),
    "searchFields2": (()=>searchFields2),
    "searchMode": (()=>searchMode),
    "searchRequest": (()=>searchRequest),
    "searchText": (()=>searchText),
    "searchText1": (()=>searchText1),
    "select": (()=>select),
    "select1": (()=>select1),
    "selectedFields": (()=>selectedFields),
    "semanticConfiguration": (()=>semanticConfiguration),
    "semanticErrorHandling": (()=>semanticErrorHandling),
    "semanticMaxWaitInMilliseconds": (()=>semanticMaxWaitInMilliseconds),
    "semanticQuery": (()=>semanticQuery),
    "sessionId": (()=>sessionId),
    "skip": (()=>skip),
    "suggestRequest": (()=>suggestRequest),
    "suggesterName": (()=>suggesterName),
    "top": (()=>top),
    "top1": (()=>top1),
    "top2": (()=>top2),
    "useFuzzyMatching": (()=>useFuzzyMatching),
    "useFuzzyMatching1": (()=>useFuzzyMatching1)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$mappers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/search-documents/dist-esm/src/generated/data/models/mappers.js [app-route] (ecmascript)");
;
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const endpoint = {
    parameterPath: "endpoint",
    mapper: {
        serializedName: "endpoint",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const indexName = {
    parameterPath: "indexName",
    mapper: {
        serializedName: "indexName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        serializedName: "api-version",
        required: true,
        type: {
            name: "String"
        }
    }
};
const searchText = {
    parameterPath: [
        "options",
        "searchText"
    ],
    mapper: {
        serializedName: "search",
        type: {
            name: "String"
        }
    }
};
const includeTotalResultCount = {
    parameterPath: [
        "options",
        "searchOptions",
        "includeTotalResultCount"
    ],
    mapper: {
        serializedName: "$count",
        type: {
            name: "Boolean"
        }
    }
};
const facets = {
    parameterPath: [
        "options",
        "searchOptions",
        "facets"
    ],
    mapper: {
        serializedName: "facet",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const filter = {
    parameterPath: [
        "options",
        "searchOptions",
        "filter"
    ],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const highlightFields = {
    parameterPath: [
        "options",
        "searchOptions",
        "highlightFields"
    ],
    mapper: {
        serializedName: "highlight",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "CSV"
};
const highlightPostTag = {
    parameterPath: [
        "options",
        "searchOptions",
        "highlightPostTag"
    ],
    mapper: {
        serializedName: "highlightPostTag",
        type: {
            name: "String"
        }
    }
};
const highlightPreTag = {
    parameterPath: [
        "options",
        "searchOptions",
        "highlightPreTag"
    ],
    mapper: {
        serializedName: "highlightPreTag",
        type: {
            name: "String"
        }
    }
};
const minimumCoverage = {
    parameterPath: [
        "options",
        "searchOptions",
        "minimumCoverage"
    ],
    mapper: {
        serializedName: "minimumCoverage",
        type: {
            name: "Number"
        }
    }
};
const orderBy = {
    parameterPath: [
        "options",
        "searchOptions",
        "orderBy"
    ],
    mapper: {
        serializedName: "$orderby",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "CSV"
};
const queryType = {
    parameterPath: [
        "options",
        "searchOptions",
        "queryType"
    ],
    mapper: {
        serializedName: "queryType",
        type: {
            name: "Enum",
            allowedValues: [
                "simple",
                "full",
                "semantic"
            ]
        }
    }
};
const scoringParameters = {
    parameterPath: [
        "options",
        "searchOptions",
        "scoringParameters"
    ],
    mapper: {
        serializedName: "scoringParameter",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const scoringProfile = {
    parameterPath: [
        "options",
        "searchOptions",
        "scoringProfile"
    ],
    mapper: {
        serializedName: "scoringProfile",
        type: {
            name: "String"
        }
    }
};
const searchFields = {
    parameterPath: [
        "options",
        "searchOptions",
        "searchFields"
    ],
    mapper: {
        serializedName: "searchFields",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "CSV"
};
const searchMode = {
    parameterPath: [
        "options",
        "searchOptions",
        "searchMode"
    ],
    mapper: {
        serializedName: "searchMode",
        type: {
            name: "Enum",
            allowedValues: [
                "any",
                "all"
            ]
        }
    }
};
const scoringStatistics = {
    parameterPath: [
        "options",
        "searchOptions",
        "scoringStatistics"
    ],
    mapper: {
        serializedName: "scoringStatistics",
        type: {
            name: "Enum",
            allowedValues: [
                "local",
                "global"
            ]
        }
    }
};
const sessionId = {
    parameterPath: [
        "options",
        "searchOptions",
        "sessionId"
    ],
    mapper: {
        serializedName: "sessionId",
        type: {
            name: "String"
        }
    }
};
const select = {
    parameterPath: [
        "options",
        "searchOptions",
        "select"
    ],
    mapper: {
        serializedName: "$select",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "CSV"
};
const skip = {
    parameterPath: [
        "options",
        "searchOptions",
        "skip"
    ],
    mapper: {
        serializedName: "$skip",
        type: {
            name: "Number"
        }
    }
};
const top = {
    parameterPath: [
        "options",
        "searchOptions",
        "top"
    ],
    mapper: {
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const semanticConfiguration = {
    parameterPath: [
        "options",
        "searchOptions",
        "semanticConfiguration"
    ],
    mapper: {
        serializedName: "semanticConfiguration",
        type: {
            name: "String"
        }
    }
};
const semanticErrorHandling = {
    parameterPath: [
        "options",
        "searchOptions",
        "semanticErrorHandling"
    ],
    mapper: {
        serializedName: "semanticErrorHandling",
        type: {
            name: "String"
        }
    }
};
const semanticMaxWaitInMilliseconds = {
    parameterPath: [
        "options",
        "searchOptions",
        "semanticMaxWaitInMilliseconds"
    ],
    mapper: {
        constraints: {
            InclusiveMinimum: 700
        },
        serializedName: "semanticMaxWaitInMilliseconds",
        type: {
            name: "Number"
        }
    }
};
const answers = {
    parameterPath: [
        "options",
        "searchOptions",
        "answers"
    ],
    mapper: {
        serializedName: "answers",
        type: {
            name: "String"
        }
    }
};
const captions = {
    parameterPath: [
        "options",
        "searchOptions",
        "captions"
    ],
    mapper: {
        serializedName: "captions",
        type: {
            name: "String"
        }
    }
};
const semanticQuery = {
    parameterPath: [
        "options",
        "searchOptions",
        "semanticQuery"
    ],
    mapper: {
        serializedName: "semanticQuery",
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: [
        "options",
        "contentType"
    ],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const searchRequest = {
    parameterPath: "searchRequest",
    mapper: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$mappers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SearchRequest"]
};
const key = {
    parameterPath: "key",
    mapper: {
        serializedName: "key",
        required: true,
        type: {
            name: "String"
        }
    }
};
const selectedFields = {
    parameterPath: [
        "options",
        "selectedFields"
    ],
    mapper: {
        serializedName: "$select",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "CSV"
};
const searchText1 = {
    parameterPath: "searchText",
    mapper: {
        serializedName: "search",
        required: true,
        type: {
            name: "String"
        }
    }
};
const suggesterName = {
    parameterPath: "suggesterName",
    mapper: {
        serializedName: "suggesterName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const filter1 = {
    parameterPath: [
        "options",
        "suggestOptions",
        "filter"
    ],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const useFuzzyMatching = {
    parameterPath: [
        "options",
        "suggestOptions",
        "useFuzzyMatching"
    ],
    mapper: {
        serializedName: "fuzzy",
        type: {
            name: "Boolean"
        }
    }
};
const highlightPostTag1 = {
    parameterPath: [
        "options",
        "suggestOptions",
        "highlightPostTag"
    ],
    mapper: {
        serializedName: "highlightPostTag",
        type: {
            name: "String"
        }
    }
};
const highlightPreTag1 = {
    parameterPath: [
        "options",
        "suggestOptions",
        "highlightPreTag"
    ],
    mapper: {
        serializedName: "highlightPreTag",
        type: {
            name: "String"
        }
    }
};
const minimumCoverage1 = {
    parameterPath: [
        "options",
        "suggestOptions",
        "minimumCoverage"
    ],
    mapper: {
        serializedName: "minimumCoverage",
        type: {
            name: "Number"
        }
    }
};
const orderBy1 = {
    parameterPath: [
        "options",
        "suggestOptions",
        "orderBy"
    ],
    mapper: {
        serializedName: "$orderby",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "CSV"
};
const searchFields1 = {
    parameterPath: [
        "options",
        "suggestOptions",
        "searchFields"
    ],
    mapper: {
        serializedName: "searchFields",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "CSV"
};
const select1 = {
    parameterPath: [
        "options",
        "suggestOptions",
        "select"
    ],
    mapper: {
        serializedName: "$select",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "CSV"
};
const top1 = {
    parameterPath: [
        "options",
        "suggestOptions",
        "top"
    ],
    mapper: {
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const suggestRequest = {
    parameterPath: "suggestRequest",
    mapper: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$mappers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SuggestRequest"]
};
const batch = {
    parameterPath: "batch",
    mapper: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$mappers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["IndexBatch"]
};
const autocompleteMode = {
    parameterPath: [
        "options",
        "autocompleteOptions",
        "autocompleteMode"
    ],
    mapper: {
        serializedName: "autocompleteMode",
        type: {
            name: "Enum",
            allowedValues: [
                "oneTerm",
                "twoTerms",
                "oneTermWithContext"
            ]
        }
    }
};
const filter2 = {
    parameterPath: [
        "options",
        "autocompleteOptions",
        "filter"
    ],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const useFuzzyMatching1 = {
    parameterPath: [
        "options",
        "autocompleteOptions",
        "useFuzzyMatching"
    ],
    mapper: {
        serializedName: "fuzzy",
        type: {
            name: "Boolean"
        }
    }
};
const highlightPostTag2 = {
    parameterPath: [
        "options",
        "autocompleteOptions",
        "highlightPostTag"
    ],
    mapper: {
        serializedName: "highlightPostTag",
        type: {
            name: "String"
        }
    }
};
const highlightPreTag2 = {
    parameterPath: [
        "options",
        "autocompleteOptions",
        "highlightPreTag"
    ],
    mapper: {
        serializedName: "highlightPreTag",
        type: {
            name: "String"
        }
    }
};
const minimumCoverage2 = {
    parameterPath: [
        "options",
        "autocompleteOptions",
        "minimumCoverage"
    ],
    mapper: {
        serializedName: "minimumCoverage",
        type: {
            name: "Number"
        }
    }
};
const searchFields2 = {
    parameterPath: [
        "options",
        "autocompleteOptions",
        "searchFields"
    ],
    mapper: {
        serializedName: "searchFields",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "CSV"
};
const top2 = {
    parameterPath: [
        "options",
        "autocompleteOptions",
        "top"
    ],
    mapper: {
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const autocompleteRequest = {
    parameterPath: "autocompleteRequest",
    mapper: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$mappers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AutocompleteRequest"]
}; //# sourceMappingURL=parameters.js.map
}}),
"[project]/node_modules/@azure/search-documents/dist-esm/src/generated/data/operations/documents.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */ __turbopack_context__.s({
    "DocumentsImpl": (()=>DocumentsImpl)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$client$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-client/dist/esm/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$client$2f$dist$2f$esm$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-client/dist/esm/serializer.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$mappers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/search-documents/dist-esm/src/generated/data/models/mappers.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/search-documents/dist-esm/src/generated/data/models/parameters.js [app-route] (ecmascript)");
;
;
;
class DocumentsImpl {
    /**
     * Initialize a new instance of the class Documents class.
     * @param client Reference to the service client
     */ constructor(client){
        this.client = client;
    }
    /**
     * Queries the number of documents in the index.
     * @param options The options parameters.
     */ count(options) {
        return this.client.sendOperationRequest({
            options
        }, countOperationSpec);
    }
    /**
     * Searches for documents in the index.
     * @param options The options parameters.
     */ searchGet(options) {
        return this.client.sendOperationRequest({
            options
        }, searchGetOperationSpec);
    }
    /**
     * Searches for documents in the index.
     * @param searchRequest The definition of the Search request.
     * @param options The options parameters.
     */ searchPost(searchRequest, options) {
        return this.client.sendOperationRequest({
            searchRequest,
            options
        }, searchPostOperationSpec);
    }
    /**
     * Retrieves a document from the index.
     * @param key The key of the document to retrieve.
     * @param options The options parameters.
     */ get(key, options) {
        return this.client.sendOperationRequest({
            key,
            options
        }, getOperationSpec);
    }
    /**
     * Suggests documents in the index that match the given partial query text.
     * @param searchText The search text to use to suggest documents. Must be at least 1 character, and no
     *                   more than 100 characters.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part
     *                      of the index definition.
     * @param options The options parameters.
     */ suggestGet(searchText, suggesterName, options) {
        return this.client.sendOperationRequest({
            searchText,
            suggesterName,
            options
        }, suggestGetOperationSpec);
    }
    /**
     * Suggests documents in the index that match the given partial query text.
     * @param suggestRequest The Suggest request.
     * @param options The options parameters.
     */ suggestPost(suggestRequest, options) {
        return this.client.sendOperationRequest({
            suggestRequest,
            options
        }, suggestPostOperationSpec);
    }
    /**
     * Sends a batch of document write actions to the index.
     * @param batch The batch of index actions.
     * @param options The options parameters.
     */ index(batch, options) {
        return this.client.sendOperationRequest({
            batch,
            options
        }, indexOperationSpec);
    }
    /**
     * Autocompletes incomplete query terms based on input text and matching terms in the index.
     * @param searchText The incomplete term which should be auto-completed.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part
     *                      of the index definition.
     * @param options The options parameters.
     */ autocompleteGet(searchText, suggesterName, options) {
        return this.client.sendOperationRequest({
            searchText,
            suggesterName,
            options
        }, autocompleteGetOperationSpec);
    }
    /**
     * Autocompletes incomplete query terms based on input text and matching terms in the index.
     * @param autocompleteRequest The definition of the Autocomplete request.
     * @param options The options parameters.
     */ autocompletePost(autocompleteRequest, options) {
        return this.client.sendOperationRequest({
            autocompleteRequest,
            options
        }, autocompletePostOperationSpec);
    }
}
// Operation Specifications
const serializer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$client$2f$dist$2f$esm$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createSerializer"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$mappers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__, /* isXml */ false);
const countOperationSpec = {
    path: "/docs/$count",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Number"
                }
            }
        },
        default: {
            bodyMapper: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$mappers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__.ErrorResponse
        }
    },
    queryParameters: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["apiVersion"]
    ],
    urlParameters: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["endpoint"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["indexName"]
    ],
    headerParameters: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["accept"]
    ],
    serializer
};
const searchGetOperationSpec = {
    path: "/docs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$mappers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__.SearchDocumentsResult
        },
        default: {
            bodyMapper: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$mappers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__.ErrorResponse
        }
    },
    queryParameters: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["apiVersion"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["searchText"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["includeTotalResultCount"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["facets"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["filter"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["highlightFields"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["highlightPostTag"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["highlightPreTag"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["minimumCoverage"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["orderBy"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryType"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["scoringParameters"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["scoringProfile"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["searchFields"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["searchMode"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["scoringStatistics"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["sessionId"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["select"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["skip"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["top"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["semanticConfiguration"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["semanticErrorHandling"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["semanticMaxWaitInMilliseconds"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["answers"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["captions"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["semanticQuery"]
    ],
    urlParameters: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["endpoint"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["indexName"]
    ],
    headerParameters: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["accept"]
    ],
    serializer
};
const searchPostOperationSpec = {
    path: "/docs/search.post.search",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$mappers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__.SearchDocumentsResult
        },
        default: {
            bodyMapper: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$mappers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__.ErrorResponse
        }
    },
    requestBody: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["searchRequest"],
    queryParameters: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["apiVersion"]
    ],
    urlParameters: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["endpoint"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["indexName"]
    ],
    headerParameters: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["accept"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["contentType"]
    ],
    mediaType: "json",
    serializer
};
const getOperationSpec = {
    path: "/docs('{key}')",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "any"
                        }
                    }
                }
            }
        },
        default: {
            bodyMapper: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$mappers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__.ErrorResponse
        }
    },
    queryParameters: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["apiVersion"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["selectedFields"]
    ],
    urlParameters: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["endpoint"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["indexName"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["key"]
    ],
    headerParameters: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["accept"]
    ],
    serializer
};
const suggestGetOperationSpec = {
    path: "/docs/search.suggest",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$mappers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__.SuggestDocumentsResult
        },
        default: {
            bodyMapper: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$mappers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__.ErrorResponse
        }
    },
    queryParameters: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["apiVersion"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["searchText1"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["suggesterName"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["filter1"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["useFuzzyMatching"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["highlightPostTag1"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["highlightPreTag1"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["minimumCoverage1"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["orderBy1"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["searchFields1"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["select1"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["top1"]
    ],
    urlParameters: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["endpoint"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["indexName"]
    ],
    headerParameters: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["accept"]
    ],
    serializer
};
const suggestPostOperationSpec = {
    path: "/docs/search.post.suggest",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$mappers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__.SuggestDocumentsResult
        },
        default: {
            bodyMapper: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$mappers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__.ErrorResponse
        }
    },
    requestBody: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["suggestRequest"],
    queryParameters: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["apiVersion"]
    ],
    urlParameters: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["endpoint"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["indexName"]
    ],
    headerParameters: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["accept"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["contentType"]
    ],
    mediaType: "json",
    serializer
};
const indexOperationSpec = {
    path: "/docs/search.index",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$mappers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__.IndexDocumentsResult
        },
        207: {
            bodyMapper: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$mappers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__.IndexDocumentsResult
        },
        default: {
            bodyMapper: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$mappers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__.ErrorResponse
        }
    },
    requestBody: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["batch"],
    queryParameters: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["apiVersion"]
    ],
    urlParameters: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["endpoint"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["indexName"]
    ],
    headerParameters: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["accept"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["contentType"]
    ],
    mediaType: "json",
    serializer
};
const autocompleteGetOperationSpec = {
    path: "/docs/search.autocomplete",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$mappers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__.AutocompleteResult
        },
        default: {
            bodyMapper: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$mappers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__.ErrorResponse
        }
    },
    queryParameters: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["apiVersion"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["searchText1"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["suggesterName"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["autocompleteMode"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["filter2"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["useFuzzyMatching1"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["highlightPostTag2"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["highlightPreTag2"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["minimumCoverage2"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["searchFields2"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["top2"]
    ],
    urlParameters: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["endpoint"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["indexName"]
    ],
    headerParameters: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["accept"]
    ],
    serializer
};
const autocompletePostOperationSpec = {
    path: "/docs/search.post.autocomplete",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$mappers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__.AutocompleteResult
        },
        default: {
            bodyMapper: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$mappers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__.ErrorResponse
        }
    },
    requestBody: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["autocompleteRequest"],
    queryParameters: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["apiVersion"]
    ],
    urlParameters: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["endpoint"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["indexName"]
    ],
    headerParameters: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["accept"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$models$2f$parameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["contentType"]
    ],
    mediaType: "json",
    serializer
}; //# sourceMappingURL=documents.js.map
}}),
"[project]/node_modules/@azure/search-documents/dist-esm/src/generated/data/searchClient.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */ __turbopack_context__.s({
    "SearchClient": (()=>SearchClient)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$http$2d$compat$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-http-compat/dist/esm/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$http$2d$compat$2f$dist$2f$esm$2f$extendedClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-http-compat/dist/esm/extendedClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$operations$2f$documents$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/search-documents/dist-esm/src/generated/data/operations/documents.js [app-route] (ecmascript)");
;
;
class SearchClient extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$http$2d$compat$2f$dist$2f$esm$2f$extendedClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExtendedServiceClient"] {
    /**
     * Initializes a new instance of the SearchClient class.
     * @param endpoint The endpoint URL of the search service.
     * @param indexName The name of the index.
     * @param apiVersion Api Version
     * @param options The parameter options
     */ constructor(endpoint, indexName, apiVersion, options){
        var _a, _b;
        if (endpoint === undefined) {
            throw new Error("'endpoint' cannot be null");
        }
        if (indexName === undefined) {
            throw new Error("'indexName' cannot be null");
        }
        if (apiVersion === undefined) {
            throw new Error("'apiVersion' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8"
        };
        const packageDetails = `azsdk-js-search-documents/12.1.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), {
            userAgentOptions: {
                userAgentPrefix
            },
            endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "{endpoint}/indexes('{indexName}')"
        });
        super(optionsWithDefaults);
        // Parameter assignments
        this.endpoint = endpoint;
        this.indexName = indexName;
        this.apiVersion = apiVersion;
        this.documents = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$operations$2f$documents$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DocumentsImpl"](this);
        this.addCustomApiVersionPolicy(apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */ addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            async sendRequest (request, next) {
                const param = request.url.split("?");
                if (param.length > 1) {
                    const newParams = param[1].split("&").map((item)=>{
                        if (item.indexOf("api-version") > -1) {
                            return "api-version=" + apiVersion;
                        } else {
                            return item;
                        }
                    });
                    request.url = param[0] + "?" + newParams.join("&");
                }
                return next(request);
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
} //# sourceMappingURL=searchClient.js.map
}}),
"[project]/node_modules/@azure/search-documents/dist-esm/src/indexDocumentsBatch.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Class used to perform batch operations
 * with multiple documents to the index.
 */ __turbopack_context__.s({
    "IndexDocumentsBatch": (()=>IndexDocumentsBatch)
});
class IndexDocumentsBatch {
    constructor(actions = []){
        this.actions = actions;
    }
    /**
     * Upload an array of documents to the index.
     * @param documents - The documents to upload.
     */ upload(documents) {
        const batch = documents.map((doc)=>{
            return Object.assign(Object.assign({}, doc), {
                __actionType: "upload"
            });
        });
        this.actions.push(...batch);
    }
    /**
     * Update a set of documents in the index.
     * For more details about how merging works, see https://docs.microsoft.com/en-us/rest/api/searchservice/AddUpdate-or-Delete-Documents
     * @param documents - The updated documents.
     */ merge(documents) {
        const batch = documents.map((doc)=>{
            return Object.assign(Object.assign({}, doc), {
                __actionType: "merge"
            });
        });
        this.actions.push(...batch);
    }
    /**
     * Update a set of documents in the index or uploads them if they don't exist.
     * For more details about how merging works, see https://docs.microsoft.com/en-us/rest/api/searchservice/AddUpdate-or-Delete-Documents
     * @param documents - The new/updated documents.
     */ mergeOrUpload(documents) {
        const batch = documents.map((doc)=>{
            return Object.assign(Object.assign({}, doc), {
                __actionType: "mergeOrUpload"
            });
        });
        this.actions.push(...batch);
    }
    delete(keyNameOrDocuments, keyValues) {
        if (keyValues) {
            const keyName = keyNameOrDocuments;
            const batch = keyValues.map((keyValue)=>{
                return {
                    __actionType: "delete",
                    [keyName]: keyValue
                };
            });
            this.actions.push(...batch);
        } else {
            const documents = keyNameOrDocuments;
            const batch = documents.map((document)=>{
                return Object.assign({
                    __actionType: "delete"
                }, document);
            });
            this.actions.push(...batch);
        }
    }
} //# sourceMappingURL=indexDocumentsBatch.js.map
}}),
"[project]/node_modules/@azure/search-documents/dist-esm/src/logger.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
__turbopack_context__.s({
    "logger": (()=>logger)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$logger$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/logger/dist/esm/index.js [app-route] (ecmascript)");
;
const logger = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$logger$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClientLogger"])("search"); //# sourceMappingURL=logger.js.map
}}),
"[project]/node_modules/@azure/search-documents/dist-esm/src/odataMetadataPolicy.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
__turbopack_context__.s({
    "createOdataMetadataPolicy": (()=>createOdataMetadataPolicy)
});
const AcceptHeaderName = "Accept";
const odataMetadataPolicy = "OdataMetadataPolicy";
function createOdataMetadataPolicy(metadataLevel) {
    return {
        name: odataMetadataPolicy,
        async sendRequest (request, next) {
            request.headers.set(AcceptHeaderName, `application/json;odata.metadata=${metadataLevel}`);
            return next(request);
        }
    };
} //# sourceMappingURL=odataMetadataPolicy.js.map
}}),
"[project]/node_modules/@azure/search-documents/dist-esm/src/searchApiKeyCredentialPolicy.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
__turbopack_context__.s({
    "createSearchApiKeyCredentialPolicy": (()=>createSearchApiKeyCredentialPolicy)
});
const API_KEY_HEADER_NAME = "api-key";
const searchApiKeyCredentialPolicy = "SearchApiKeyCredentialPolicy";
function createSearchApiKeyCredentialPolicy(credential) {
    return {
        name: searchApiKeyCredentialPolicy,
        async sendRequest (request, next) {
            if (!request.headers.has(API_KEY_HEADER_NAME)) {
                request.headers.set(API_KEY_HEADER_NAME, credential.key);
            }
            return next(request);
        }
    };
} //# sourceMappingURL=searchApiKeyCredentialPolicy.js.map
}}),
"[project]/node_modules/@azure/search-documents/dist-esm/src/searchAudience.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Known values for Search Audience
 */ __turbopack_context__.s({
    "KnownSearchAudience": (()=>KnownSearchAudience)
});
var KnownSearchAudience;
(function(KnownSearchAudience) {
    /**
     * Audience for Azure China
     */ KnownSearchAudience["AzureChina"] = "https://search.azure.cn";
    /**
     * Audience for Azure Government
     */ KnownSearchAudience["AzureGovernment"] = "https://search.azure.us";
    /**
     * Audience for Azure Public
     */ KnownSearchAudience["AzurePublicCloud"] = "https://search.azure.com";
})(KnownSearchAudience || (KnownSearchAudience = {})); //# sourceMappingURL=searchAudience.js.map
}}),
"[project]/node_modules/@azure/search-documents/dist-esm/src/geographyPoint.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
__turbopack_context__.s({
    "default": (()=>GeographyPoint)
});
const WorldGeodeticSystem1984 = "EPSG:4326"; // See https://epsg.io/4326
class GeographyPoint {
    /**
     * Constructs a new instance of GeographyPoint given
     * the specified coordinates.
     * @param geographyPoint - object with longitude and latitude values in decimal
     */ constructor(geographyPoint){
        this.longitude = geographyPoint.longitude;
        this.latitude = geographyPoint.latitude;
    }
    /**
     * Used to serialize to a GeoJSON Point.
     */ toJSON() {
        return {
            type: "Point",
            coordinates: [
                this.longitude,
                this.latitude
            ],
            crs: {
                type: "name",
                properties: {
                    name: WorldGeodeticSystem1984
                }
            }
        };
    }
} //# sourceMappingURL=geographyPoint.js.map
}}),
"[project]/node_modules/@azure/search-documents/dist-esm/src/walk.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
__turbopack_context__.s({
    "walk": (()=>walk)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-util/dist/esm/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$typeGuards$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-util/dist/esm/typeGuards.js [app-route] (ecmascript)");
;
function walk(v, fn) {
    var _a;
    const seen = new Set();
    const mutated = new Map();
    deepLazyApply(v);
    for (const value of mutated.values()){
        replaceChildren(value);
    }
    return (_a = mutated.get(v)) !== null && _a !== void 0 ? _a : v;
    "TURBOPACK unreachable";
    function deepLazyApply(value) {
        var _a, _b;
        if (seen.has(value)) {
            return;
        }
        seen.add(value);
        const children = getChildren((_a = cachedApply(value)) !== null && _a !== void 0 ? _a : value);
        children === null || children === void 0 ? void 0 : children.forEach(deepLazyApply);
        if (children === null || children === void 0 ? void 0 : children.some((node)=>mutated.has(node))) {
            mutated.set(value, (_b = mutated.get(value)) !== null && _b !== void 0 ? _b : shallowCopy(value));
        }
    }
    function cachedApply(value) {
        const cached = mutated.get(value);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$typeGuards$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isDefined"])(cached)) {
            return cached;
        }
        const applied = fn(value);
        if (value !== applied) {
            mutated.set(value, applied);
        }
        return mutated.get(value);
    }
    function replaceChildren(applied) {
        if (!isComplex(applied)) {
            return;
        } else if (Array.isArray(applied)) {
            applied.forEach((e, i)=>{
                var _a;
                applied[i] = (_a = mutated.get(e)) !== null && _a !== void 0 ? _a : e;
            });
        } else if (typeof applied === "object" && applied !== null) {
            Object.keys(applied).forEach((key)=>{
                var _a;
                applied[key] = (_a = mutated.get(applied[key])) !== null && _a !== void 0 ? _a : applied[key];
            });
        }
    }
}
/**
 * Array inputs SHOULD not have both complex and non-complex elements. This function determines
 * whether an array is complex based solely on the first element.
 */ function isComplex(v) {
    return Array.isArray(v) ? isComplex(v[0]) : typeof v === "object" && v !== null;
}
function getChildren(v) {
    if (!isComplex(v)) {
        return;
    }
    if (Array.isArray(v)) {
        return v;
    }
    return Object.values(v);
}
function shallowCopy(value) {
    const maybeCopy = Array.isArray(value) ? value.map((v)=>v) : typeof value === "object" && value !== null ? Object.assign({}, value) : value;
    return value === maybeCopy ? value : Object.setPrototypeOf(maybeCopy, Object.getPrototypeOf(value));
} //# sourceMappingURL=walk.js.map
}}),
"[project]/node_modules/@azure/search-documents/dist-esm/src/serialization.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
__turbopack_context__.s({
    "deserialize": (()=>deserialize),
    "serialize": (()=>serialize)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$geographyPoint$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/search-documents/dist-esm/src/geographyPoint.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$walk$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/search-documents/dist-esm/src/walk.js [app-route] (ecmascript)");
;
;
const ISO8601DateRegex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{1,3})?Z$/i;
const GeoJSONPointTypeName = "Point";
const WorldGeodeticSystem1984 = "EPSG:4326"; // See https://epsg.io/4326
const [serializeValue, deserializeValue] = [
    [
        serializeSpecialNumbers,
        serializeDates,
        serializeGeoPoint
    ],
    [
        deserializeSpecialNumbers,
        deserializeDates,
        deserializeGeoPoint
    ]
].map((fns)=>(value)=>fns.reduceRight((acc, fn)=>fn(acc), value));
function serialize(obj) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$walk$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["walk"])(obj, serializeValue);
}
function deserialize(obj) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$walk$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["walk"])(obj, deserializeValue);
}
function serializeSpecialNumbers(input) {
    if (typeof input === "number" && isNaN(input)) {
        return "NaN";
    } else if (input === Infinity) {
        return "INF";
    } else if (input === -Infinity) {
        return "-INF";
    } else {
        return input;
    }
}
function serializeDates(input) {
    return input instanceof Date ? input.toISOString() : input;
}
function serializeGeoPoint(input) {
    return input instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$geographyPoint$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"] ? input.toJSON() : input;
}
function deserializeSpecialNumbers(input) {
    switch(input){
        case "NaN":
            return NaN;
        case "-INF":
            return -Infinity;
        case "INF":
            return Infinity;
        default:
            return input;
    }
}
function deserializeDates(input) {
    return typeof input === "string" && ISO8601DateRegex.test(input) ? new Date(input) : input;
}
function deserializeGeoPoint(input) {
    if (isGeoJSONPoint(input)) {
        const [longitude, latitude] = input.coordinates;
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$geographyPoint$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]({
            longitude,
            latitude
        });
    }
    return input;
}
function isGeoJSONPoint(obj) {
    const requiredKeys = [
        "type",
        "coordinates"
    ];
    return isValidObject(obj, {
        requiredKeys,
        propertyValidator: (key)=>{
            switch(key){
                case "type":
                    return obj.type === GeoJSONPointTypeName;
                    "TURBOPACK unreachable";
                case "coordinates":
                    return isCoordinateArray(obj.coordinates);
                    "TURBOPACK unreachable";
                case "crs":
                    return isCrs(obj.crs);
                    "TURBOPACK unreachable";
                default:
                    return false;
            }
        }
    });
}
function isCoordinateArray(maybeCoordinates) {
    if (!Array.isArray(maybeCoordinates)) {
        return false;
    }
    if (maybeCoordinates.length !== 2) {
        return false;
    }
    if (typeof maybeCoordinates[0] !== "number" || typeof maybeCoordinates[1] !== "number") {
        return false;
    }
    return true;
}
function isCrs(maybeCrs) {
    return isValidObject(maybeCrs, {
        requiredKeys: [
            "type",
            "properties"
        ],
        propertyValidator: (key)=>{
            switch(key){
                case "type":
                    return maybeCrs.type === "name";
                    "TURBOPACK unreachable";
                case "properties":
                    return isCrsProperties(maybeCrs.properties);
                    "TURBOPACK unreachable";
                default:
                    return false;
            }
        }
    });
}
function isCrsProperties(maybeProperties) {
    return isValidObject(maybeProperties, {
        requiredKeys: [
            "name"
        ],
        propertyValidator: (key)=>{
            if (key === "name") {
                return maybeProperties.name === WorldGeodeticSystem1984;
            } else {
                return false;
            }
        }
    });
}
function isValidObject(obj, options = {}) {
    if (typeof obj !== "object" || obj === null) {
        return false;
    }
    const keys = Object.keys(obj);
    if (options.requiredKeys) {
        for (const requiredKey of options.requiredKeys){
            if (!keys.includes(requiredKey)) {
                return false;
            }
        }
    }
    if (options.propertyValidator) {
        for (const key of keys){
            if (!options.propertyValidator(key)) {
                return false;
            }
        }
    }
    return true;
} //# sourceMappingURL=serialization.js.map
}}),
"[project]/node_modules/@azure/search-documents/dist-esm/src/serviceModels.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
__turbopack_context__.s({
    "KnownAnalyzerNames": (()=>KnownAnalyzerNames),
    "KnownCharFilterNames": (()=>KnownCharFilterNames),
    "KnownTokenFilterNames": (()=>KnownTokenFilterNames),
    "KnownTokenizerNames": (()=>KnownTokenizerNames),
    "isComplexField": (()=>isComplexField)
});
function isComplexField(field) {
    return field.type === "Edm.ComplexType" || field.type === "Collection(Edm.ComplexType)";
}
var KnownTokenizerNames;
(function(KnownTokenizerNames) {
    /**
     * Grammar-based tokenizer that is suitable for processing most European-language documents. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/ClassicTokenizer.html
     */ KnownTokenizerNames["Classic"] = "classic";
    /**
     * Tokenizes the input from an edge into n-grams of the given size(s). See
     * https://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/EdgeNGramTokenizer.html
     */ KnownTokenizerNames["EdgeNGram"] = "edgeNGram";
    /**
     * Emits the entire input as a single token. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/KeywordTokenizer.html
     */ KnownTokenizerNames["Keyword"] = "keyword_v2";
    /**
     * Divides text at non-letters. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/LetterTokenizer.html
     */ KnownTokenizerNames["Letter"] = "letter";
    /**
     * Divides text at non-letters and converts them to lower case. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/LowerCaseTokenizer.html
     */ KnownTokenizerNames["Lowercase"] = "lowercase";
    /**
     * Divides text using language-specific rules.
     */ // eslint-disable-next-line @typescript-eslint/no-shadow
    KnownTokenizerNames["MicrosoftLanguageTokenizer"] = "microsoft_language_tokenizer";
    /**
     * Divides text using language-specific rules and reduces words to their base forms.
     */ // eslint-disable-next-line @typescript-eslint/no-shadow
    KnownTokenizerNames["MicrosoftLanguageStemmingTokenizer"] = "microsoft_language_stemming_tokenizer";
    /**
     * Tokenizes the input into n-grams of the given size(s). See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/NGramTokenizer.html
     */ KnownTokenizerNames["NGram"] = "nGram";
    /**
     * Tokenizer for path-like hierarchies. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/path/PathHierarchyTokenizer.html
     */ KnownTokenizerNames["PathHierarchy"] = "path_hierarchy_v2";
    /**
     * Tokenizer that uses regex pattern matching to construct distinct tokens. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/pattern/PatternTokenizer.html
     */ KnownTokenizerNames["Pattern"] = "pattern";
    /**
     * Standard Lucene analyzer; Composed of the standard tokenizer, lowercase filter and stop
     * filter. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/StandardTokenizer.html
     */ KnownTokenizerNames["Standard"] = "standard_v2";
    /**
     * Tokenizes urls and emails as one token. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizer.html
     */ KnownTokenizerNames["UaxUrlEmail"] = "uax_url_email";
    /**
     * Divides text at whitespace. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/WhitespaceTokenizer.html
     */ KnownTokenizerNames["Whitespace"] = "whitespace";
})(KnownTokenizerNames || (KnownTokenizerNames = {}));
var KnownTokenFilterNames;
(function(KnownTokenFilterNames) {
    /**
     * A token filter that applies the Arabic normalizer to normalize the orthography. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ar/ArabicNormalizationFilter.html
     */ KnownTokenFilterNames["ArabicNormalization"] = "arabic_normalization";
    /**
     * Strips all characters after an apostrophe (including the apostrophe itself). See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/tr/ApostropheFilter.html
     */ KnownTokenFilterNames["Apostrophe"] = "apostrophe";
    /**
     * Converts alphabetic, numeric, and symbolic Unicode characters which are not in the first 127
     * ASCII characters (the "Basic Latin" Unicode block) into their ASCII equivalents, if such
     * equivalents exist. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/ASCIIFoldingFilter.html
     */ KnownTokenFilterNames["AsciiFolding"] = "asciifolding";
    /**
     * Forms bigrams of CJK terms that are generated from StandardTokenizer. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/cjk/CJKBigramFilter.html
     */ KnownTokenFilterNames["CjkBigram"] = "cjk_bigram";
    /**
     * Normalizes CJK width differences. Folds fullwidth ASCII variants into the equivalent basic
     * Latin, and half-width Katakana variants into the equivalent Kana. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/cjk/CJKWidthFilter.html
     */ KnownTokenFilterNames["CjkWidth"] = "cjk_width";
    /**
     * Removes English possessives, and dots from acronyms. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/ClassicFilter.html
     */ KnownTokenFilterNames["Classic"] = "classic";
    /**
     * Construct bigrams for frequently occurring terms while indexing. Single terms are still
     * indexed too, with bigrams overlaid. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/commongrams/CommonGramsFilter.html
     */ KnownTokenFilterNames["CommonGram"] = "common_grams";
    /**
     * Generates n-grams of the given size(s) starting from the front or the back of an input token.
     * See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/EdgeNGramTokenFilter.html
     */ KnownTokenFilterNames["EdgeNGram"] = "edgeNGram_v2";
    /**
     * Removes elisions. For example, "l'avion" (the plane) will be converted to "avion" (plane). See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/util/ElisionFilter.html
     */ KnownTokenFilterNames["Elision"] = "elision";
    /**
     * Normalizes German characters according to the heuristics of the German2 snowball algorithm.
     * See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/de/GermanNormalizationFilter.html
     */ KnownTokenFilterNames["GermanNormalization"] = "german_normalization";
    /**
     * Normalizes text in Hindi to remove some differences in spelling variations. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/hi/HindiNormalizationFilter.html
     */ KnownTokenFilterNames["HindiNormalization"] = "hindi_normalization";
    /**
     * Normalizes the Unicode representation of text in Indian languages. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/in/IndicNormalizationFilter.html
     */ KnownTokenFilterNames["IndicNormalization"] = "indic_normalization";
    /**
     * Emits each incoming token twice, once as keyword and once as non-keyword. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/KeywordRepeatFilter.html
     */ KnownTokenFilterNames["KeywordRepeat"] = "keyword_repeat";
    /**
     * A high-performance kstem filter for English. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/en/KStemFilter.html
     */ KnownTokenFilterNames["KStem"] = "kstem";
    /**
     * Removes words that are too long or too short. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/LengthFilter.html
     */ KnownTokenFilterNames["Length"] = "length";
    /**
     * Limits the number of tokens while indexing. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/LimitTokenCountFilter.html
     */ KnownTokenFilterNames["Limit"] = "limit";
    /**
     * Normalizes token text to lower case. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/LowerCaseFilter.htm
     */ KnownTokenFilterNames["Lowercase"] = "lowercase";
    /**
     * Generates n-grams of the given size(s). See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/NGramTokenFilter.html
     */ KnownTokenFilterNames["NGram"] = "nGram_v2";
    /**
     * Applies normalization for Persian. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/fa/PersianNormalizationFilter.html
     */ KnownTokenFilterNames["PersianNormalization"] = "persian_normalization";
    /**
     * Create tokens for phonetic matches. See
     * https://lucene.apache.org/core/4_10_3/analyzers-phonetic/org/apache/lucene/analysis/phonetic/package-tree.html
     */ KnownTokenFilterNames["Phonetic"] = "phonetic";
    /**
     * Uses the Porter stemming algorithm to transform the token stream. See
     * http://tartarus.org/~martin/PorterStemmer
     */ KnownTokenFilterNames["PorterStem"] = "porter_stem";
    /**
     * Reverses the token string. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/reverse/ReverseStringFilter.html
     */ KnownTokenFilterNames["Reverse"] = "reverse";
    /**
     * Normalizes use of the interchangeable Scandinavian characters. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/ScandinavianNormalizationFilter.html
     */ KnownTokenFilterNames["ScandinavianNormalization"] = "scandinavian_normalization";
    /**
     * Folds Scandinavian characters åÅäæÄÆ-&gt;a and öÖøØ-&gt;o. It also discriminates against use
     * of double vowels aa, ae, ao, oe and oo, leaving just the first one. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/ScandinavianFoldingFilter.html
     */ KnownTokenFilterNames["ScandinavianFoldingNormalization"] = "scandinavian_folding";
    /**
     * Creates combinations of tokens as a single token. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/shingle/ShingleFilter.html
     */ KnownTokenFilterNames["Shingle"] = "shingle";
    /**
     * A filter that stems words using a Snowball-generated stemmer. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/snowball/SnowballFilter.html
     */ KnownTokenFilterNames["Snowball"] = "snowball";
    /**
     * Normalizes the Unicode representation of Sorani text. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ckb/SoraniNormalizationFilter.html
     */ KnownTokenFilterNames["SoraniNormalization"] = "sorani_normalization";
    /**
     * Language specific stemming filter. See
     * https://docs.microsoft.com/rest/api/searchservice/Custom-analyzers-in-Azure-Search#TokenFilters
     */ KnownTokenFilterNames["Stemmer"] = "stemmer";
    /**
     * Removes stop words from a token stream. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/StopFilter.html
     */ KnownTokenFilterNames["Stopwords"] = "stopwords";
    /**
     * Trims leading and trailing whitespace from tokens. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/TrimFilter.html
     */ KnownTokenFilterNames["Trim"] = "trim";
    /**
     * Truncates the terms to a specific length. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/TruncateTokenFilter.html
     */ KnownTokenFilterNames["Truncate"] = "truncate";
    /**
     * Filters out tokens with same text as the previous token. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/RemoveDuplicatesTokenFilter.html
     */ KnownTokenFilterNames["Unique"] = "unique";
    /**
     * Normalizes token text to upper case. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/UpperCaseFilter.html
     */ KnownTokenFilterNames["Uppercase"] = "uppercase";
    /**
     * Splits words into subwords and performs optional transformations on subword groups.
     */ KnownTokenFilterNames["WordDelimiter"] = "word_delimiter";
})(KnownTokenFilterNames || (KnownTokenFilterNames = {}));
var KnownCharFilterNames;
(function(KnownCharFilterNames) {
    /**
     * A character filter that attempts to strip out HTML constructs. See
     * https://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter.html
     */ KnownCharFilterNames["HtmlStrip"] = "html_strip";
})(KnownCharFilterNames || (KnownCharFilterNames = {}));
var KnownAnalyzerNames;
(function(KnownAnalyzerNames) {
    /**
     * Arabic
     */ KnownAnalyzerNames["ArMicrosoft"] = "ar.microsoft";
    /**
     * Arabic
     */ KnownAnalyzerNames["ArLucene"] = "ar.lucene";
    /**
     * Armenian
     */ KnownAnalyzerNames["HyLucene"] = "hy.lucene";
    /**
     * Bangla
     */ KnownAnalyzerNames["BnMicrosoft"] = "bn.microsoft";
    /**
     * Basque
     */ KnownAnalyzerNames["EuLucene"] = "eu.lucene";
    /**
     * Bulgarian
     */ KnownAnalyzerNames["BgMicrosoft"] = "bg.microsoft";
    /**
     * Bulgarian
     */ KnownAnalyzerNames["BgLucene"] = "bg.lucene";
    /**
     * Catalan
     */ KnownAnalyzerNames["CaMicrosoft"] = "ca.microsoft";
    /**
     * Catalan
     */ KnownAnalyzerNames["CaLucene"] = "ca.lucene";
    /**
     * Chinese Simplified
     */ KnownAnalyzerNames["ZhHansMicrosoft"] = "zh-Hans.microsoft";
    /**
     * Chinese Simplified
     */ KnownAnalyzerNames["ZhHansLucene"] = "zh-Hans.lucene";
    /**
     * Chinese Traditional
     */ KnownAnalyzerNames["ZhHantMicrosoft"] = "zh-Hant.microsoft";
    /**
     * Chinese Traditional
     */ KnownAnalyzerNames["ZhHantLucene"] = "zh-Hant.lucene";
    /**
     * Croatian
     */ KnownAnalyzerNames["HrMicrosoft"] = "hr.microsoft";
    /**
     * Czech
     */ KnownAnalyzerNames["CsMicrosoft"] = "cs.microsoft";
    /**
     * Czech
     */ KnownAnalyzerNames["CsLucene"] = "cs.lucene";
    /**
     * Danish
     */ KnownAnalyzerNames["DaMicrosoft"] = "da.microsoft";
    /**
     * Danish
     */ KnownAnalyzerNames["DaLucene"] = "da.lucene";
    /**
     * Dutch
     */ KnownAnalyzerNames["NlMicrosoft"] = "nl.microsoft";
    /**
     * Dutch
     */ KnownAnalyzerNames["NlLucene"] = "nl.lucene";
    /**
     * English
     */ KnownAnalyzerNames["EnMicrosoft"] = "en.microsoft";
    /**
     * English
     */ KnownAnalyzerNames["EnLucene"] = "en.lucene";
    /**
     * Estonian
     */ KnownAnalyzerNames["EtMicrosoft"] = "et.microsoft";
    /**
     * Finnish
     */ KnownAnalyzerNames["FiMicrosoft"] = "fi.microsoft";
    /**
     * Finnish
     */ KnownAnalyzerNames["FiLucene"] = "fi.lucene";
    /**
     * French
     */ KnownAnalyzerNames["FrMicrosoft"] = "fr.microsoft";
    /**
     * French
     */ KnownAnalyzerNames["FrLucene"] = "fr.lucene";
    /**
     * Galician
     */ KnownAnalyzerNames["GlLucene"] = "gl.lucene";
    /**
     * German
     */ KnownAnalyzerNames["DeMicrosoft"] = "de.microsoft";
    /**
     * German
     */ KnownAnalyzerNames["DeLucene"] = "de.lucene";
    /**
     * Greek
     */ KnownAnalyzerNames["ElMicrosoft"] = "el.microsoft";
    /**
     * Greek
     */ KnownAnalyzerNames["ElLucene"] = "el.lucene";
    /**
     * Gujarati
     */ KnownAnalyzerNames["GuMicrosoft"] = "gu.microsoft";
    /**
     * Hebrew
     */ KnownAnalyzerNames["HeMicrosoft"] = "he.microsoft";
    /**
     * Hindi
     */ KnownAnalyzerNames["HiMicrosoft"] = "hi.microsoft";
    /**
     * Hindi
     */ KnownAnalyzerNames["HiLucene"] = "hi.lucene";
    /**
     * Hungarian
     */ KnownAnalyzerNames["HuMicrosoft"] = "hu.microsoft";
    /**
     * Hungarian
     */ KnownAnalyzerNames["HuLucene"] = "hu.lucene";
    /**
     * Icelandic
     */ KnownAnalyzerNames["IsMicrosoft"] = "is.microsoft";
    /**
     * Indonesian (Bahasa)
     */ KnownAnalyzerNames["IdMicrosoft"] = "id.microsoft";
    /**
     * Indonesian (Bahasa)
     */ KnownAnalyzerNames["IdLucene"] = "id.lucene";
    /**
     * Irish
     */ KnownAnalyzerNames["GaLucene"] = "ga.lucene";
    /**
     * Italian
     */ KnownAnalyzerNames["ItMicrosoft"] = "it.microsoft";
    /**
     * Italian
     */ KnownAnalyzerNames["ItLucene"] = "it.lucene";
    /**
     * Japanese
     */ KnownAnalyzerNames["JaMicrosoft"] = "ja.microsoft";
    /**
     * Japanese
     */ KnownAnalyzerNames["JaLucene"] = "ja.lucene";
    /**
     * Kannada
     */ KnownAnalyzerNames["KnMicrosoft"] = "kn.microsoft";
    /**
     * Korean
     */ KnownAnalyzerNames["KoMicrosoft"] = "ko.microsoft";
    /**
     * Korean
     */ KnownAnalyzerNames["KoLucene"] = "ko.lucene";
    /**
     * Latvian
     */ KnownAnalyzerNames["LvMicrosoft"] = "lv.microsoft";
    /**
     * Latvian
     */ KnownAnalyzerNames["LvLucene"] = "lv.lucene";
    /**
     * Lithuanian
     */ KnownAnalyzerNames["LtMicrosoft"] = "lt.microsoft";
    /**
     * Malayalam
     */ KnownAnalyzerNames["MlMicrosoft"] = "ml.microsoft";
    /**
     * Malay (Latin)
     */ KnownAnalyzerNames["MsMicrosoft"] = "ms.microsoft";
    /**
     * Marathi
     */ KnownAnalyzerNames["MrMicrosoft"] = "mr.microsoft";
    /**
     * Norwegian
     */ KnownAnalyzerNames["NbMicrosoft"] = "nb.microsoft";
    /**
     * Norwegian
     */ KnownAnalyzerNames["NoLucene"] = "no.lucene";
    /**
     * Persian
     */ KnownAnalyzerNames["FaLucene"] = "fa.lucene";
    /**
     * Polish
     */ KnownAnalyzerNames["PlMicrosoft"] = "pl.microsoft";
    /**
     * Polish
     */ KnownAnalyzerNames["PlLucene"] = "pl.lucene";
    /**
     * Portuguese (Brazil)
     */ KnownAnalyzerNames["PtBRMicrosoft"] = "pt-BR.microsoft";
    /**
     * Portuguese (Brazil)
     */ KnownAnalyzerNames["PtBRLucene"] = "pt-BR.lucene";
    /**
     * Portuguese (Portugal)
     */ KnownAnalyzerNames["PtPTMicrosoft"] = "pt-PT.microsoft";
    /**
     * Portuguese (Portugal)
     */ KnownAnalyzerNames["PtPTLucene"] = "pt-PT.lucene";
    /**
     * Punjabi
     */ KnownAnalyzerNames["PaMicrosoft"] = "pa.microsoft";
    /**
     * Romanian
     */ KnownAnalyzerNames["RoMicrosoft"] = "ro.microsoft";
    /**
     * Romanian
     */ KnownAnalyzerNames["RoLucene"] = "ro.lucene";
    /**
     * Russian
     */ KnownAnalyzerNames["RuMicrosoft"] = "ru.microsoft";
    /**
     * Russian
     */ KnownAnalyzerNames["RuLucene"] = "ru.lucene";
    /**
     * Serbian (Cyrillic)
     */ KnownAnalyzerNames["SrCyrillicMicrosoft"] = "sr-cyrillic.microsoft";
    /**
     * Serbian (Latin)
     */ KnownAnalyzerNames["SrLatinMicrosoft"] = "sr-latin.microsoft";
    /**
     * Slovak
     */ KnownAnalyzerNames["SkMicrosoft"] = "sk.microsoft";
    /**
     * Slovenian
     */ KnownAnalyzerNames["SlMicrosoft"] = "sl.microsoft";
    /**
     * Spanish
     */ KnownAnalyzerNames["EsMicrosoft"] = "es.microsoft";
    /**
     * Spanish
     */ KnownAnalyzerNames["EsLucene"] = "es.lucene";
    /**
     * Swedish
     */ KnownAnalyzerNames["SvMicrosoft"] = "sv.microsoft";
    /**
     * Swedish
     */ KnownAnalyzerNames["SvLucene"] = "sv.lucene";
    /**
     * Tamil
     */ KnownAnalyzerNames["TaMicrosoft"] = "ta.microsoft";
    /**
     * Telugu
     */ KnownAnalyzerNames["TeMicrosoft"] = "te.microsoft";
    /**
     * Thai
     */ KnownAnalyzerNames["ThMicrosoft"] = "th.microsoft";
    /**
     * Thai
     */ KnownAnalyzerNames["ThLucene"] = "th.lucene";
    /**
     * Turkish
     */ KnownAnalyzerNames["TrMicrosoft"] = "tr.microsoft";
    /**
     * Turkish
     */ KnownAnalyzerNames["TrLucene"] = "tr.lucene";
    /**
     * Ukrainian
     */ KnownAnalyzerNames["UkMicrosoft"] = "uk.microsoft";
    /**
     * Urdu
     */ KnownAnalyzerNames["UrMicrosoft"] = "ur.microsoft";
    /**
     * Vietnamese
     */ KnownAnalyzerNames["ViMicrosoft"] = "vi.microsoft";
    /**
     * See: https://lucene.apache.org/core/6_6_1/core/org/apache/lucene/analysis/standard/StandardAnalyzer.html
     */ KnownAnalyzerNames["StandardLucene"] = "standard.lucene";
    /**
     * See https://lucene.apache.org/core/6_6_1/analyzers-common/org/apache/lucene/analysis/miscellaneous/ASCIIFoldingFilter.html
     */ KnownAnalyzerNames["StandardAsciiFoldingLucene"] = "standardasciifolding.lucene";
    /**
     * Treats the entire content of a field as a single token. This is useful for data like zip codes, ids, and some product names.
     */ KnownAnalyzerNames["Keyword"] = "keyword";
    /**
     * Flexibly separates text into terms via a regular expression pattern.
     */ KnownAnalyzerNames["Pattern"] = "pattern";
    /**
     * Divides text at non-letters and converts them to lower case.
     */ KnownAnalyzerNames["Simple"] = "simple";
    /**
     * Divides text at non-letters; Applies the lowercase and stopword token filters.
     */ KnownAnalyzerNames["Stop"] = "stop";
    /**
     * An analyzer that uses the whitespace tokenizer.
     */ KnownAnalyzerNames["Whitespace"] = "whitespace";
})(KnownAnalyzerNames || (KnownAnalyzerNames = {})); // END manually modified generated interfaces
 //# sourceMappingURL=serviceModels.js.map
}}),
"[project]/node_modules/@azure/search-documents/dist-esm/src/serviceUtils.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
__turbopack_context__.s({
    "convertCognitiveServicesAccountToGenerated": (()=>convertCognitiveServicesAccountToGenerated),
    "convertCognitiveServicesAccountToPublic": (()=>convertCognitiveServicesAccountToPublic),
    "convertDataChangeDetectionPolicyToPublic": (()=>convertDataChangeDetectionPolicyToPublic),
    "convertDataDeletionDetectionPolicyToPublic": (()=>convertDataDeletionDetectionPolicyToPublic),
    "convertFieldsToGenerated": (()=>convertFieldsToGenerated),
    "convertFieldsToPublic": (()=>convertFieldsToPublic),
    "convertSearchIndexerDataIdentityToPublic": (()=>convertSearchIndexerDataIdentityToPublic),
    "convertSimilarityToGenerated": (()=>convertSimilarityToGenerated),
    "convertSimilarityToPublic": (()=>convertSimilarityToPublic),
    "convertSkillsToPublic": (()=>convertSkillsToPublic),
    "convertTokenFiltersToGenerated": (()=>convertTokenFiltersToGenerated),
    "defaultServiceVersion": (()=>defaultServiceVersion),
    "generatedDataSourceToPublicDataSource": (()=>generatedDataSourceToPublicDataSource),
    "generatedIndexToPublicIndex": (()=>generatedIndexToPublicIndex),
    "generatedSearchIndexerToPublicSearchIndexer": (()=>generatedSearchIndexerToPublicSearchIndexer),
    "generatedSearchResultToPublicSearchResult": (()=>generatedSearchResultToPublicSearchResult),
    "generatedSkillsetToPublicSkillset": (()=>generatedSkillsetToPublicSkillset),
    "generatedSuggestDocumentsResultToPublicSuggestDocumentsResult": (()=>generatedSuggestDocumentsResultToPublicSuggestDocumentsResult),
    "generatedSynonymMapToPublicSynonymMap": (()=>generatedSynonymMapToPublicSynonymMap),
    "generatedVectorSearchAlgorithmConfigurationToPublicVectorSearchAlgorithmConfiguration": (()=>generatedVectorSearchAlgorithmConfigurationToPublicVectorSearchAlgorithmConfiguration),
    "generatedVectorSearchToPublicVectorSearch": (()=>generatedVectorSearchToPublicVectorSearch),
    "generatedVectorSearchVectorizerToPublicVectorizer": (()=>generatedVectorSearchVectorizerToPublicVectorizer),
    "getRandomIntegerInclusive": (()=>getRandomIntegerInclusive),
    "publicDataSourceToGeneratedDataSource": (()=>publicDataSourceToGeneratedDataSource),
    "publicIndexToGeneratedIndex": (()=>publicIndexToGeneratedIndex),
    "publicSearchIndexerToGeneratedSearchIndexer": (()=>publicSearchIndexerToGeneratedSearchIndexer),
    "publicSkillsetToGeneratedSkillset": (()=>publicSkillsetToGeneratedSkillset),
    "publicSynonymMapToGeneratedSynonymMap": (()=>publicSynonymMapToGeneratedSynonymMap)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$logger$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/search-documents/dist-esm/src/logger.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$serviceModels$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/search-documents/dist-esm/src/serviceModels.js [app-route] (ecmascript)");
;
;
;
const defaultServiceVersion = "2024-07-01";
const knownSkills = {
    "#Microsoft.Skills.Custom.WebApiSkill": true,
    "#Microsoft.Skills.Text.AzureOpenAIEmbeddingSkill": true,
    "#Microsoft.Skills.Text.CustomEntityLookupSkill": true,
    "#Microsoft.Skills.Text.EntityRecognitionSkill": true,
    "#Microsoft.Skills.Text.KeyPhraseExtractionSkill": true,
    "#Microsoft.Skills.Text.LanguageDetectionSkill": true,
    "#Microsoft.Skills.Text.MergeSkill": true,
    "#Microsoft.Skills.Text.PIIDetectionSkill": true,
    "#Microsoft.Skills.Text.SentimentSkill": true,
    "#Microsoft.Skills.Text.SplitSkill": true,
    "#Microsoft.Skills.Text.TranslationSkill": true,
    "#Microsoft.Skills.Text.V3.EntityLinkingSkill": true,
    "#Microsoft.Skills.Text.V3.EntityRecognitionSkill": true,
    "#Microsoft.Skills.Text.V3.SentimentSkill": true,
    "#Microsoft.Skills.Util.ConditionalSkill": true,
    "#Microsoft.Skills.Util.DocumentExtractionSkill": true,
    "#Microsoft.Skills.Util.ShaperSkill": true,
    "#Microsoft.Skills.Vision.ImageAnalysisSkill": true,
    "#Microsoft.Skills.Vision.OcrSkill": true
};
function convertSkillsToPublic(skills) {
    if (!skills) {
        return skills;
    }
    // This validation has already GAed
    return skills.filter((skill)=>knownSkills[skill.odatatype]);
}
function convertCognitiveServicesAccountToGenerated(cognitiveServicesAccount) {
    if (!cognitiveServicesAccount) {
        return cognitiveServicesAccount;
    }
    return cognitiveServicesAccount;
}
function convertCognitiveServicesAccountToPublic(cognitiveServicesAccount) {
    if (!cognitiveServicesAccount) {
        return cognitiveServicesAccount;
    }
    if (cognitiveServicesAccount.odatatype === "#Microsoft.Azure.Search.DefaultCognitiveServices") {
        return cognitiveServicesAccount;
    } else {
        return cognitiveServicesAccount;
    }
}
function convertTokenFiltersToGenerated(tokenFilters) {
    if (!tokenFilters) {
        return tokenFilters;
    }
    const result = [];
    for (const filter of tokenFilters){
        result.push(filter);
    }
    return result;
}
function convertAnalyzersToGenerated(analyzers) {
    if (!analyzers) {
        return analyzers;
    }
    const result = [];
    for (const analyzer of analyzers){
        switch(analyzer.odatatype){
            case "#Microsoft.Azure.Search.StandardAnalyzer":
            case "#Microsoft.Azure.Search.StopAnalyzer":
                result.push(analyzer);
                break;
            case "#Microsoft.Azure.Search.PatternAnalyzer":
                result.push(Object.assign(Object.assign({}, analyzer), {
                    flags: analyzer.flags ? analyzer.flags.join("|") : undefined
                }));
                break;
            case "#Microsoft.Azure.Search.CustomAnalyzer":
                result.push(Object.assign(Object.assign({}, analyzer), {
                    tokenizerName: analyzer.tokenizerName
                }));
                break;
        }
    }
    return result;
}
function convertAnalyzersToPublic(analyzers) {
    if (!analyzers) {
        return analyzers;
    }
    const result = [];
    for (const analyzer of analyzers){
        switch(analyzer.odatatype){
            case "#Microsoft.Azure.Search.StandardAnalyzer":
                result.push(analyzer);
                break;
            case "#Microsoft.Azure.Search.StopAnalyzer":
                result.push(analyzer);
                break;
            case "#Microsoft.Azure.Search.PatternAnalyzer":
                result.push(Object.assign(Object.assign({}, analyzer), {
                    flags: analyzer.flags ? analyzer.flags.split("|") : undefined
                }));
                break;
            case "#Microsoft.Azure.Search.CustomAnalyzer":
                result.push(analyzer);
                break;
        }
    }
    return result;
}
function convertFieldsToPublic(fields) {
    if (!fields) {
        return fields;
    }
    return fields.map((field)=>{
        if (field.type === "Collection(Edm.ComplexType)" || field.type === "Edm.ComplexType") {
            const result = {
                name: field.name,
                type: field.type,
                fields: convertFieldsToPublic(field.fields)
            };
            return result;
        } else {
            const type = field.type;
            const synonymMapNames = field.synonymMaps;
            const { retrievable, analyzer, searchAnalyzer, indexAnalyzer } = field, restField = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__rest"])(field, [
                "retrievable",
                "analyzer",
                "searchAnalyzer",
                "indexAnalyzer"
            ]);
            const hidden = typeof retrievable === "boolean" ? !retrievable : retrievable;
            const result = Object.assign(Object.assign({}, restField), {
                type,
                hidden,
                analyzerName: analyzer,
                searchAnalyzerName: searchAnalyzer,
                indexAnalyzerName: indexAnalyzer,
                synonymMapNames
            });
            return result;
        }
    });
}
function convertFieldsToGenerated(fields) {
    return fields.map((field)=>{
        var _a, _b, _c, _d;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$serviceModels$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isComplexField"])(field)) {
            return {
                name: field.name,
                type: field.type,
                fields: field.fields ? convertFieldsToGenerated(field.fields) : field.fields
            };
        } else {
            const { hidden } = field, restField = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__rest"])(field, [
                "hidden"
            ]);
            const retrievable = typeof hidden === "boolean" ? !hidden : hidden;
            return Object.assign(Object.assign({}, restField), {
                retrievable,
                // modify API defaults to use less storage for simple types
                searchable: (_a = field.searchable) !== null && _a !== void 0 ? _a : false,
                filterable: (_b = field.filterable) !== null && _b !== void 0 ? _b : false,
                facetable: (_c = field.facetable) !== null && _c !== void 0 ? _c : false,
                sortable: (_d = field.sortable) !== null && _d !== void 0 ? _d : false,
                analyzer: field.analyzerName,
                searchAnalyzer: field.searchAnalyzerName,
                indexAnalyzer: field.indexAnalyzerName,
                synonymMaps: field.synonymMapNames
            });
        }
    });
}
function convertTokenizersToGenerated(tokenizers) {
    if (!tokenizers) {
        return tokenizers;
    }
    const result = [];
    for (const tokenizer of tokenizers){
        if (tokenizer.odatatype === "#Microsoft.Azure.Search.PatternTokenizer") {
            result.push(Object.assign(Object.assign({}, tokenizer), {
                flags: tokenizer.flags ? tokenizer.flags.join("|") : undefined
            }));
        } else {
            result.push(tokenizer);
        }
    }
    return result;
}
function convertTokenizersToPublic(tokenizers) {
    var _a;
    if (!tokenizers) {
        return tokenizers;
    }
    const result = [];
    for (const tokenizer of tokenizers){
        if (tokenizer.odatatype === "#Microsoft.Azure.Search.PatternTokenizer") {
            const patternTokenizer = tokenizer;
            const flags = (_a = patternTokenizer.flags) === null || _a === void 0 ? void 0 : _a.split("|");
            result.push(Object.assign(Object.assign({}, tokenizer), {
                flags
            }));
        } else {
            result.push(tokenizer);
        }
    }
    return result;
}
function convertSimilarityToGenerated(similarity) {
    if (!similarity) {
        return similarity;
    }
    return similarity;
}
function convertSimilarityToPublic(similarity) {
    if (!similarity) {
        return similarity;
    }
    if (similarity.odatatype === "#Microsoft.Azure.Search.ClassicSimilarity") {
        return similarity;
    } else {
        return similarity;
    }
}
function convertEncryptionKeyToPublic(encryptionKey) {
    if (!encryptionKey) {
        return encryptionKey;
    }
    const result = {
        keyName: encryptionKey.keyName,
        keyVersion: encryptionKey.keyVersion,
        vaultUrl: encryptionKey.vaultUri
    };
    if (encryptionKey.accessCredentials) {
        result.applicationId = encryptionKey.accessCredentials.applicationId;
        result.applicationSecret = encryptionKey.accessCredentials.applicationSecret;
    }
    return result;
}
function convertEncryptionKeyToGenerated(encryptionKey) {
    if (!encryptionKey) {
        return encryptionKey;
    }
    const result = {
        keyName: encryptionKey.keyName,
        keyVersion: encryptionKey.keyVersion,
        vaultUri: encryptionKey.vaultUrl
    };
    if (encryptionKey.applicationId) {
        result.accessCredentials = {
            applicationId: encryptionKey.applicationId,
            applicationSecret: encryptionKey.applicationSecret
        };
    }
    return result;
}
function generatedIndexToPublicIndex(generatedIndex) {
    return {
        name: generatedIndex.name,
        defaultScoringProfile: generatedIndex.defaultScoringProfile,
        corsOptions: generatedIndex.corsOptions,
        suggesters: generatedIndex.suggesters,
        encryptionKey: convertEncryptionKeyToPublic(generatedIndex.encryptionKey),
        etag: generatedIndex.etag,
        analyzers: convertAnalyzersToPublic(generatedIndex.analyzers),
        tokenizers: convertTokenizersToPublic(generatedIndex.tokenizers),
        tokenFilters: generatedIndex.tokenFilters,
        charFilters: generatedIndex.charFilters,
        scoringProfiles: generatedIndex.scoringProfiles,
        fields: convertFieldsToPublic(generatedIndex.fields),
        similarity: convertSimilarityToPublic(generatedIndex.similarity),
        semanticSearch: generatedIndex.semanticSearch,
        vectorSearch: generatedVectorSearchToPublicVectorSearch(generatedIndex.vectorSearch)
    };
}
function generatedVectorSearchVectorizerToPublicVectorizer(generatedVectorizer) {
    if (!generatedVectorizer) {
        return generatedVectorizer;
    }
    switch(generatedVectorizer.kind){
        case "azureOpenAI":
            {
                const { parameters } = generatedVectorizer;
                const authIdentity = convertSearchIndexerDataIdentityToPublic(parameters === null || parameters === void 0 ? void 0 : parameters.authIdentity);
                const vectorizer = Object.assign(Object.assign({}, generatedVectorizer), {
                    parameters: Object.assign(Object.assign({}, parameters), {
                        authIdentity
                    })
                });
                return vectorizer;
            }
        case "customWebApi":
            {
                const { parameters } = generatedVectorizer;
                const authIdentity = convertSearchIndexerDataIdentityToPublic(parameters === null || parameters === void 0 ? void 0 : parameters.authIdentity);
                const vectorizer = Object.assign(Object.assign({}, generatedVectorizer), {
                    parameters: Object.assign(Object.assign({}, parameters), {
                        authIdentity
                    })
                });
                return vectorizer;
            }
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$logger$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].warning(`Unsupported vectorizer kind: ${generatedVectorizer.kind}`);
    return generatedVectorizer;
}
function generatedVectorSearchAlgorithmConfigurationToPublicVectorSearchAlgorithmConfiguration(generatedAlgorithmConfiguration) {
    var _a;
    if (!generatedAlgorithmConfiguration) {
        return generatedAlgorithmConfiguration;
    }
    if ([
        "hnsw",
        "exhaustiveKnn"
    ].includes(generatedAlgorithmConfiguration.kind)) {
        const algorithmConfiguration = generatedAlgorithmConfiguration;
        const metric = (_a = algorithmConfiguration.parameters) === null || _a === void 0 ? void 0 : _a.metric;
        return Object.assign(Object.assign({}, algorithmConfiguration), {
            parameters: Object.assign(Object.assign({}, algorithmConfiguration.parameters), {
                metric
            })
        });
    }
    throw Error("Unsupported algorithm configuration");
}
function generatedVectorSearchToPublicVectorSearch(vectorSearch) {
    var _a, _b;
    if (!vectorSearch) {
        return vectorSearch;
    }
    return Object.assign(Object.assign({}, vectorSearch), {
        algorithms: (_a = vectorSearch.algorithms) === null || _a === void 0 ? void 0 : _a.map(generatedVectorSearchAlgorithmConfigurationToPublicVectorSearchAlgorithmConfiguration),
        vectorizers: (_b = vectorSearch.vectorizers) === null || _b === void 0 ? void 0 : _b.map(generatedVectorSearchVectorizerToPublicVectorizer)
    });
}
function generatedSearchResultToPublicSearchResult(results) {
    const returnValues = results.map((result)=>{
        const { _score: score, _highlights: highlights, _rerankerScore: rerankerScore, _captions: captions } = result, restProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__rest"])(result, [
            "_score",
            "_highlights",
            "_rerankerScore",
            "_captions"
        ]);
        const obj = {
            score,
            highlights,
            rerankerScore,
            captions,
            document: restProps
        };
        return obj;
    });
    return returnValues;
}
function generatedSuggestDocumentsResultToPublicSuggestDocumentsResult(searchDocumentsResult) {
    const results = searchDocumentsResult.results.map((element)=>{
        const { _text } = element, restProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__rest"])(element, [
            "_text"
        ]);
        const obj = {
            text: _text,
            document: restProps
        };
        return obj;
    });
    const result = {
        results: results,
        coverage: searchDocumentsResult.coverage
    };
    return result;
}
function publicIndexToGeneratedIndex(index) {
    const { encryptionKey, tokenFilters, analyzers, tokenizers, fields, similarity } = index;
    return Object.assign(Object.assign({}, index), {
        encryptionKey: convertEncryptionKeyToGenerated(encryptionKey),
        tokenFilters: convertTokenFiltersToGenerated(tokenFilters),
        analyzers: convertAnalyzersToGenerated(analyzers),
        tokenizers: convertTokenizersToGenerated(tokenizers),
        fields: convertFieldsToGenerated(fields),
        similarity: convertSimilarityToGenerated(similarity)
    });
}
function generatedSkillsetToPublicSkillset(generatedSkillset) {
    const { skills, cognitiveServicesAccount, encryptionKey, indexProjection } = generatedSkillset, props = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__rest"])(generatedSkillset, [
        "skills",
        "cognitiveServicesAccount",
        "encryptionKey",
        "indexProjection"
    ]);
    return Object.assign(Object.assign({}, props), {
        skills: convertSkillsToPublic(skills),
        cognitiveServicesAccount: convertCognitiveServicesAccountToPublic(cognitiveServicesAccount),
        encryptionKey: convertEncryptionKeyToPublic(encryptionKey),
        indexProjection: indexProjection
    });
}
function publicSkillsetToGeneratedSkillset(skillset) {
    return Object.assign(Object.assign({}, skillset), {
        name: skillset.name,
        description: skillset.description,
        etag: skillset.etag,
        skills: skillset.skills,
        cognitiveServicesAccount: convertCognitiveServicesAccountToGenerated(skillset.cognitiveServicesAccount),
        knowledgeStore: skillset.knowledgeStore,
        encryptionKey: convertEncryptionKeyToGenerated(skillset.encryptionKey)
    });
}
function generatedSynonymMapToPublicSynonymMap(synonymMap) {
    const result = {
        name: synonymMap.name,
        encryptionKey: convertEncryptionKeyToPublic(synonymMap.encryptionKey),
        etag: synonymMap.etag,
        synonyms: []
    };
    if (synonymMap.synonyms) {
        result.synonyms = synonymMap.synonyms.split("\n");
    }
    return result;
}
function publicSynonymMapToGeneratedSynonymMap(synonymMap) {
    const result = {
        name: synonymMap.name,
        format: "solr",
        encryptionKey: convertEncryptionKeyToGenerated(synonymMap.encryptionKey),
        etag: synonymMap.etag,
        synonyms: synonymMap.synonyms.join("\n")
    };
    result.encryptionKey = convertEncryptionKeyToGenerated(synonymMap.encryptionKey);
    return result;
}
function publicSearchIndexerToGeneratedSearchIndexer(indexer) {
    return Object.assign(Object.assign({}, indexer), {
        encryptionKey: convertEncryptionKeyToGenerated(indexer.encryptionKey)
    });
}
function generatedSearchIndexerToPublicSearchIndexer(indexer) {
    var _a, _b, _c, _d;
    const { parsingMode, dataToExtract, imageAction, pdfTextRotationAlgorithm, executionEnvironment } = (_b = (_a = indexer.parameters) === null || _a === void 0 ? void 0 : _a.configuration) !== null && _b !== void 0 ? _b : {};
    const configuration = ((_c = indexer.parameters) === null || _c === void 0 ? void 0 : _c.configuration) && Object.assign(Object.assign({}, (_d = indexer.parameters) === null || _d === void 0 ? void 0 : _d.configuration), {
        parsingMode: parsingMode,
        dataToExtract: dataToExtract,
        imageAction: imageAction,
        pdfTextRotationAlgorithm: pdfTextRotationAlgorithm,
        executionEnvironment: executionEnvironment
    });
    const parameters = Object.assign(Object.assign({}, indexer.parameters), {
        configuration
    });
    return Object.assign(Object.assign({}, indexer), {
        parameters,
        encryptionKey: convertEncryptionKeyToPublic(indexer.encryptionKey)
    });
}
function publicDataSourceToGeneratedDataSource(dataSource) {
    return {
        name: dataSource.name,
        description: dataSource.description,
        type: dataSource.type,
        credentials: {
            connectionString: dataSource.connectionString
        },
        container: dataSource.container,
        etag: dataSource.etag,
        dataChangeDetectionPolicy: dataSource.dataChangeDetectionPolicy,
        dataDeletionDetectionPolicy: dataSource.dataDeletionDetectionPolicy,
        encryptionKey: convertEncryptionKeyToGenerated(dataSource.encryptionKey)
    };
}
function generatedDataSourceToPublicDataSource(dataSource) {
    return {
        name: dataSource.name,
        description: dataSource.name,
        type: dataSource.type,
        connectionString: dataSource.credentials.connectionString,
        container: dataSource.container,
        etag: dataSource.etag,
        dataChangeDetectionPolicy: convertDataChangeDetectionPolicyToPublic(dataSource.dataChangeDetectionPolicy),
        dataDeletionDetectionPolicy: convertDataDeletionDetectionPolicyToPublic(dataSource.dataDeletionDetectionPolicy),
        encryptionKey: convertEncryptionKeyToPublic(dataSource.encryptionKey)
    };
}
function convertSearchIndexerDataIdentityToPublic(searchIndexerDataIdentity) {
    if (!searchIndexerDataIdentity) {
        return searchIndexerDataIdentity;
    }
    if (searchIndexerDataIdentity.odatatype === "#Microsoft.Azure.Search.DataNoneIdentity") {
        return searchIndexerDataIdentity;
    } else {
        return searchIndexerDataIdentity;
    }
}
function convertDataChangeDetectionPolicyToPublic(dataChangeDetectionPolicy) {
    if (!dataChangeDetectionPolicy) {
        return dataChangeDetectionPolicy;
    }
    if (dataChangeDetectionPolicy.odatatype === "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy") {
        return dataChangeDetectionPolicy;
    } else {
        return dataChangeDetectionPolicy;
    }
}
function convertDataDeletionDetectionPolicyToPublic(dataDeletionDetectionPolicy) {
    if (!dataDeletionDetectionPolicy) {
        return dataDeletionDetectionPolicy;
    }
    return dataDeletionDetectionPolicy;
}
function getRandomIntegerInclusive(min, max) {
    // Make sure inputs are integers.
    min = Math.ceil(min);
    max = Math.floor(max);
    // Pick a random offset from zero to the size of the range.
    // Since Math.random() can never return 1, we have to make the range one larger
    // in order to be inclusive of the maximum value after we take the floor.
    const offset = Math.floor(Math.random() * (max - min + 1));
    return offset + min;
} //# sourceMappingURL=serviceUtils.js.map
}}),
"[project]/node_modules/@azure/search-documents/dist-esm/src/tracing.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
__turbopack_context__.s({
    "createSpan": (()=>createSpan)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$tracing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-tracing/dist/esm/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$tracing$2f$dist$2f$esm$2f$tracingClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-tracing/dist/esm/tracingClient.js [app-route] (ecmascript)");
;
/**
 * Creates a tracing client using the global tracer.
 * @internal
 */ const tracingClient = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$tracing$2f$dist$2f$esm$2f$tracingClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createTracingClient"])({
    namespace: "Microsoft.Search",
    packageName: "Azure.Search"
});
const createSpan = tracingClient.startSpan; //# sourceMappingURL=tracing.js.map
}}),
"[project]/node_modules/@azure/search-documents/dist-esm/src/searchClient.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
__turbopack_context__.s({
    "SearchClient": (()=>SearchClient)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
/// <reference lib="esnext.asynciterable" />
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$auth$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-auth/dist/esm/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$auth$2f$dist$2f$esm$2f$tokenCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-auth/dist/esm/tokenCredential.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-rest-pipeline/dist/esm/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$policies$2f$bearerTokenAuthenticationPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-rest-pipeline/dist/esm/policies/bearerTokenAuthenticationPolicy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$base64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/search-documents/dist-esm/src/base64.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$searchClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/search-documents/dist-esm/src/generated/data/searchClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$indexDocumentsBatch$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/search-documents/dist-esm/src/indexDocumentsBatch.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$logger$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/search-documents/dist-esm/src/logger.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$odataMetadataPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/search-documents/dist-esm/src/odataMetadataPolicy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$searchApiKeyCredentialPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/search-documents/dist-esm/src/searchApiKeyCredentialPolicy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$searchAudience$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/search-documents/dist-esm/src/searchAudience.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$serialization$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/search-documents/dist-esm/src/serialization.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$serviceUtils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/search-documents/dist-esm/src/serviceUtils.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/search-documents/dist-esm/src/tracing.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
class SearchClient {
    /**
     * Creates an instance of SearchClient.
     *
     * Example usage:
     * ```ts
     * const { SearchClient, AzureKeyCredential } = require("@azure/search-documents");
     *
     * const client = new SearchClient(
     *   "<endpoint>",
     *   "<indexName>",
     *   new AzureKeyCredential("<Admin Key>")
     * );
     * ```
     *
     * Optionally, the type of the model can be used to enable strong typing and type hints:
     * ```ts
     * type TModel = {
     *   keyName: string;
     *   field1?: string | null;
     *   field2?: { anotherField?: string | null } | null;
     * };
     *
     * const client = new SearchClient<TModel>(
     *   ...
     * );
     * ```
     *
     * @param endpoint - The endpoint of the search service
     * @param indexName - The name of the index
     * @param credential - Used to authenticate requests to the service.
     * @param options - Used to configure the Search client.
     *
     * @typeParam TModel - An optional type that represents the documents stored in
     * the search index. For the best typing experience, all non-key fields should
     * be marked optional and nullable, and the key property should have the
     * non-nullable type `string`.
     */ constructor(endpoint, indexName, credential, options = {}){
        var _a, _b;
        /// Maintenance note: when updating supported API versions,
        /// the ContinuationToken logic will need to be updated below.
        /**
         *  The service version to use when communicating with the service.
         */ this.serviceVersion = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$serviceUtils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultServiceVersion"];
        /**
         * The API version to use when communicating with the service.
         * @deprecated use {@Link serviceVersion} instead
         */ this.apiVersion = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$serviceUtils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultServiceVersion"];
        this.endpoint = endpoint;
        this.indexName = indexName;
        const internalClientPipelineOptions = Object.assign(Object.assign({}, options), {
            loggingOptions: {
                logger: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$logger$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].info,
                additionalAllowedHeaderNames: [
                    "elapsed-time",
                    "Location",
                    "OData-MaxVersion",
                    "OData-Version",
                    "Prefer",
                    "throttle-reason"
                ]
            }
        });
        this.serviceVersion = (_b = (_a = options.serviceVersion) !== null && _a !== void 0 ? _a : options.apiVersion) !== null && _b !== void 0 ? _b : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$serviceUtils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultServiceVersion"];
        this.apiVersion = this.serviceVersion;
        this.client = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$generated$2f$data$2f$searchClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SearchClient"](this.endpoint, this.indexName, this.serviceVersion, internalClientPipelineOptions);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$auth$2f$dist$2f$esm$2f$tokenCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenCredential"])(credential)) {
            const scope = options.audience ? `${options.audience}/.default` : `${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$searchAudience$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["KnownSearchAudience"].AzurePublicCloud}/.default`;
            this.client.pipeline.addPolicy((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$policies$2f$bearerTokenAuthenticationPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["bearerTokenAuthenticationPolicy"])({
                credential,
                scopes: scope
            }));
        } else {
            this.client.pipeline.addPolicy((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$searchApiKeyCredentialPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createSearchApiKeyCredentialPolicy"])(credential));
        }
        this.client.pipeline.addPolicy((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$odataMetadataPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createOdataMetadataPolicy"])("none"));
    }
    /**
     * Retrieves the number of documents in the index.
     * @param options - Options to the count operation.
     */ async getDocumentsCount(options = {}) {
        const { span, updatedOptions } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createSpan"])("SearchClient-getDocumentsCount", options);
        try {
            let documentsCount = 0;
            await this.client.documents.count(Object.assign(Object.assign({}, updatedOptions), {
                onResponse: (rawResponse, flatResponse)=>{
                    documentsCount = Number(rawResponse.bodyAsText);
                    if (updatedOptions.onResponse) {
                        updatedOptions.onResponse(rawResponse, flatResponse);
                    }
                }
            }));
            return documentsCount;
        } catch (e) {
            span.setStatus({
                status: "error",
                error: e.message
            });
            throw e;
        } finally{
            span.end();
        }
    }
    /**
     * Based on a partial searchText from the user, return a list
     * of potential completion strings based on a specified suggester.
     * @param searchText - The search text on which to base autocomplete results.
     * @param suggesterName - The name of the suggester as specified in the suggesters collection that's part of the index definition.
     * @param options - Options to the autocomplete operation.
     * @example
     * ```ts
     * import {
     *   AzureKeyCredential,
     *   SearchClient,
     *   SearchFieldArray,
     * } from "@azure/search-documents";
     *
     * type TModel = {
     *   key: string;
     *   azure?: { sdk: string | null } | null;
     * };
     *
     * const client = new SearchClient<TModel>(
     *   "endpoint.azure",
     *   "indexName",
     *   new AzureKeyCredential("key")
     * );
     *
     * const searchFields: SearchFieldArray<TModel> = ["azure/sdk"];
     *
     * const autocompleteResult = await client.autocomplete(
     *   "searchText",
     *   "suggesterName",
     *   { searchFields }
     * );
     * ```
     */ async autocomplete(searchText, suggesterName, options = {}) {
        const { searchFields } = options, nonFieldOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__rest"])(options, [
            "searchFields"
        ]);
        const fullOptions = Object.assign({
            searchText: searchText,
            suggesterName: suggesterName,
            searchFields: this.convertSearchFields(searchFields)
        }, nonFieldOptions);
        if (!fullOptions.searchText) {
            throw new RangeError("searchText must be provided.");
        }
        if (!fullOptions.suggesterName) {
            throw new RangeError("suggesterName must be provided.");
        }
        const { span, updatedOptions } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createSpan"])("SearchClient-autocomplete", options);
        try {
            const result = await this.client.documents.autocompletePost(fullOptions, updatedOptions);
            return result;
        } catch (e) {
            span.setStatus({
                status: "error",
                error: e.message
            });
            throw e;
        } finally{
            span.end();
        }
    }
    async searchDocuments(searchText, options = {}, nextPageParameters = {}) {
        const _a = options, { includeTotalCount, orderBy, searchFields, select, vectorSearchOptions, semanticSearchOptions } = _a, restOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__rest"])(_a, [
            "includeTotalCount",
            "orderBy",
            "searchFields",
            "select",
            "vectorSearchOptions",
            "semanticSearchOptions"
        ]);
        const _b = semanticSearchOptions !== null && semanticSearchOptions !== void 0 ? semanticSearchOptions : {}, { configurationName, errorMode, answers, captions } = _b, restSemanticOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__rest"])(_b, [
            "configurationName",
            "errorMode",
            "answers",
            "captions"
        ]);
        const _c = vectorSearchOptions !== null && vectorSearchOptions !== void 0 ? vectorSearchOptions : {}, { queries, filterMode } = _c, restVectorOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__rest"])(_c, [
            "queries",
            "filterMode"
        ]);
        const fullOptions = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, restSemanticOptions), restVectorOptions), restOptions), nextPageParameters), {
            searchFields: this.convertSearchFields(searchFields),
            select: this.convertSelect(select) || "*",
            orderBy: this.convertOrderBy(orderBy),
            includeTotalResultCount: includeTotalCount,
            vectorQueries: queries === null || queries === void 0 ? void 0 : queries.map(this.convertVectorQuery.bind(this)),
            answers: this.convertQueryAnswers(answers),
            captions: this.convertQueryCaptions(captions),
            semanticErrorHandling: errorMode,
            semanticConfigurationName: configurationName,
            vectorFilterMode: filterMode
        });
        const { span, updatedOptions } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createSpan"])("SearchClient-searchDocuments", options);
        try {
            const result = await this.client.documents.searchPost(Object.assign(Object.assign({}, fullOptions), {
                searchText: searchText
            }), updatedOptions);
            const _d = result, { results, nextLink, nextPageParameters: resultNextPageParameters, semanticPartialResponseReason: semanticErrorReason, semanticPartialResponseType: semanticSearchResultsType } = _d, restResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__rest"])(_d, [
                "results",
                "nextLink",
                "nextPageParameters",
                "semanticPartialResponseReason",
                "semanticPartialResponseType"
            ]);
            const modifiedResults = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$serviceUtils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generatedSearchResultToPublicSearchResult"])(results);
            const converted = Object.assign(Object.assign({}, restResult), {
                results: modifiedResults,
                semanticErrorReason,
                semanticSearchResultsType,
                continuationToken: this.encodeContinuationToken(nextLink, resultNextPageParameters)
            });
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$serialization$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["deserialize"])(converted);
        } catch (e) {
            span.setStatus({
                status: "error",
                error: e.message
            });
            throw e;
        } finally{
            span.end();
        }
    }
    listSearchResultsPage(searchText, options = {}, settings = {}) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__asyncGenerator"])(this, arguments, function* listSearchResultsPage_1() {
            let decodedContinuation = this.decodeContinuationToken(settings.continuationToken);
            let result = yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__await"])(this.searchDocuments(searchText, options, decodedContinuation === null || decodedContinuation === void 0 ? void 0 : decodedContinuation.nextPageParameters));
            yield yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__await"])(result);
            // Technically, we should also leverage nextLink, but the generated code
            // doesn't support this yet.
            while(result.continuationToken){
                decodedContinuation = this.decodeContinuationToken(result.continuationToken);
                result = yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__await"])(this.searchDocuments(searchText, options, decodedContinuation === null || decodedContinuation === void 0 ? void 0 : decodedContinuation.nextPageParameters));
                yield yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__await"])(result);
            }
        });
    }
    listSearchResultsAll(firstPage, searchText, options = {}) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__asyncGenerator"])(this, arguments, function* listSearchResultsAll_1() {
            var _a, e_1, _b, _c;
            yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__await"])((yield* (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__asyncDelegator"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__asyncValues"])(firstPage.results))));
            if (firstPage.continuationToken) {
                try {
                    for(var _d = true, _e = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__asyncValues"])(this.listSearchResultsPage(searchText, options, {
                        continuationToken: firstPage.continuationToken
                    })), _f; _f = yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__await"])(_e.next()), _a = _f.done, !_a; _d = true){
                        _c = _f.value;
                        _d = false;
                        const page = _c;
                        yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__await"])((yield* (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__asyncDelegator"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__asyncValues"])(page.results))));
                    }
                } catch (e_1_1) {
                    e_1 = {
                        error: e_1_1
                    };
                } finally{
                    try {
                        if (!_d && !_a && (_b = _e.return)) yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__await"])(_b.call(_e));
                    } finally{
                        if (e_1) throw e_1.error;
                    }
                }
            }
        });
    }
    listSearchResults(firstPage, searchText, options = {}) {
        const iter = this.listSearchResultsAll(firstPage, searchText, options);
        return {
            next () {
                return iter.next();
            },
            [Symbol.asyncIterator] () {
                return this;
            },
            byPage: (settings = {})=>{
                return this.listSearchResultsPage(searchText, options, settings);
            }
        };
    }
    /**
     * Performs a search on the current index given
     * the specified arguments.
     * @param searchText - Text to search
     * @param options - Options for the search operation.
     * @example
     * ```ts
     * import {
     *   AzureKeyCredential,
     *   SearchClient,
     *   SearchFieldArray,
     * } from "@azure/search-documents";
     *
     * type TModel = {
     *   key: string;
     *   azure?: { sdk: string | null } | null;
     * };
     *
     * const client = new SearchClient<TModel>(
     *   "endpoint.azure",
     *   "indexName",
     *   new AzureKeyCredential("key")
     * );
     *
     * const select = ["azure/sdk"] as const;
     * const searchFields: SearchFieldArray<TModel> = ["azure/sdk"];
     *
     * const searchResult = await client.search("searchText", {
     *   select,
     *   searchFields,
     * });
     * ```
     */ async search(searchText, options) {
        const { span, updatedOptions } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createSpan"])("SearchClient-search", options);
        try {
            const pageResult = await this.searchDocuments(searchText, updatedOptions);
            return Object.assign(Object.assign({}, pageResult), {
                results: this.listSearchResults(pageResult, searchText, updatedOptions)
            });
        } catch (e) {
            span.setStatus({
                status: "error",
                error: e.message
            });
            throw e;
        } finally{
            span.end();
        }
    }
    /**
     * Returns a short list of suggestions based on the searchText
     * and specified suggester.
     * @param searchText - The search text to use to suggest documents. Must be at least 1 character, and no more than 100 characters.
     * @param suggesterName - The name of the suggester as specified in the suggesters collection that's part of the index definition.
     * @param options - Options for the suggest operation
     * @example
     * ```ts
     * import {
     *   AzureKeyCredential,
     *   SearchClient,
     *   SearchFieldArray,
     * } from "@azure/search-documents";
     *
     * type TModel = {
     *   key: string;
     *   azure?: { sdk: string | null } | null;
     * };
     *
     * const client = new SearchClient<TModel>(
     *   "endpoint.azure",
     *   "indexName",
     *   new AzureKeyCredential("key")
     * );
     *
     * const select = ["azure/sdk"] as const;
     * const searchFields: SearchFieldArray<TModel> = ["azure/sdk"];
     *
     * const suggestResult = await client.suggest("searchText", "suggesterName", {
     *   select,
     *   searchFields,
     * });
     * ```
     */ async suggest(searchText, suggesterName, options = {}) {
        const { select, searchFields, orderBy } = options, nonFieldOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__rest"])(options, [
            "select",
            "searchFields",
            "orderBy"
        ]);
        const fullOptions = Object.assign({
            searchText: searchText,
            suggesterName: suggesterName,
            searchFields: this.convertSearchFields(searchFields),
            select: this.convertSelect(select),
            orderBy: this.convertOrderBy(orderBy)
        }, nonFieldOptions);
        if (!fullOptions.searchText) {
            throw new RangeError("searchText must be provided.");
        }
        if (!fullOptions.suggesterName) {
            throw new RangeError("suggesterName must be provided.");
        }
        const { span, updatedOptions } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createSpan"])("SearchClient-suggest", options);
        try {
            const result = await this.client.documents.suggestPost(fullOptions, updatedOptions);
            const modifiedResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$serviceUtils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generatedSuggestDocumentsResultToPublicSuggestDocumentsResult"])(result);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$serialization$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["deserialize"])(modifiedResult);
        } catch (e) {
            span.setStatus({
                status: "error",
                error: e.message
            });
            throw e;
        } finally{
            span.end();
        }
    }
    /**
     * Retrieve a particular document from the index by key.
     * @param key - The primary key value of the document
     * @param options - Additional options
     */ async getDocument(key, options = {}) {
        const { span, updatedOptions } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createSpan"])("SearchClient-getDocument", options);
        try {
            const result = await this.client.documents.get(key, Object.assign(Object.assign({}, updatedOptions), {
                selectedFields: updatedOptions.selectedFields
            }));
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$serialization$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["deserialize"])(result);
        } catch (e) {
            span.setStatus({
                status: "error",
                error: e.message
            });
            throw e;
        } finally{
            span.end();
        }
    }
    /**
     * Perform a set of index modifications (upload, merge, mergeOrUpload, delete)
     * for the given set of documents.
     * This operation may partially succeed and not all document operations will
     * be reflected in the index. If you would like to treat this as an exception,
     * set the `throwOnAnyFailure` option to true.
     * For more details about how merging works, see: https://docs.microsoft.com/en-us/rest/api/searchservice/AddUpdate-or-Delete-Documents
     * @param batch - An array of actions to perform on the index.
     * @param options - Additional options.
     */ async indexDocuments(// eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
    batch, options = {}) {
        const { span, updatedOptions } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createSpan"])("SearchClient-indexDocuments", options);
        try {
            let status = 0;
            const result = await this.client.documents.index({
                actions: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$serialization$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serialize"])(batch.actions)
            }, Object.assign(Object.assign({}, updatedOptions), {
                onResponse: (rawResponse, flatResponse)=>{
                    status = rawResponse.status;
                    if (updatedOptions.onResponse) {
                        updatedOptions.onResponse(rawResponse, flatResponse);
                    }
                }
            }));
            if (options.throwOnAnyFailure && status === 207) {
                throw result;
            }
            return result;
        } catch (e) {
            span.setStatus({
                status: "error",
                error: e.message
            });
            throw e;
        } finally{
            span.end();
        }
    }
    /**
     * Upload an array of documents to the index.
     * @param documents - The documents to upload.
     * @param options - Additional options.
     */ async uploadDocuments(documents, options = {}) {
        const { span, updatedOptions } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createSpan"])("SearchClient-uploadDocuments", options);
        const batch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$indexDocumentsBatch$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["IndexDocumentsBatch"]();
        batch.upload(documents);
        try {
            return await this.indexDocuments(batch, updatedOptions);
        } catch (e) {
            span.setStatus({
                status: "error",
                error: e.message
            });
            throw e;
        } finally{
            span.end();
        }
    }
    /**
     * Update a set of documents in the index.
     * For more details about how merging works, see https://docs.microsoft.com/en-us/rest/api/searchservice/AddUpdate-or-Delete-Documents
     * @param documents - The updated documents.
     * @param options - Additional options.
     */ async mergeDocuments(documents, options = {}) {
        const { span, updatedOptions } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createSpan"])("SearchClient-mergeDocuments", options);
        const batch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$indexDocumentsBatch$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["IndexDocumentsBatch"]();
        batch.merge(documents);
        try {
            return await this.indexDocuments(batch, updatedOptions);
        } catch (e) {
            span.setStatus({
                status: "error",
                error: e.message
            });
            throw e;
        } finally{
            span.end();
        }
    }
    /**
     * Update a set of documents in the index or upload them if they don't exist.
     * For more details about how merging works, see https://docs.microsoft.com/en-us/rest/api/searchservice/AddUpdate-or-Delete-Documents
     * @param documents - The updated documents.
     * @param options - Additional options.
     */ async mergeOrUploadDocuments(documents, options = {}) {
        const { span, updatedOptions } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createSpan"])("SearchClient-mergeDocuments", options);
        const batch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$indexDocumentsBatch$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["IndexDocumentsBatch"]();
        batch.mergeOrUpload(documents);
        try {
            return await this.indexDocuments(batch, updatedOptions);
        } catch (e) {
            span.setStatus({
                status: "error",
                error: e.message
            });
            throw e;
        } finally{
            span.end();
        }
    }
    async deleteDocuments(keyNameOrDocuments, keyValuesOrOptions, options = {}) {
        const { span, updatedOptions } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createSpan"])("SearchClient-deleteDocuments", options);
        const batch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$indexDocumentsBatch$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["IndexDocumentsBatch"]();
        if (typeof keyNameOrDocuments === "string") {
            batch.delete(keyNameOrDocuments, keyValuesOrOptions);
        } else {
            batch.delete(keyNameOrDocuments);
        }
        try {
            return await this.indexDocuments(batch, updatedOptions);
        } catch (e) {
            span.setStatus({
                status: "error",
                error: e.message
            });
            throw e;
        } finally{
            span.end();
        }
    }
    encodeContinuationToken(nextLink, nextPageParameters) {
        if (!nextLink || !nextPageParameters) {
            return undefined;
        }
        const payload = JSON.stringify({
            apiVersion: this.apiVersion,
            nextLink,
            nextPageParameters
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$base64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["encode"])(payload);
    }
    decodeContinuationToken(token) {
        if (!token) {
            return undefined;
        }
        const decodedToken = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$search$2d$documents$2f$dist$2d$esm$2f$src$2f$base64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decode"])(token);
        try {
            const result = JSON.parse(decodedToken);
            if (result.apiVersion !== this.apiVersion) {
                throw new RangeError(`Continuation token uses unsupported apiVersion "${this.apiVersion}"`);
            }
            return {
                nextLink: result.nextLink,
                nextPageParameters: result.nextPageParameters
            };
        } catch (e) {
            throw new Error(`Corrupted or invalid continuation token: ${decodedToken}`);
        }
    }
    convertSelect(select) {
        if (select) {
            return select.join(",");
        }
        return select;
    }
    convertVectorQueryFields(fields) {
        if (fields) {
            return fields.join(",");
        }
        return fields;
    }
    convertSearchFields(searchFields) {
        if (searchFields) {
            return searchFields.join(",");
        }
        return searchFields;
    }
    convertOrderBy(orderBy) {
        if (orderBy) {
            return orderBy.join(",");
        }
        return orderBy;
    }
    convertQueryAnswers(answers) {
        if (!answers) {
            return answers;
        }
        const config = [];
        const { answerType: output, count, threshold } = answers;
        if (count) {
            config.push(`count-${count}`);
        }
        if (threshold) {
            config.push(`threshold-${threshold}`);
        }
        if (config.length) {
            return output + `|${config.join(",")}`;
        }
        return output;
    }
    convertQueryCaptions(captions) {
        if (!captions) {
            return captions;
        }
        const config = [];
        const { captionType: output, highlight } = captions;
        if (highlight !== undefined) {
            config.push(`highlight-${highlight}`);
        }
        if (config.length) {
            return output + `|${config.join(",")}`;
        }
        return output;
    }
    convertVectorQuery(vectorQuery) {
        return Object.assign(Object.assign({}, vectorQuery), {
            fields: this.convertVectorQueryFields(vectorQuery === null || vectorQuery === void 0 ? void 0 : vectorQuery.fields)
        });
    }
} //# sourceMappingURL=searchClient.js.map
}}),

};

//# sourceMappingURL=node_modules_%40azure_search-documents_dist-esm_src_858c05c3._.js.map
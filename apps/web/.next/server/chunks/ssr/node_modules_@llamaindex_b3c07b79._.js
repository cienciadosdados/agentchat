module.exports = {

"[project]/node_modules/@llamaindex/env/dist/index.js [app-rsc] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "CustomEvent": (()=>defaultCustomEvent),
    "NotSupportCurrentRuntimeClass": (()=>NotSupportCurrentRuntimeClass),
    "consoleLogger": (()=>consoleLogger),
    "createSHA256": (()=>createSHA256),
    "emptyLogger": (()=>emptyLogger),
    "getEnv": (()=>getEnv),
    "process": (()=>process$1),
    "setEnvs": (()=>setEnvs)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$assert__$5b$external$5d$__$28$node$3a$assert$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:assert [external] (node:assert, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:crypto [external] (node:crypto, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:os [external] (node:os, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:stream [external] (node:stream, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:url [external] (node:url, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs [external] (node:fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs/promises [external] (node:fs/promises, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$async_hooks__$5b$external$5d$__$28$node$3a$async_hooks$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:async_hooks [external] (node:async_hooks, cjs)");
;
;
;
;
;
;
;
;
;
;
class NotSupportCurrentRuntimeClass {
    constructor(runtime){
        throw new Error(`Current environment ${runtime} is not supported`);
    }
    static bind(runtime) {
        return class extends NotSupportCurrentRuntimeClass {
            constructor(...args){
                super(runtime);
            }
        };
    }
}
// This is a workaround for the lack of globalThis in some environments
// It's being used across multiple places inside the `env` package
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const glo = typeof globalThis !== "undefined" ? globalThis : ("TURBOPACK compile-time falsy", 0) ? ("TURBOPACK unreachable", undefined) : typeof global !== "undefined" ? global : {};
const importIdentifier = "__ $@llamaindex/env$ __";
if (glo[importIdentifier] === true) {
    /**
   * Dear reader of this message. Please take this seriously.
   *
   * If you see this message, make sure that you only import one version of llamaindex. In many cases,
   * your package manager installs two versions of llamaindex that are used by different packages within your project.
   * Another reason for this message is that some parts of your project use the CJS version of llamaindex
   * and others use the ESM version of llamaindex.
   *
   * This often leads to issues that are hard to debug. We often need to perform constructor checks,
   * e.g. `node instanceof TextNode`. If you imported different versions of llamaindex, it is impossible for us to
   * do the constructor checks anymore - which might break the functionality of your application.
   */ console.error("llamaindex was already imported. This breaks constructor checks and will lead to issues!");
}
glo[importIdentifier] = true;
function noop() {}
const emptyLogger = Object.freeze({
    log: noop,
    error: noop,
    warn: noop
});
const consoleLogger = Object.freeze({
    log: console.log.bind(console),
    error: console.error.bind(console),
    warn: console.warn.bind(console)
});
// DO NOT EXPOSE THIS VARIABLE TO PUBLIC, IT IS USED INTERNALLY FOR CLOUDFLARE WORKER
const INTERNAL_ENV = {};
/**
 * Set environment variables before using llamaindex, because some LLM need to access API key before running.
 *
 * You have to set the environment variables in Cloudflare Worker environment,
 * because it doesn't have any global environment variables.
 *
 * @example
 * ```ts
 * export default {
 *   async fetch(
 *     request: Request,
 *     env: Env,
 *     ctx: ExecutionContext,
 *   ): Promise<Response> {
 *     const { setEnvs } = await import("@llamaindex/env");
 *     setEnvs(env);
 *     // ...
 *     return new Response("Hello, World!");
 *   },
 * };
 * ```
 *
 * @param envs Environment variables
 */ function setEnvs(envs) {
    Object.assign(INTERNAL_ENV, envs);
}
function getEnv(name) {
    if (INTERNAL_ENV[name]) {
        return INTERNAL_ENV[name];
    }
    if (typeof process === "undefined" || typeof process.env === "undefined") {
        // @ts-expect-error Deno is not defined
        if (typeof Deno === "undefined") {
            throw new Error("Current environment is not supported");
        } else {
            // @ts-expect-error Deno is not defined
            return Deno.env.get(name);
        }
    }
    return process.env[name];
}
// Node.js 18 doesn't have CustomEvent by default
// Refs: https://github.com/nodejs/node/issues/40678
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class CustomEvent extends Event {
    #detail;
    get detail() {
        return this.#detail;
    }
    constructor(event, options){
        super(event, options);
        this.#detail = options?.detail;
    }
    /**
   * @deprecated This method is not supported
   */ initCustomEvent() {
        throw new Error("initCustomEvent is not supported");
    }
}
const defaultCustomEvent = globalThis.CustomEvent || CustomEvent;
function createSHA256() {
    const hash = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["createHash"])("sha256");
    return {
        update (data) {
            hash.update(data);
        },
        digest () {
            return hash.digest("base64");
        }
    };
}
const process$1 = globalThis.process;
;
}}),
"[project]/node_modules/@llamaindex/env/dist/index.js [app-rsc] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$assert__$5b$external$5d$__$28$node$3a$assert$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:assert [external] (node:assert, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:crypto [external] (node:crypto, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:os [external] (node:os, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:stream [external] (node:stream, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:url [external] (node:url, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs [external] (node:fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs/promises [external] (node:fs/promises, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$async_hooks__$5b$external$5d$__$28$node$3a$async_hooks$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:async_hooks [external] (node:async_hooks, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@llamaindex/env/dist/index.js [app-rsc] (ecmascript) <locals>");
}}),
"[project]/node_modules/@llamaindex/env/tokenizers/dist/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Tokenizers": (()=>Tokenizers),
    "tokenizers": (()=>tokenizers)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$js$2d$tiktoken$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/js-tiktoken/dist/index.js [app-rsc] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$js$2d$tiktoken$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/js-tiktoken/dist/index.js [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$module__$5b$external$5d$__$28$node$3a$module$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:module [external] (node:module, cjs)");
const __TURBOPACK__import$2e$meta__ = {
    get url () {
        return `file://${__turbopack_context__.P("node_modules/@llamaindex/env/tokenizers/dist/index.js")}`;
    }
};
;
;
var Tokenizers = /*#__PURE__*/ function(Tokenizers) {
    Tokenizers["CL100K_BASE"] = "cl100k_base";
    return Tokenizers;
}({});
const require = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$module__$5b$external$5d$__$28$node$3a$module$2c$__cjs$29$__["default"].createRequire(__TURBOPACK__import$2e$meta__.url);
function tryLoadGptTokenizer() {
    try {
        // eslint-disable-next-line @typescript-eslint/no-require-imports
        return require("gpt-tokenizer"); // using require for CommonJS compatibility
    } catch (e) {
        return null;
    }
}
const gptTokenizerModule = tryLoadGptTokenizer();
class TokenizerSingleton {
    #defaultTokenizer;
    constructor(){
        // Use gpt-tokenizer if available, otherwise use js-tiktoken
        if (gptTokenizerModule) {
            this.#defaultTokenizer = {
                encode: (text)=>{
                    return new Uint32Array(gptTokenizerModule.encode(text));
                },
                decode: (tokens)=>{
                    return gptTokenizerModule.decode(Array.from(tokens));
                }
            };
        } else {
            // Fall back to js-tiktoken which is always available
            // Note: js-tiktoken it's 60x slower than gpt-tokenizer
            const encoding = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$js$2d$tiktoken$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getEncoding"])("cl100k_base");
            this.#defaultTokenizer = {
                encode: (text)=>{
                    return new Uint32Array(encoding.encode(text));
                },
                decode: (tokens)=>{
                    const numberArray = Array.from(tokens);
                    const text = encoding.decode(numberArray);
                    const uint8Array = new TextEncoder().encode(text);
                    return new TextDecoder().decode(uint8Array);
                }
            };
        }
    }
    tokenizer(encoding) {
        if (encoding && encoding !== Tokenizers.CL100K_BASE) {
            throw new Error(`Tokenizer encoding ${encoding} not yet supported`);
        }
        return this.#defaultTokenizer;
    }
}
const tokenizers = new TokenizerSingleton();
;
}}),
"[project]/node_modules/@llamaindex/openai/dist/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ALL_AVAILABLE_OPENAI_MODELS": (()=>ALL_AVAILABLE_OPENAI_MODELS),
    "ALL_OPENAI_EMBEDDING_MODELS": (()=>ALL_OPENAI_EMBEDDING_MODELS),
    "GPT35_MODELS": (()=>GPT35_MODELS),
    "GPT4_MODELS": (()=>GPT4_MODELS),
    "O1_MODELS": (()=>O1_MODELS),
    "O3_MODELS": (()=>O3_MODELS),
    "OpenAI": (()=>OpenAI),
    "OpenAIAgent": (()=>OpenAIAgent),
    "OpenAIAgentWorker": (()=>OpenAIAgentWorker),
    "OpenAIEmbedding": (()=>OpenAIEmbedding),
    "openai": (()=>openai)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$agent$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@llamaindex/core/agent/dist/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$global$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@llamaindex/core/global/dist/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$decorator$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@llamaindex/core/decorator/dist/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$llms$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@llamaindex/core/llms/dist/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$utils$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@llamaindex/core/utils/dist/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@llamaindex/env/dist/index.js [app-rsc] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@llamaindex/env/dist/index.js [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$tokenizers$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@llamaindex/env/tokenizers/dist/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$embeddings$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@llamaindex/core/embeddings/dist/index.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
var name = "@llamaindex/openai";
var version = "0.1.61";
var pkg = {
    name: name,
    version: version
};
// NOTE we're not supporting the legacy models as they're not available for new deployments
// https://learn.microsoft.com/en-us/azure/ai-services/openai/concepts/legacy-models
// If you have a need for them, please open an issue on GitHub
const ALL_AZURE_OPENAI_CHAT_MODELS = {
    "gpt-35-turbo": {
        contextWindow: 4096,
        openAIModel: "gpt-3.5-turbo"
    },
    "gpt-35-turbo-16k": {
        contextWindow: 16384,
        openAIModel: "gpt-3.5-turbo-16k"
    },
    "gpt-4o": {
        contextWindow: 128000,
        openAIModel: "gpt-4o"
    },
    "gpt-4o-mini": {
        contextWindow: 128000,
        openAIModel: "gpt-4o-mini"
    },
    "gpt-4": {
        contextWindow: 8192,
        openAIModel: "gpt-4"
    },
    "gpt-4-32k": {
        contextWindow: 32768,
        openAIModel: "gpt-4-32k"
    },
    "gpt-4-turbo": {
        contextWindow: 128000,
        openAIModel: "gpt-4-turbo"
    },
    "gpt-4-turbo-2024-04-09": {
        contextWindow: 128000,
        openAIModel: "gpt-4-turbo"
    },
    "gpt-4-vision-preview": {
        contextWindow: 128000,
        openAIModel: "gpt-4-vision-preview"
    },
    "gpt-4-1106-preview": {
        contextWindow: 128000,
        openAIModel: "gpt-4-1106-preview"
    },
    "gpt-4o-2024-05-13": {
        contextWindow: 128000,
        openAIModel: "gpt-4o-2024-05-13"
    },
    "gpt-4o-mini-2024-07-18": {
        contextWindow: 128000,
        openAIModel: "gpt-4o-mini-2024-07-18"
    }
};
const ALL_AZURE_OPENAI_EMBEDDING_MODELS = {
    "text-embedding-ada-002": {
        dimensions: 1536,
        openAIModel: "text-embedding-ada-002",
        maxTokens: 8191
    },
    "text-embedding-3-small": {
        dimensions: 1536,
        dimensionOptions: [
            512,
            1536
        ],
        openAIModel: "text-embedding-3-small",
        maxTokens: 8191
    },
    "text-embedding-3-large": {
        dimensions: 3072,
        dimensionOptions: [
            256,
            1024,
            3072
        ],
        openAIModel: "text-embedding-3-large",
        maxTokens: 8191
    }
};
// Current version list found here - https://learn.microsoft.com/en-us/azure/ai-services/openai/reference
// const ALL_AZURE_API_VERSIONS = [
//   "2022-12-01",
//   "2023-05-15",
//   "2023-06-01-preview", // Maintained for DALL-E 2
//   "2023-10-01-preview",
//   "2024-02-01",
//   "2024-02-15-preview",
//   "2024-03-01-preview",
//   "2024-04-01-preview",
//   "2024-05-01-preview",
//   "2024-06-01",
// ];
const DEFAULT_API_VERSION = "2023-05-15";
//^ NOTE: this will change over time, if you want to pin it, use a specific version
function getAzureConfigFromEnv(init) {
    const deployment = init && "deploymentName" in init && typeof init.deploymentName === "string" ? init?.deploymentName : init?.deployment ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getEnv"])("AZURE_OPENAI_DEPLOYMENT") ?? // From Azure docs
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getEnv"])("AZURE_OPENAI_API_DEPLOYMENT_NAME") ?? // LCJS compatible
    init?.model; // Fall back to model name, Python compatible
    return {
        apiKey: init?.apiKey ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getEnv"])("AZURE_OPENAI_KEY") ?? // From Azure docs
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getEnv"])("OPENAI_API_KEY") ?? // Python compatible
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getEnv"])("AZURE_OPENAI_API_KEY"),
        endpoint: init?.endpoint ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getEnv"])("AZURE_OPENAI_ENDPOINT") ?? // From Azure docs
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getEnv"])("OPENAI_API_BASE") ?? // Python compatible
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getEnv"])("AZURE_OPENAI_API_INSTANCE_NAME"),
        apiVersion: init?.apiVersion ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getEnv"])("AZURE_OPENAI_API_VERSION") ?? // From Azure docs
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getEnv"])("OPENAI_API_VERSION") ?? // Python compatible
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getEnv"])("AZURE_OPENAI_API_VERSION") ?? // LCJS compatible
        DEFAULT_API_VERSION,
        deployment
    };
}
function getAzureModel(openAIModel) {
    for (const [key, value] of Object.entries(ALL_AZURE_OPENAI_EMBEDDING_MODELS)){
        if (value.openAIModel === openAIModel) {
            return key;
        }
    }
    for (const [key, value] of Object.entries(ALL_AZURE_OPENAI_CHAT_MODELS)){
        if (value.openAIModel === openAIModel) {
            return key;
        }
    }
    throw new Error(`Unknown model: ${openAIModel}`);
}
function shouldUseAzure() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getEnv"])("AZURE_OPENAI_ENDPOINT") || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getEnv"])("AZURE_OPENAI_API_INSTANCE_NAME") || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getEnv"])("OPENAI_API_TYPE") === "azure";
}
// This mixin adds a User-Agent header to the request for Azure OpenAI
function AzureOpenAIWithUserAgent(Base) {
    return class AzureOpenAI extends Base {
        // Define a new public method that wraps the base class's defaultHeaders
        defaultHeaders(opts) {
            const baseHeaders = super.defaultHeaders(opts);
            return {
                ...baseHeaders,
                "User-Agent": `${pkg.name}/${pkg.version} (node.js/${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["process"].version}; ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["process"].platform}; ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["process"].arch}) ${baseHeaders["User-Agent"] || ""}`
            };
        }
    };
}
function applyDecs2203RFactory() {
    function createAddInitializerMethod(initializers, decoratorFinishedRef) {
        return function addInitializer(initializer) {
            assertNotFinished(decoratorFinishedRef, "addInitializer");
            assertCallable(initializer, "An initializer");
            initializers.push(initializer);
        };
    }
    function memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value) {
        var kindStr;
        switch(kind){
            case 1:
                kindStr = "accessor";
                break;
            case 2:
                kindStr = "method";
                break;
            case 3:
                kindStr = "getter";
                break;
            case 4:
                kindStr = "setter";
                break;
            default:
                kindStr = "field";
        }
        var ctx = {
            kind: kindStr,
            name: isPrivate ? "#" + name : name,
            static: isStatic,
            private: isPrivate,
            metadata: metadata
        };
        var decoratorFinishedRef = {
            v: false
        };
        ctx.addInitializer = createAddInitializerMethod(initializers, decoratorFinishedRef);
        var get, set;
        if (kind === 0) {
            if (isPrivate) {
                get = desc.get;
                set = desc.set;
            } else {
                get = function() {
                    return this[name];
                };
                set = function(v) {
                    this[name] = v;
                };
            }
        } else if (kind === 2) {
            get = function() {
                return desc.value;
            };
        } else {
            if (kind === 1 || kind === 3) {
                get = function() {
                    return desc.get.call(this);
                };
            }
            if (kind === 1 || kind === 4) {
                set = function(v) {
                    desc.set.call(this, v);
                };
            }
        }
        ctx.access = get && set ? {
            get: get,
            set: set
        } : get ? {
            get: get
        } : {
            set: set
        };
        try {
            return dec(value, ctx);
        } finally{
            decoratorFinishedRef.v = true;
        }
    }
    function assertNotFinished(decoratorFinishedRef, fnName) {
        if (decoratorFinishedRef.v) {
            throw new Error("attempted to call " + fnName + " after decoration was finished");
        }
    }
    function assertCallable(fn, hint) {
        if (typeof fn !== "function") {
            throw new TypeError(hint + " must be a function");
        }
    }
    function assertValidReturnValue(kind, value) {
        var type = typeof value;
        if (kind === 1) {
            if (type !== "object" || value === null) {
                throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");
            }
            if (value.get !== undefined) {
                assertCallable(value.get, "accessor.get");
            }
            if (value.set !== undefined) {
                assertCallable(value.set, "accessor.set");
            }
            if (value.init !== undefined) {
                assertCallable(value.init, "accessor.init");
            }
        } else if (type !== "function") {
            var hint;
            if (kind === 0) {
                hint = "field";
            } else if (kind === 10) {
                hint = "class";
            } else {
                hint = "method";
            }
            throw new TypeError(hint + " decorators must return a function or void 0");
        }
    }
    function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata) {
        var decs = decInfo[0];
        var desc, init, value;
        if (isPrivate) {
            if (kind === 0 || kind === 1) {
                desc = {
                    get: decInfo[3],
                    set: decInfo[4]
                };
            } else if (kind === 3) {
                desc = {
                    get: decInfo[3]
                };
            } else if (kind === 4) {
                desc = {
                    set: decInfo[3]
                };
            } else {
                desc = {
                    value: decInfo[3]
                };
            }
        } else if (kind !== 0) {
            desc = Object.getOwnPropertyDescriptor(base, name);
        }
        if (kind === 1) {
            value = {
                get: desc.get,
                set: desc.set
            };
        } else if (kind === 2) {
            value = desc.value;
        } else if (kind === 3) {
            value = desc.get;
        } else if (kind === 4) {
            value = desc.set;
        }
        var newValue, get, set;
        if (typeof decs === "function") {
            newValue = memberDec(decs, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
            if (newValue !== void 0) {
                assertValidReturnValue(kind, newValue);
                if (kind === 0) {
                    init = newValue;
                } else if (kind === 1) {
                    init = newValue.init;
                    get = newValue.get || value.get;
                    set = newValue.set || value.set;
                    value = {
                        get: get,
                        set: set
                    };
                } else {
                    value = newValue;
                }
            }
        } else {
            for(var i = decs.length - 1; i >= 0; i--){
                var dec = decs[i];
                newValue = memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
                if (newValue !== void 0) {
                    assertValidReturnValue(kind, newValue);
                    var newInit;
                    if (kind === 0) {
                        newInit = newValue;
                    } else if (kind === 1) {
                        newInit = newValue.init;
                        get = newValue.get || value.get;
                        set = newValue.set || value.set;
                        value = {
                            get: get,
                            set: set
                        };
                    } else {
                        value = newValue;
                    }
                    if (newInit !== void 0) {
                        if (init === void 0) {
                            init = newInit;
                        } else if (typeof init === "function") {
                            init = [
                                init,
                                newInit
                            ];
                        } else {
                            init.push(newInit);
                        }
                    }
                }
            }
        }
        if (kind === 0 || kind === 1) {
            if (init === void 0) {
                init = function(instance, init) {
                    return init;
                };
            } else if (typeof init !== "function") {
                var ownInitializers = init;
                init = function(instance, init) {
                    var value = init;
                    for(var i = 0; i < ownInitializers.length; i++){
                        value = ownInitializers[i].call(instance, value);
                    }
                    return value;
                };
            } else {
                var originalInitializer = init;
                init = function(instance, init) {
                    return originalInitializer.call(instance, init);
                };
            }
            ret.push(init);
        }
        if (kind !== 0) {
            if (kind === 1) {
                desc.get = value.get;
                desc.set = value.set;
            } else if (kind === 2) {
                desc.value = value;
            } else if (kind === 3) {
                desc.get = value;
            } else if (kind === 4) {
                desc.set = value;
            }
            if (isPrivate) {
                if (kind === 1) {
                    ret.push(function(instance, args) {
                        return value.get.call(instance, args);
                    });
                    ret.push(function(instance, args) {
                        return value.set.call(instance, args);
                    });
                } else if (kind === 2) {
                    ret.push(value);
                } else {
                    ret.push(function(instance, args) {
                        return value.call(instance, args);
                    });
                }
            } else {
                Object.defineProperty(base, name, desc);
            }
        }
    }
    function applyMemberDecs(Class, decInfos, metadata) {
        var ret = [];
        var protoInitializers;
        var staticInitializers;
        var existingProtoNonFields = new Map();
        var existingStaticNonFields = new Map();
        for(var i = 0; i < decInfos.length; i++){
            var decInfo = decInfos[i];
            if (!Array.isArray(decInfo)) continue;
            var kind = decInfo[1];
            var name = decInfo[2];
            var isPrivate = decInfo.length > 3;
            var isStatic = kind >= 5;
            var base;
            var initializers;
            if (isStatic) {
                base = Class;
                kind = kind - 5;
                staticInitializers = staticInitializers || [];
                initializers = staticInitializers;
            } else {
                base = Class.prototype;
                protoInitializers = protoInitializers || [];
                initializers = protoInitializers;
            }
            if (kind !== 0 && !isPrivate) {
                var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields;
                var existingKind = existingNonFields.get(name) || 0;
                if (existingKind === true || existingKind === 3 && kind !== 4 || existingKind === 4 && kind !== 3) {
                    throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + name);
                } else if (!existingKind && kind > 2) {
                    existingNonFields.set(name, kind);
                } else {
                    existingNonFields.set(name, true);
                }
            }
            applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata);
        }
        pushInitializers(ret, protoInitializers);
        pushInitializers(ret, staticInitializers);
        return ret;
    }
    function pushInitializers(ret, initializers) {
        if (initializers) {
            ret.push(function(instance) {
                for(var i = 0; i < initializers.length; i++){
                    initializers[i].call(instance);
                }
                return instance;
            });
        }
    }
    function applyClassDecs(targetClass, classDecs, metadata) {
        if (classDecs.length > 0) {
            var initializers = [];
            var newClass = targetClass;
            var name = targetClass.name;
            for(var i = classDecs.length - 1; i >= 0; i--){
                var decoratorFinishedRef = {
                    v: false
                };
                try {
                    var nextNewClass = classDecs[i](newClass, {
                        kind: "class",
                        name: name,
                        addInitializer: createAddInitializerMethod(initializers, decoratorFinishedRef),
                        metadata
                    });
                } finally{
                    decoratorFinishedRef.v = true;
                }
                if (nextNewClass !== undefined) {
                    assertValidReturnValue(10, nextNewClass);
                    newClass = nextNewClass;
                }
            }
            return [
                defineMetadata(newClass, metadata),
                function() {
                    for(var i = 0; i < initializers.length; i++){
                        initializers[i].call(newClass);
                    }
                }
            ];
        }
    }
    function defineMetadata(Class, metadata) {
        return Object.defineProperty(Class, Symbol.metadata || Symbol.for("Symbol.metadata"), {
            configurable: true,
            enumerable: true,
            value: metadata
        });
    }
    return function applyDecs2203R(targetClass, memberDecs, classDecs, parentClass) {
        if (parentClass !== void 0) {
            var parentMetadata = parentClass[Symbol.metadata || Symbol.for("Symbol.metadata")];
        }
        var metadata = Object.create(parentMetadata === void 0 ? null : parentMetadata);
        var e = applyMemberDecs(targetClass, memberDecs, metadata);
        if (!classDecs.length) defineMetadata(targetClass, metadata);
        return {
            e: e,
            get c () {
                return applyClassDecs(targetClass, classDecs, metadata);
            }
        };
    };
}
function _apply_decs_2203_r(targetClass, memberDecs, classDecs, parentClass) {
    return (_apply_decs_2203_r = applyDecs2203RFactory())(targetClass, memberDecs, classDecs, parentClass);
}
var _initProto;
const GPT4_MODELS = {
    "chatgpt-4o-latest": {
        contextWindow: 128000
    },
    "gpt-4.5-preview": {
        contextWindow: 128000
    },
    "gpt-4.5-preview-2025-02-27": {
        contextWindow: 128000
    },
    "gpt-4": {
        contextWindow: 8192
    },
    "gpt-4-32k": {
        contextWindow: 32768
    },
    "gpt-4-32k-0613": {
        contextWindow: 32768
    },
    "gpt-4-turbo": {
        contextWindow: 128000
    },
    "gpt-4-turbo-preview": {
        contextWindow: 128000
    },
    "gpt-4-1106-preview": {
        contextWindow: 128000
    },
    "gpt-4-0125-preview": {
        contextWindow: 128000
    },
    "gpt-4-vision-preview": {
        contextWindow: 128000
    },
    "gpt-4o": {
        contextWindow: 128000
    },
    "gpt-4o-2024-05-13": {
        contextWindow: 128000
    },
    "gpt-4o-mini": {
        contextWindow: 128000
    },
    "gpt-4o-mini-2024-07-18": {
        contextWindow: 128000
    },
    "gpt-4o-2024-08-06": {
        contextWindow: 128000
    },
    "gpt-4o-2024-09-14": {
        contextWindow: 128000
    },
    "gpt-4o-2024-10-14": {
        contextWindow: 128000
    },
    "gpt-4-0613": {
        contextWindow: 128000
    },
    "gpt-4-turbo-2024-04-09": {
        contextWindow: 128000
    },
    "gpt-4-0314": {
        contextWindow: 128000
    },
    "gpt-4-32k-0314": {
        contextWindow: 32768
    },
    "gpt-4o-realtime-preview": {
        contextWindow: 128000
    },
    "gpt-4o-realtime-preview-2024-10-01": {
        contextWindow: 128000
    },
    "gpt-4o-audio-preview": {
        contextWindow: 128000
    },
    "gpt-4o-audio-preview-2024-10-01": {
        contextWindow: 128000
    },
    "gpt-4o-2024-11-20": {
        contextWindow: 128000
    },
    "gpt-4o-audio-preview-2024-12-17": {
        contextWindow: 128000
    },
    "gpt-4o-mini-audio-preview": {
        contextWindow: 128000
    },
    "gpt-4o-mini-audio-preview-2024-12-17": {
        contextWindow: 128000
    }
};
// NOTE we don't currently support gpt-3.5-turbo-instruct and don't plan to in the near future
const GPT35_MODELS = {
    "gpt-3.5-turbo": {
        contextWindow: 16385
    },
    "gpt-3.5-turbo-0613": {
        contextWindow: 4096
    },
    "gpt-3.5-turbo-16k": {
        contextWindow: 16385
    },
    "gpt-3.5-turbo-16k-0613": {
        contextWindow: 16385
    },
    "gpt-3.5-turbo-1106": {
        contextWindow: 16385
    },
    "gpt-3.5-turbo-0125": {
        contextWindow: 16385
    },
    "gpt-3.5-turbo-0301": {
        contextWindow: 16385
    }
};
const O1_MODELS = {
    "o1-preview": {
        contextWindow: 128000
    },
    "o1-preview-2024-09-12": {
        contextWindow: 128000
    },
    "o1-mini": {
        contextWindow: 128000
    },
    "o1-mini-2024-09-12": {
        contextWindow: 128000
    },
    o1: {
        contextWindow: 128000
    },
    "o1-2024-12-17": {
        contextWindow: 128000
    }
};
const O3_MODELS = {
    "o3-mini": {
        contextWindow: 200000
    },
    "o3-mini-2025-01-31": {
        contextWindow: 200000
    }
};
/**
 * We currently support GPT-3.5 and GPT-4 models
 */ const ALL_AVAILABLE_OPENAI_MODELS = {
    ...GPT4_MODELS,
    ...GPT35_MODELS,
    ...O1_MODELS,
    ...O3_MODELS
};
function isFunctionCallingModel(llm) {
    let model;
    if (llm instanceof OpenAI) {
        model = llm.model;
    } else if ("model" in llm && typeof llm.model === "string") {
        model = llm.model;
    } else {
        return false;
    }
    const isChatModel = Object.keys(ALL_AVAILABLE_OPENAI_MODELS).includes(model);
    const isOld = model.includes("0314") || model.includes("0301");
    const isO1 = model.startsWith("o1");
    return isChatModel && !isOld && !isO1;
}
function isReasoningModel(model) {
    const isO1 = model.startsWith("o1");
    const isO3 = model.startsWith("o3");
    return isO1 || isO3;
}
function isTemperatureSupported(model) {
    return !model.startsWith("o3");
}
class OpenAI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$llms$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ToolCallLLM"] {
    static{
        ({ e: [_initProto] } = _apply_decs_2203_r(this, [
            [
                [
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$decorator$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["wrapEventCaller"],
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$decorator$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["wrapLLMEvent"]
                ],
                2,
                "chat"
            ],
            [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$decorator$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["wrapEventCaller"],
                2,
                "streamChat"
            ]
        ], []));
    }
    #session;
    get session() {
        if (!this.#session) {
            this.#session = this.lazySession();
        }
        return this.#session;
    }
    constructor(init){
        super(), this.apiKey = (_initProto(this), undefined), this.baseURL = undefined, this.#session = null;
        this.model = init?.model ?? "gpt-4o";
        this.temperature = init?.temperature ?? 0.1;
        this.reasoningEffort = isReasoningModel(this.model) ? init?.reasoningEffort : undefined;
        this.topP = init?.topP ?? 1;
        this.maxTokens = init?.maxTokens ?? undefined;
        this.maxRetries = init?.maxRetries ?? 10;
        this.timeout = init?.timeout ?? 60 * 1000; // Default is 60 seconds
        this.additionalChatOptions = init?.additionalChatOptions;
        this.additionalSessionOptions = init?.additionalSessionOptions;
        this.apiKey = init?.session?.apiKey ?? init?.apiKey ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getEnv"])("OPENAI_API_KEY");
        this.baseURL = init?.session?.baseURL ?? init?.baseURL ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getEnv"])("OPENAI_BASE_URL");
        if (init?.azure || shouldUseAzure()) {
            const azureConfig = {
                ...getAzureConfigFromEnv({
                    model: getAzureModel(this.model)
                }),
                ...init?.azure
            };
            this.lazySession = async ()=>init?.session ?? __turbopack_context__.r("[project]/node_modules/openai/index.mjs [app-rsc] (ecmascript, async loader)")(__turbopack_context__.i).then(({ AzureOpenAI })=>{
                    AzureOpenAI = AzureOpenAIWithUserAgent(AzureOpenAI);
                    return new AzureOpenAI({
                        maxRetries: this.maxRetries,
                        timeout: this.timeout,
                        ...this.additionalSessionOptions,
                        ...azureConfig
                    });
                });
        } else {
            this.lazySession = async ()=>init?.session ?? __turbopack_context__.r("[project]/node_modules/openai/index.mjs [app-rsc] (ecmascript, async loader)")(__turbopack_context__.i).then(({ OpenAI })=>{
                    return new OpenAI({
                        apiKey: this.apiKey,
                        baseURL: this.baseURL,
                        maxRetries: this.maxRetries,
                        timeout: this.timeout,
                        ...this.additionalSessionOptions
                    });
                });
        }
    }
    get supportToolCall() {
        return isFunctionCallingModel(this);
    }
    get metadata() {
        const contextWindow = ALL_AVAILABLE_OPENAI_MODELS[this.model]?.contextWindow ?? 1024;
        return {
            model: this.model,
            temperature: this.temperature,
            topP: this.topP,
            maxTokens: this.maxTokens,
            contextWindow,
            tokenizer: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$tokenizers$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Tokenizers"].CL100K_BASE
        };
    }
    static toOpenAIRole(messageType) {
        switch(messageType){
            case "user":
                return "user";
            case "assistant":
                return "assistant";
            case "system":
                return "system";
            default:
                return "user";
        }
    }
    static toOpenAIMessage(messages) {
        return messages.map((message)=>{
            const options = message.options ?? {};
            if ("toolResult" in options) {
                return {
                    tool_call_id: options.toolResult.id,
                    role: "tool",
                    content: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$utils$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["extractText"])(message.content)
                };
            } else if ("toolCall" in options) {
                return {
                    role: "assistant",
                    content: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$utils$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["extractText"])(message.content),
                    tool_calls: options.toolCall.map((toolCall)=>{
                        return {
                            id: toolCall.id,
                            type: "function",
                            function: {
                                name: toolCall.name,
                                arguments: typeof toolCall.input === "string" ? toolCall.input : JSON.stringify(toolCall.input)
                            }
                        };
                    })
                };
            } else if (message.role === "user") {
                return {
                    role: "user",
                    content: message.content
                };
            }
            const response = {
                // fixme(alex): type assertion
                role: OpenAI.toOpenAIRole(message.role),
                // fixme: should not extract text, but assert content is string
                content: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$utils$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["extractText"])(message.content)
            };
            return response;
        });
    }
    async chat(params) {
        const { messages, stream, tools, additionalChatOptions } = params;
        const baseRequestParams = {
            model: this.model,
            temperature: this.temperature,
            reasoning_effort: this.reasoningEffort,
            max_tokens: this.maxTokens,
            tools: tools?.map(OpenAI.toTool),
            messages: OpenAI.toOpenAIMessage(messages),
            top_p: this.topP,
            ...Object.assign({}, this.additionalChatOptions, additionalChatOptions)
        };
        if (Array.isArray(baseRequestParams.tools) && baseRequestParams.tools.length === 0) {
            // remove empty tools array to avoid OpenAI error
            delete baseRequestParams.tools;
        }
        if (!isTemperatureSupported(baseRequestParams.model)) delete baseRequestParams.temperature;
        // Streaming
        if (stream) {
            return this.streamChat(baseRequestParams);
        }
        // Non-streaming
        const response = await (await this.session).chat.completions.create({
            ...baseRequestParams,
            stream: false
        });
        const content = response.choices[0].message?.content ?? "";
        return {
            raw: response,
            message: {
                content,
                role: response.choices[0].message.role,
                options: response.choices[0].message?.tool_calls ? {
                    toolCall: response.choices[0].message.tool_calls.map((toolCall)=>({
                            id: toolCall.id,
                            name: toolCall.function.name,
                            input: toolCall.function.arguments
                        }))
                } : {}
            }
        };
    }
    // todo: this wrapper is ugly, refactor it
    async *streamChat(baseRequestParams) {
        const stream = await (await this.session).chat.completions.create({
            ...baseRequestParams,
            stream: true
        });
        // TODO: add callback to streamConverter and use streamConverter here
        // this will be used to keep track of the current tool call, make sure input are valid json object.
        let currentToolCall = null;
        const toolCallMap = new Map();
        for await (const part of stream){
            if (part.choices.length === 0) {
                if (part.usage) {
                    yield {
                        raw: part,
                        delta: ""
                    };
                }
                continue;
            }
            const choice = part.choices[0];
            // skip parts that don't have any content
            if (!(choice.delta.content || choice.delta.tool_calls || choice.finish_reason)) continue;
            let shouldEmitToolCall = null;
            if (choice.delta.tool_calls?.[0].id && currentToolCall && choice.delta.tool_calls?.[0].id !== currentToolCall.id) {
                shouldEmitToolCall = {
                    ...currentToolCall,
                    input: JSON.parse(currentToolCall.input)
                };
            }
            if (choice.delta.tool_calls?.[0].id) {
                currentToolCall = {
                    name: choice.delta.tool_calls[0].function.name,
                    id: choice.delta.tool_calls[0].id,
                    input: choice.delta.tool_calls[0].function.arguments
                };
                toolCallMap.set(choice.delta.tool_calls[0].id, currentToolCall);
            } else {
                if (choice.delta.tool_calls?.[0].function?.arguments) {
                    currentToolCall.input += choice.delta.tool_calls[0].function.arguments;
                }
            }
            const isDone = choice.finish_reason !== null;
            if (isDone && currentToolCall) {
                // for the last one, we need to emit the tool call
                shouldEmitToolCall = {
                    ...currentToolCall,
                    input: JSON.parse(currentToolCall.input)
                };
            }
            yield {
                raw: part,
                options: shouldEmitToolCall ? {
                    toolCall: [
                        shouldEmitToolCall
                    ]
                } : currentToolCall ? {
                    toolCall: [
                        currentToolCall
                    ]
                } : {},
                delta: choice.delta.content ?? ""
            };
        }
        toolCallMap.clear();
        return;
    }
    static toTool(tool) {
        return {
            type: "function",
            function: tool.metadata.parameters ? {
                name: tool.metadata.name,
                description: tool.metadata.description,
                parameters: tool.metadata.parameters
            } : {
                name: tool.metadata.name,
                description: tool.metadata.description
            }
        };
    }
}
/**
 * Convenience function to create a new OpenAI instance.
 * @param init - Optional initialization parameters for the OpenAI instance.
 * @returns A new OpenAI instance.
 */ const openai = (init)=>new OpenAI(init);
class OpenAIAgentWorker extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$agent$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["LLMAgentWorker"] {
}
class OpenAIAgent extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$agent$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["LLMAgent"] {
    constructor(params){
        const llm = params.llm ?? (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$global$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Settings"].llm instanceof OpenAI ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$global$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Settings"].llm : new OpenAI());
        super({
            ...params,
            llm
        });
    }
}
const ALL_OPENAI_EMBEDDING_MODELS = {
    "text-embedding-ada-002": {
        dimensions: 1536,
        maxTokens: 8192,
        tokenizer: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$tokenizers$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Tokenizers"].CL100K_BASE
    },
    "text-embedding-3-small": {
        dimensions: 1536,
        dimensionOptions: [
            512,
            1536
        ],
        maxTokens: 8192,
        tokenizer: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$tokenizers$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Tokenizers"].CL100K_BASE
    },
    "text-embedding-3-large": {
        dimensions: 3072,
        dimensionOptions: [
            256,
            1024,
            3072
        ],
        maxTokens: 8192,
        tokenizer: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$tokenizers$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Tokenizers"].CL100K_BASE
    }
};
class OpenAIEmbedding extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$embeddings$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["BaseEmbedding"] {
    #session;
    get session() {
        if (!this.#session) {
            this.#session = this.lazySession();
        }
        return this.#session;
    }
    /**
   * OpenAI Embedding
   * @param init - initial parameters
   */ constructor(init){
        super(), /** api key */ this.apiKey = undefined, /** base url */ this.baseURL = undefined, this.#session = null, /**
   * Get embeddings for a batch of texts
   * @param texts
   */ this.getTextEmbeddings = async (texts)=>{
            return this.getOpenAIEmbedding(texts);
        };
        this.model = init?.model ?? "text-embedding-ada-002";
        this.dimensions = init?.dimensions; // if no dimensions provided, will be undefined/not sent to OpenAI
        this.embedBatchSize = init?.embedBatchSize ?? 10;
        this.maxRetries = init?.maxRetries ?? 10;
        this.timeout = init?.timeout ?? 60 * 1000; // Default is 60 seconds
        this.additionalSessionOptions = init?.additionalSessionOptions;
        // find metadata for model
        const key = Object.keys(ALL_OPENAI_EMBEDDING_MODELS).find((key)=>key === this.model);
        if (key) {
            this.embedInfo = ALL_OPENAI_EMBEDDING_MODELS[key];
        }
        if (init?.azure || shouldUseAzure()) {
            const azureConfig = {
                ...getAzureConfigFromEnv({
                    model: getAzureModel(this.model)
                }),
                ...init?.azure
            };
            this.apiKey = init?.session?.apiKey ?? azureConfig.apiKey ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getEnv"])("OPENAI_API_KEY");
            this.baseURL = init?.session?.baseURL ?? azureConfig.baseURL ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getEnv"])("OPENAI_BASE_URL");
            this.lazySession = async ()=>__turbopack_context__.r("[project]/node_modules/openai/index.mjs [app-rsc] (ecmascript, async loader)")(__turbopack_context__.i).then(async ({ AzureOpenAI })=>{
                    AzureOpenAI = AzureOpenAIWithUserAgent(AzureOpenAI);
                    return init?.session ?? new AzureOpenAI({
                        maxRetries: this.maxRetries,
                        timeout: this.timeout,
                        ...this.additionalSessionOptions,
                        ...azureConfig
                    });
                });
        } else {
            this.apiKey = init?.session?.apiKey ?? init?.apiKey ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getEnv"])("OPENAI_API_KEY");
            this.baseURL = init?.session?.baseURL ?? init?.baseURL ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getEnv"])("OPENAI_BASE_URL");
            this.lazySession = async ()=>__turbopack_context__.r("[project]/node_modules/openai/index.mjs [app-rsc] (ecmascript, async loader)")(__turbopack_context__.i).then(({ OpenAI })=>{
                    return init?.session ?? new OpenAI({
                        apiKey: this.apiKey,
                        baseURL: this.baseURL,
                        maxRetries: this.maxRetries,
                        timeout: this.timeout,
                        ...this.additionalSessionOptions
                    });
                });
        }
    }
    /**
   * Get embeddings for a batch of texts
   * @param texts
   * @param options
   */ async getOpenAIEmbedding(input) {
        // TODO: ensure this for every sub class by calling it in the base class
        input = this.truncateMaxTokens(input);
        const { data } = await (await this.session).embeddings.create(this.dimensions ? {
            model: this.model,
            dimensions: this.dimensions,
            input
        } : {
            model: this.model,
            input
        });
        return data.map((d)=>d.embedding);
    }
    /**
   * Get embeddings for a single text
   * @param text
   */ async getTextEmbedding(text) {
        return (await this.getOpenAIEmbedding([
            text
        ]))[0];
    }
}
;
}}),
"[project]/node_modules/@llamaindex/workflow/dist/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "StartEvent": (()=>StartEvent),
    "StopEvent": (()=>StopEvent),
    "Workflow": (()=>Workflow),
    "WorkflowContext": (()=>WorkflowContext),
    "WorkflowEvent": (()=>WorkflowEvent)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@llamaindex/env/dist/index.js [app-rsc] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:crypto [external] (node:crypto, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@llamaindex/env/dist/index.js [app-rsc] (ecmascript) <locals>");
;
class WorkflowEvent {
    constructor(data){
        this.data = data;
        this.displayName = this.constructor.name;
    }
    toString() {
        return this.displayName;
    }
    static or(AEvent, BEvent) {
        function OrEvent() {
            throw new Error("Cannot instantiate OrEvent");
        }
        OrEvent.prototype = Object.create(AEvent.prototype);
        Object.getOwnPropertyNames(BEvent.prototype).forEach((property)=>{
            if (!(property in OrEvent.prototype)) {
                Object.defineProperty(OrEvent.prototype, property, Object.getOwnPropertyDescriptor(BEvent.prototype, property));
            }
        });
        OrEvent.prototype.constructor = OrEvent;
        Object.defineProperty(OrEvent, Symbol.hasInstance, {
            value: function(instance) {
                return instance instanceof AEvent || instance instanceof BEvent;
            }
        });
        return OrEvent;
    }
}
// These are special events that are used to control the workflow
class StartEvent extends WorkflowEvent {
    constructor(data){
        super(data);
    }
}
class StopEvent extends WorkflowEvent {
    constructor(data){
        super(data);
    }
}
var _computedKey, _computedKey1;
function flattenEvents(acceptEventTypes, inputEvents) {
    const eventMap = new Map();
    for (const event of inputEvents){
        for (const acceptType of acceptEventTypes){
            if (event instanceof acceptType && !eventMap.has(acceptType)) {
                eventMap.set(acceptType, event);
                break; // Once matched, no need to check other accept types
            }
        }
    }
    return Array.from(eventMap.values());
}
_computedKey = Symbol.asyncIterator, _computedKey1 = Symbol.toStringTag;
class WorkflowContext {
    #steps;
    #startEvent;
    #queue;
    #queueEventTarget;
    #wait;
    #timeout;
    #verbose;
    #data;
    #stepCache;
    #getStepFunction(event) {
        if (this.#stepCache.has(event)) {
            return this.#stepCache.get(event);
        }
        const set = new Set();
        const stepInputs = new WeakMap();
        const stepOutputs = new WeakMap();
        const res = [
            set,
            stepInputs,
            stepOutputs
        ];
        this.#stepCache.set(event, res);
        for (const [step, { inputs, outputs }] of this.#steps){
            if (inputs.some((input)=>event instanceof input)) {
                set.add(step);
                stepInputs.set(step, inputs);
                stepOutputs.set(step, outputs);
            }
        }
        return res;
    }
    constructor(params){
        this.#queue = [];
        this.#queueEventTarget = new EventTarget();
        this.#timeout = null;
        this.#verbose = false;
        this.#stepCache = new Map();
        // make sure it will only be called once
        this.#iterator = null;
        this.#signal = null;
        this.#sendEvent = (event)=>{
            this.#queue.push({
                type: "event",
                event
            });
        };
        this.#requireEvent = async (event)=>{
            const requestId = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["randomUUID"])();
            this.#queue.push({
                type: "requestEvent",
                id: requestId,
                requestEvent: event
            });
            return new Promise((resolve)=>{
                const handler = (event)=>{
                    if (event instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CustomEvent"]) {
                        const { id } = event.detail;
                        if (requestId === id) {
                            this.#queueEventTarget.removeEventListener("update", handler);
                            resolve(event.detail.event);
                        }
                    }
                };
                this.#queueEventTarget.addEventListener("update", handler);
            });
        };
        this.#pendingInputQueue = [];
        // if strict mode is enabled, it will throw an error if there's input or output events are not expected
        this.#strict = false;
        // PromiseLike implementation, this is following the Promise/A+ spec
        // It will consume the iterator and resolve the promise once it reaches the StopEvent
        // If you want to customize the behavior, you can use the async iterator directly
        this.#resolved = null;
        this.#rejected = null;
        this[_computedKey1] = "Context";
        this.#steps = params.steps;
        this.#startEvent = params.startEvent;
        if (typeof params.timeout === "number") {
            this.#timeout = params.timeout;
        }
        this.#data = params.contextData;
        this.#verbose = params.verbose ?? false;
        this.#wait = params.wait;
        // push start event to the queue
        const [step] = this.#getStepFunction(this.#startEvent);
        if (step.size === 0) {
            throw new TypeError("No step found for start event");
        }
        // restore from snapshot
        if (params.queue) {
            params.queue.forEach((protocol)=>{
                this.#queue.push(protocol);
            });
        } else {
            this.#sendEvent(this.#startEvent);
        }
        if (params.pendingInputQueue) {
            this.#pendingInputQueue = params.pendingInputQueue;
        }
        if (params.resolved) {
            this.#resolved = params.resolved;
        }
        if (params.rejected) {
            this.#rejected = params.rejected;
        }
    }
    #iterator;
    #signal;
    get #iteratorSingleton() {
        if (this.#iterator === null) {
            this.#iterator = this.#createStreamEvents();
        }
        return this.#iterator;
    }
    [_computedKey]() {
        return this.#iteratorSingleton;
    }
    #sendEvent;
    #requireEvent;
    #pendingInputQueue;
    #strict;
    strict() {
        this.#strict = true;
        return this;
    }
    get data() {
        return this.#data;
    }
    /**
   * Stream events from the start event
   *
   * Note that this function will stop once there's no more future events,
   *  if you want stop immediately once reach a StopEvent, you should handle it in the other side.
   * @private
   */ #createStreamEvents() {
        const isPendingEvents = new WeakSet();
        const pendingTasks = new Set();
        const enqueuedEvents = new Set();
        const stream = new ReadableStream({
            start: async (controller)=>{
                while(true){
                    const eventProtocol = this.#queue.shift();
                    if (eventProtocol) {
                        switch(eventProtocol.type){
                            case "requestEvent":
                                {
                                    const { id, requestEvent } = eventProtocol;
                                    const acceptableInput = this.#pendingInputQueue.find((event)=>event instanceof requestEvent);
                                    if (acceptableInput) {
                                        // remove the event from the queue, in case of infinite loop
                                        const protocolIdx = this.#queue.findIndex((protocol)=>protocol.type === "event" && protocol.event === acceptableInput);
                                        if (protocolIdx !== -1) {
                                            this.#queue.splice(protocolIdx, 1);
                                        }
                                        this.#pendingInputQueue.splice(this.#pendingInputQueue.indexOf(acceptableInput), 1);
                                        this.#queueEventTarget.dispatchEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CustomEvent"]("update", {
                                            detail: {
                                                id,
                                                event: acceptableInput
                                            }
                                        }));
                                    } else {
                                        // push back to the queue as there are not enough events
                                        this.#queue.push(eventProtocol);
                                    }
                                    break;
                                }
                            case "event":
                                {
                                    const { event } = eventProtocol;
                                    if (isPendingEvents.has(event)) {
                                        // this event is still processing
                                        this.#sendEvent(event);
                                    } else {
                                        if (!enqueuedEvents.has(event)) {
                                            controller.enqueue(event);
                                            enqueuedEvents.add(event);
                                        }
                                        const [steps, inputsMap, outputsMap] = this.#getStepFunction(event);
                                        const nextEventPromises = [
                                            ...steps
                                        ].map((step)=>{
                                            const inputs = [
                                                ...inputsMap.get(step) ?? []
                                            ];
                                            const acceptableInputs = this.#pendingInputQueue.filter((event)=>inputs.some((input)=>event instanceof input));
                                            const events = flattenEvents(inputs, [
                                                event,
                                                ...acceptableInputs
                                            ]);
                                            // remove the event from the queue, in case of infinite loop
                                            events.forEach((event)=>{
                                                const protocolIdx = this.#queue.findIndex((protocol)=>protocol.type === "event" && protocol.event === event);
                                                if (protocolIdx !== -1) {
                                                    this.#queue.splice(protocolIdx, 1);
                                                }
                                            });
                                            if (events.length !== inputs.length) {
                                                if (this.#verbose) {
                                                    console.log(`Not enough inputs for step ${step.name}, waiting for more events`);
                                                }
                                                // not enough to run the step, push back to the queue
                                                this.#sendEvent(event);
                                                isPendingEvents.add(event);
                                                return null;
                                            }
                                            if (isPendingEvents.has(event)) {
                                                isPendingEvents.delete(event);
                                            }
                                            if (this.#verbose) {
                                                console.log(`Running step ${step.name} with inputs ${events}`);
                                            }
                                            const data = this.data;
                                            return step.call(null, {
                                                get data () {
                                                    return data;
                                                },
                                                sendEvent: this.#sendEvent,
                                                requireEvent: this.#requireEvent
                                            }, ...events.sort((a, b)=>{
                                                const aIndex = inputs.indexOf(a.constructor);
                                                const bIndex = inputs.indexOf(b.constructor);
                                                return aIndex - bIndex;
                                            })).then((nextEvent)=>{
                                                if (nextEvent === undefined) {
                                                    return;
                                                }
                                                if (this.#verbose) {
                                                    console.log(`Step ${step.name} completed, next event is ${nextEvent}`);
                                                }
                                                const outputs = outputsMap.get(step) ?? [];
                                                if (!outputs.some((output)=>nextEvent.constructor === output)) {
                                                    if (this.#strict) {
                                                        const error = Error(`Step ${step.name} returned an unexpected output event ${nextEvent}`);
                                                        controller.error(error);
                                                    } else {
                                                        console.warn(`Step ${step.name} returned an unexpected output event ${nextEvent}`);
                                                    }
                                                }
                                                if (!(nextEvent instanceof StopEvent)) {
                                                    this.#pendingInputQueue.unshift(nextEvent);
                                                    this.#sendEvent(nextEvent);
                                                }
                                                return nextEvent;
                                            });
                                        }).filter((promise)=>promise !== null);
                                        nextEventPromises.forEach((promise)=>{
                                            pendingTasks.add(promise);
                                            promise.catch((err)=>{
                                                console.error("Error in step", err);
                                            }).finally(()=>{
                                                pendingTasks.delete(promise);
                                            });
                                        });
                                        Promise.race(nextEventPromises).then((fastestNextEvent)=>{
                                            if (fastestNextEvent === undefined) {
                                                return;
                                            }
                                            if (!enqueuedEvents.has(fastestNextEvent)) {
                                                controller.enqueue(fastestNextEvent);
                                                enqueuedEvents.add(fastestNextEvent);
                                            }
                                            return fastestNextEvent;
                                        }).then(async (fastestNextEvent)=>Promise.all(nextEventPromises).then((nextEvents)=>{
                                                const events = nextEvents.filter((event)=>event !== undefined);
                                                for (const nextEvent of events){
                                                    // do not enqueue the same event twice
                                                    if (fastestNextEvent !== nextEvent) {
                                                        if (!enqueuedEvents.has(nextEvent)) {
                                                            controller.enqueue(nextEvent);
                                                            enqueuedEvents.add(nextEvent);
                                                        }
                                                    }
                                                }
                                            })).catch((err)=>{
                                            // when the step raise an error, should go back to the previous step
                                            this.#sendEvent(event);
                                            isPendingEvents.add(event);
                                            controller.error(err);
                                        });
                                    }
                                    break;
                                }
                        }
                    }
                    if (this.#queue.length === 0 && pendingTasks.size === 0) {
                        if (this.#verbose) {
                            console.log("No more events in the queue");
                        }
                        break;
                    }
                    await this.#wait();
                }
                controller.close();
            }
        });
        return stream[Symbol.asyncIterator]();
    }
    with(data) {
        return new WorkflowContext({
            startEvent: this.#startEvent,
            wait: this.#wait,
            contextData: data,
            steps: this.#steps,
            timeout: this.#timeout,
            verbose: this.#verbose,
            queue: this.#queue,
            pendingInputQueue: this.#pendingInputQueue,
            resolved: this.#resolved,
            rejected: this.#rejected
        });
    }
    #resolved;
    #rejected;
    async then(onfulfilled, onrejected) {
        onfulfilled ??= (value)=>value;
        onrejected ??= (reason)=>{
            throw reason;
        };
        if (this.#resolved !== null) {
            return Promise.resolve(this.#resolved).then(onfulfilled, onrejected);
        } else if (this.#rejected !== null) {
            return Promise.reject(this.#rejected).then(onfulfilled, onrejected);
        }
        if (this.#timeout !== null) {
            const timeout = this.#timeout;
            this.#signal = AbortSignal.timeout(timeout * 1000);
        }
        this.#signal?.addEventListener("abort", ()=>{
            this.#rejected = new Error(`Operation timed out after ${this.#timeout} seconds`);
            onrejected?.(this.#rejected);
        });
        try {
            for await (const event of this.#iteratorSingleton){
                if (this.#rejected !== null) {
                    return onrejected?.(this.#rejected);
                }
                if (event instanceof StartEvent) {
                    if (this.#verbose) {
                        console.log(`Starting workflow with event ${event}`);
                    }
                }
                if (event instanceof StopEvent) {
                    if (this.#verbose && this.#pendingInputQueue.length > 0) {
                    // fixme: #pendingInputQueue might should be cleanup correctly?
                    }
                    this.#resolved = event;
                    return onfulfilled?.(event);
                }
            }
        } catch (err) {
            if (err instanceof Error) {
                this.#rejected = err;
            }
            return onrejected?.(err);
        }
        const nextValue = await this.#iteratorSingleton.next();
        if (nextValue.done === false) {
            this.#rejected = new Error("Workflow did not complete");
            return onrejected?.(this.#rejected);
        }
        return onrejected?.(new Error("UNREACHABLE"));
    }
    catch(onrejected) {
        return this.then((v)=>v, onrejected);
    }
    finally(onfinally) {
        return this.then(()=>{
            onfinally?.();
        }, ()=>{
            onfinally?.();
        });
    }
    // for worker thread
    snapshot() {
        const state = {
            startEvent: this.#startEvent,
            queue: this.#queue,
            pendingInputQueue: this.#pendingInputQueue,
            data: this.#data,
            timeout: this.#timeout,
            verbose: this.#verbose,
            resolved: this.#resolved,
            rejected: this.#rejected
        };
        const jsonString = JSON.stringify(state, (_, value)=>{
            // If value is an instance of a class, serialize only its properties
            if (value instanceof WorkflowEvent) {
                return {
                    data: value.data,
                    constructor: value.constructor.name
                };
            }
            // value is Subtype of WorkflowEvent
            if (typeof value === "object" && value !== null && value?.prototype instanceof WorkflowEvent) {
                return {
                    constructor: value.prototype.constructor.name
                };
            }
            return value;
        });
        return new TextEncoder().encode(jsonString).buffer;
    }
}
class Workflow {
    #steps;
    #verbose;
    #timeout;
    // fixme: allow microtask
    #nextTick;
    constructor(params = {}){
        this.#steps = new Map();
        this.#verbose = false;
        this.#timeout = null;
        this.#nextTick = ()=>new Promise((resolve)=>setTimeout(resolve, 0));
        if (params.verbose) {
            this.#verbose = params.verbose;
        }
        if (params.timeout) {
            this.#timeout = params.timeout;
        }
        if (params.wait) {
            this.#nextTick = params.wait;
        }
    }
    addStep(parameters, stepFn) {
        const { inputs, outputs } = parameters;
        this.#steps.set(stepFn, {
            inputs,
            outputs
        });
        return this;
    }
    hasStep(stepFn) {
        return this.#steps.has(stepFn);
    }
    removeStep(stepFn) {
        this.#steps.delete(stepFn);
        return this;
    }
    run(event, data) {
        const startEvent = event instanceof StartEvent ? event : new StartEvent(event);
        return new WorkflowContext({
            startEvent,
            wait: this.#nextTick,
            contextData: data,
            steps: new Map(this.#steps),
            timeout: this.#timeout,
            verbose: this.#verbose,
            queue: undefined,
            pendingInputQueue: undefined,
            resolved: null,
            rejected: null
        });
    }
    recover(data) {
        const jsonString = new TextDecoder().decode(data);
        const state = JSON.parse(jsonString);
        const reconstructedStartEvent = new StartEvent(state.startEvent);
        const AllEvents = [
            ...this.#steps
        ].map(([, { inputs, outputs }])=>[
                ...inputs,
                ...outputs ?? []
            ]).flat();
        const reconstructedQueue = state.queue.map((protocol)=>{
            switch(protocol.type){
                case "requestEvent":
                    {
                        const { requestEvent, id } = protocol;
                        const EventType = AllEvents.find((type)=>type.prototype.constructor.name === requestEvent.constructor);
                        if (!EventType) {
                            throw new TypeError(`Event type not found: ${requestEvent.constructor}`);
                        }
                        return {
                            type: "requestEvent",
                            id,
                            requestEvent: EventType
                        };
                    }
                case "event":
                    {
                        const { event } = protocol;
                        const EventType = AllEvents.find((type)=>type.prototype.constructor.name === event.constructor);
                        if (!EventType) {
                            throw new TypeError(`Event type not found: ${event.constructor}`);
                        }
                        return {
                            type: "event",
                            event: new EventType(event.data)
                        };
                    }
            }
        });
        const reconstructedPendingInputQueue = state.pendingInputQueue.map((event)=>{
            const EventType = AllEvents.find((type)=>type.prototype.constructor.name === event.constructor);
            if (!EventType) {
                throw new TypeError(`Event type not found: ${event.constructor}`);
            }
            return new EventType(event.data);
        });
        return new WorkflowContext({
            startEvent: reconstructedStartEvent,
            contextData: state.data,
            wait: this.#nextTick,
            steps: this.#steps,
            timeout: state.timeout,
            verbose: state.verbose,
            queue: reconstructedQueue,
            pendingInputQueue: reconstructedPendingInputQueue,
            resolved: state.resolved ? new StopEvent(state.resolved) : null,
            rejected: state.rejected ? new Error(state.rejected) : null
        });
    }
}
;
}}),
"[project]/node_modules/@llamaindex/workflow/dist/agent/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "AgentInput": (()=>AgentInput),
    "AgentOutput": (()=>AgentOutput),
    "AgentSetup": (()=>AgentSetup),
    "AgentStepEvent": (()=>AgentStepEvent),
    "AgentStream": (()=>AgentStream),
    "AgentToolCall": (()=>AgentToolCall),
    "AgentToolCallResult": (()=>AgentToolCallResult),
    "AgentWorkflow": (()=>AgentWorkflow),
    "FunctionAgent": (()=>FunctionAgent),
    "ToolCallsEvent": (()=>ToolCallsEvent),
    "ToolResultsEvent": (()=>ToolResultsEvent),
    "agent": (()=>agent),
    "multiAgent": (()=>multiAgent)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$memory$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@llamaindex/core/memory/dist/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$prompts$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@llamaindex/core/prompts/dist/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$tools$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@llamaindex/core/tools/dist/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$utils$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@llamaindex/core/utils/dist/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zod/lib/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@llamaindex/env/dist/index.js [app-rsc] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:crypto [external] (node:crypto, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@llamaindex/env/dist/index.js [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$global$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@llamaindex/core/global/dist/index.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
class WorkflowEvent {
    constructor(data){
        this.data = data;
        this.displayName = this.constructor.name;
    }
    toString() {
        return this.displayName;
    }
    static or(AEvent, BEvent) {
        function OrEvent() {
            throw new Error("Cannot instantiate OrEvent");
        }
        OrEvent.prototype = Object.create(AEvent.prototype);
        Object.getOwnPropertyNames(BEvent.prototype).forEach((property)=>{
            if (!(property in OrEvent.prototype)) {
                Object.defineProperty(OrEvent.prototype, property, Object.getOwnPropertyDescriptor(BEvent.prototype, property));
            }
        });
        OrEvent.prototype.constructor = OrEvent;
        Object.defineProperty(OrEvent, Symbol.hasInstance, {
            value: function(instance) {
                return instance instanceof AEvent || instance instanceof BEvent;
            }
        });
        return OrEvent;
    }
}
// These are special events that are used to control the workflow
class StartEvent extends WorkflowEvent {
    constructor(data){
        super(data);
    }
}
class StopEvent extends WorkflowEvent {
    constructor(data){
        super(data);
    }
}
var _computedKey, _computedKey1;
function flattenEvents(acceptEventTypes, inputEvents) {
    const eventMap = new Map();
    for (const event of inputEvents){
        for (const acceptType of acceptEventTypes){
            if (event instanceof acceptType && !eventMap.has(acceptType)) {
                eventMap.set(acceptType, event);
                break; // Once matched, no need to check other accept types
            }
        }
    }
    return Array.from(eventMap.values());
}
_computedKey = Symbol.asyncIterator, _computedKey1 = Symbol.toStringTag;
class WorkflowContext {
    #steps;
    #startEvent;
    #queue;
    #queueEventTarget;
    #wait;
    #timeout;
    #verbose;
    #data;
    #stepCache;
    #getStepFunction(event) {
        if (this.#stepCache.has(event)) {
            return this.#stepCache.get(event);
        }
        const set = new Set();
        const stepInputs = new WeakMap();
        const stepOutputs = new WeakMap();
        const res = [
            set,
            stepInputs,
            stepOutputs
        ];
        this.#stepCache.set(event, res);
        for (const [step, { inputs, outputs }] of this.#steps){
            if (inputs.some((input)=>event instanceof input)) {
                set.add(step);
                stepInputs.set(step, inputs);
                stepOutputs.set(step, outputs);
            }
        }
        return res;
    }
    constructor(params){
        this.#queue = [];
        this.#queueEventTarget = new EventTarget();
        this.#timeout = null;
        this.#verbose = false;
        this.#stepCache = new Map();
        // make sure it will only be called once
        this.#iterator = null;
        this.#signal = null;
        this.#sendEvent = (event)=>{
            this.#queue.push({
                type: "event",
                event
            });
        };
        this.#requireEvent = async (event)=>{
            const requestId = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["randomUUID"])();
            this.#queue.push({
                type: "requestEvent",
                id: requestId,
                requestEvent: event
            });
            return new Promise((resolve)=>{
                const handler = (event)=>{
                    if (event instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CustomEvent"]) {
                        const { id } = event.detail;
                        if (requestId === id) {
                            this.#queueEventTarget.removeEventListener("update", handler);
                            resolve(event.detail.event);
                        }
                    }
                };
                this.#queueEventTarget.addEventListener("update", handler);
            });
        };
        this.#pendingInputQueue = [];
        // if strict mode is enabled, it will throw an error if there's input or output events are not expected
        this.#strict = false;
        // PromiseLike implementation, this is following the Promise/A+ spec
        // It will consume the iterator and resolve the promise once it reaches the StopEvent
        // If you want to customize the behavior, you can use the async iterator directly
        this.#resolved = null;
        this.#rejected = null;
        this[_computedKey1] = "Context";
        this.#steps = params.steps;
        this.#startEvent = params.startEvent;
        if (typeof params.timeout === "number") {
            this.#timeout = params.timeout;
        }
        this.#data = params.contextData;
        this.#verbose = params.verbose ?? false;
        this.#wait = params.wait;
        // push start event to the queue
        const [step] = this.#getStepFunction(this.#startEvent);
        if (step.size === 0) {
            throw new TypeError("No step found for start event");
        }
        // restore from snapshot
        if (params.queue) {
            params.queue.forEach((protocol)=>{
                this.#queue.push(protocol);
            });
        } else {
            this.#sendEvent(this.#startEvent);
        }
        if (params.pendingInputQueue) {
            this.#pendingInputQueue = params.pendingInputQueue;
        }
        if (params.resolved) {
            this.#resolved = params.resolved;
        }
        if (params.rejected) {
            this.#rejected = params.rejected;
        }
    }
    #iterator;
    #signal;
    get #iteratorSingleton() {
        if (this.#iterator === null) {
            this.#iterator = this.#createStreamEvents();
        }
        return this.#iterator;
    }
    [_computedKey]() {
        return this.#iteratorSingleton;
    }
    #sendEvent;
    #requireEvent;
    #pendingInputQueue;
    #strict;
    strict() {
        this.#strict = true;
        return this;
    }
    get data() {
        return this.#data;
    }
    /**
   * Stream events from the start event
   *
   * Note that this function will stop once there's no more future events,
   *  if you want stop immediately once reach a StopEvent, you should handle it in the other side.
   * @private
   */ #createStreamEvents() {
        const isPendingEvents = new WeakSet();
        const pendingTasks = new Set();
        const enqueuedEvents = new Set();
        const stream = new ReadableStream({
            start: async (controller)=>{
                while(true){
                    const eventProtocol = this.#queue.shift();
                    if (eventProtocol) {
                        switch(eventProtocol.type){
                            case "requestEvent":
                                {
                                    const { id, requestEvent } = eventProtocol;
                                    const acceptableInput = this.#pendingInputQueue.find((event)=>event instanceof requestEvent);
                                    if (acceptableInput) {
                                        // remove the event from the queue, in case of infinite loop
                                        const protocolIdx = this.#queue.findIndex((protocol)=>protocol.type === "event" && protocol.event === acceptableInput);
                                        if (protocolIdx !== -1) {
                                            this.#queue.splice(protocolIdx, 1);
                                        }
                                        this.#pendingInputQueue.splice(this.#pendingInputQueue.indexOf(acceptableInput), 1);
                                        this.#queueEventTarget.dispatchEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$env$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CustomEvent"]("update", {
                                            detail: {
                                                id,
                                                event: acceptableInput
                                            }
                                        }));
                                    } else {
                                        // push back to the queue as there are not enough events
                                        this.#queue.push(eventProtocol);
                                    }
                                    break;
                                }
                            case "event":
                                {
                                    const { event } = eventProtocol;
                                    if (isPendingEvents.has(event)) {
                                        // this event is still processing
                                        this.#sendEvent(event);
                                    } else {
                                        if (!enqueuedEvents.has(event)) {
                                            controller.enqueue(event);
                                            enqueuedEvents.add(event);
                                        }
                                        const [steps, inputsMap, outputsMap] = this.#getStepFunction(event);
                                        const nextEventPromises = [
                                            ...steps
                                        ].map((step)=>{
                                            const inputs = [
                                                ...inputsMap.get(step) ?? []
                                            ];
                                            const acceptableInputs = this.#pendingInputQueue.filter((event)=>inputs.some((input)=>event instanceof input));
                                            const events = flattenEvents(inputs, [
                                                event,
                                                ...acceptableInputs
                                            ]);
                                            // remove the event from the queue, in case of infinite loop
                                            events.forEach((event)=>{
                                                const protocolIdx = this.#queue.findIndex((protocol)=>protocol.type === "event" && protocol.event === event);
                                                if (protocolIdx !== -1) {
                                                    this.#queue.splice(protocolIdx, 1);
                                                }
                                            });
                                            if (events.length !== inputs.length) {
                                                if (this.#verbose) {
                                                    console.log(`Not enough inputs for step ${step.name}, waiting for more events`);
                                                }
                                                // not enough to run the step, push back to the queue
                                                this.#sendEvent(event);
                                                isPendingEvents.add(event);
                                                return null;
                                            }
                                            if (isPendingEvents.has(event)) {
                                                isPendingEvents.delete(event);
                                            }
                                            if (this.#verbose) {
                                                console.log(`Running step ${step.name} with inputs ${events}`);
                                            }
                                            const data = this.data;
                                            return step.call(null, {
                                                get data () {
                                                    return data;
                                                },
                                                sendEvent: this.#sendEvent,
                                                requireEvent: this.#requireEvent
                                            }, ...events.sort((a, b)=>{
                                                const aIndex = inputs.indexOf(a.constructor);
                                                const bIndex = inputs.indexOf(b.constructor);
                                                return aIndex - bIndex;
                                            })).then((nextEvent)=>{
                                                if (nextEvent === undefined) {
                                                    return;
                                                }
                                                if (this.#verbose) {
                                                    console.log(`Step ${step.name} completed, next event is ${nextEvent}`);
                                                }
                                                const outputs = outputsMap.get(step) ?? [];
                                                if (!outputs.some((output)=>nextEvent.constructor === output)) {
                                                    if (this.#strict) {
                                                        const error = Error(`Step ${step.name} returned an unexpected output event ${nextEvent}`);
                                                        controller.error(error);
                                                    } else {
                                                        console.warn(`Step ${step.name} returned an unexpected output event ${nextEvent}`);
                                                    }
                                                }
                                                if (!(nextEvent instanceof StopEvent)) {
                                                    this.#pendingInputQueue.unshift(nextEvent);
                                                    this.#sendEvent(nextEvent);
                                                }
                                                return nextEvent;
                                            });
                                        }).filter((promise)=>promise !== null);
                                        nextEventPromises.forEach((promise)=>{
                                            pendingTasks.add(promise);
                                            promise.catch((err)=>{
                                                console.error("Error in step", err);
                                            }).finally(()=>{
                                                pendingTasks.delete(promise);
                                            });
                                        });
                                        Promise.race(nextEventPromises).then((fastestNextEvent)=>{
                                            if (fastestNextEvent === undefined) {
                                                return;
                                            }
                                            if (!enqueuedEvents.has(fastestNextEvent)) {
                                                controller.enqueue(fastestNextEvent);
                                                enqueuedEvents.add(fastestNextEvent);
                                            }
                                            return fastestNextEvent;
                                        }).then(async (fastestNextEvent)=>Promise.all(nextEventPromises).then((nextEvents)=>{
                                                const events = nextEvents.filter((event)=>event !== undefined);
                                                for (const nextEvent of events){
                                                    // do not enqueue the same event twice
                                                    if (fastestNextEvent !== nextEvent) {
                                                        if (!enqueuedEvents.has(nextEvent)) {
                                                            controller.enqueue(nextEvent);
                                                            enqueuedEvents.add(nextEvent);
                                                        }
                                                    }
                                                }
                                            })).catch((err)=>{
                                            // when the step raise an error, should go back to the previous step
                                            this.#sendEvent(event);
                                            isPendingEvents.add(event);
                                            controller.error(err);
                                        });
                                    }
                                    break;
                                }
                        }
                    }
                    if (this.#queue.length === 0 && pendingTasks.size === 0) {
                        if (this.#verbose) {
                            console.log("No more events in the queue");
                        }
                        break;
                    }
                    await this.#wait();
                }
                controller.close();
            }
        });
        return stream[Symbol.asyncIterator]();
    }
    with(data) {
        return new WorkflowContext({
            startEvent: this.#startEvent,
            wait: this.#wait,
            contextData: data,
            steps: this.#steps,
            timeout: this.#timeout,
            verbose: this.#verbose,
            queue: this.#queue,
            pendingInputQueue: this.#pendingInputQueue,
            resolved: this.#resolved,
            rejected: this.#rejected
        });
    }
    #resolved;
    #rejected;
    async then(onfulfilled, onrejected) {
        onfulfilled ??= (value)=>value;
        onrejected ??= (reason)=>{
            throw reason;
        };
        if (this.#resolved !== null) {
            return Promise.resolve(this.#resolved).then(onfulfilled, onrejected);
        } else if (this.#rejected !== null) {
            return Promise.reject(this.#rejected).then(onfulfilled, onrejected);
        }
        if (this.#timeout !== null) {
            const timeout = this.#timeout;
            this.#signal = AbortSignal.timeout(timeout * 1000);
        }
        this.#signal?.addEventListener("abort", ()=>{
            this.#rejected = new Error(`Operation timed out after ${this.#timeout} seconds`);
            onrejected?.(this.#rejected);
        });
        try {
            for await (const event of this.#iteratorSingleton){
                if (this.#rejected !== null) {
                    return onrejected?.(this.#rejected);
                }
                if (event instanceof StartEvent) {
                    if (this.#verbose) {
                        console.log(`Starting workflow with event ${event}`);
                    }
                }
                if (event instanceof StopEvent) {
                    if (this.#verbose && this.#pendingInputQueue.length > 0) {
                    // fixme: #pendingInputQueue might should be cleanup correctly?
                    }
                    this.#resolved = event;
                    return onfulfilled?.(event);
                }
            }
        } catch (err) {
            if (err instanceof Error) {
                this.#rejected = err;
            }
            return onrejected?.(err);
        }
        const nextValue = await this.#iteratorSingleton.next();
        if (nextValue.done === false) {
            this.#rejected = new Error("Workflow did not complete");
            return onrejected?.(this.#rejected);
        }
        return onrejected?.(new Error("UNREACHABLE"));
    }
    catch(onrejected) {
        return this.then((v)=>v, onrejected);
    }
    finally(onfinally) {
        return this.then(()=>{
            onfinally?.();
        }, ()=>{
            onfinally?.();
        });
    }
    // for worker thread
    snapshot() {
        const state = {
            startEvent: this.#startEvent,
            queue: this.#queue,
            pendingInputQueue: this.#pendingInputQueue,
            data: this.#data,
            timeout: this.#timeout,
            verbose: this.#verbose,
            resolved: this.#resolved,
            rejected: this.#rejected
        };
        const jsonString = JSON.stringify(state, (_, value)=>{
            // If value is an instance of a class, serialize only its properties
            if (value instanceof WorkflowEvent) {
                return {
                    data: value.data,
                    constructor: value.constructor.name
                };
            }
            // value is Subtype of WorkflowEvent
            if (typeof value === "object" && value !== null && value?.prototype instanceof WorkflowEvent) {
                return {
                    constructor: value.prototype.constructor.name
                };
            }
            return value;
        });
        return new TextEncoder().encode(jsonString).buffer;
    }
}
class Workflow {
    #steps;
    #verbose;
    #timeout;
    // fixme: allow microtask
    #nextTick;
    constructor(params = {}){
        this.#steps = new Map();
        this.#verbose = false;
        this.#timeout = null;
        this.#nextTick = ()=>new Promise((resolve)=>setTimeout(resolve, 0));
        if (params.verbose) {
            this.#verbose = params.verbose;
        }
        if (params.timeout) {
            this.#timeout = params.timeout;
        }
        if (params.wait) {
            this.#nextTick = params.wait;
        }
    }
    addStep(parameters, stepFn) {
        const { inputs, outputs } = parameters;
        this.#steps.set(stepFn, {
            inputs,
            outputs
        });
        return this;
    }
    hasStep(stepFn) {
        return this.#steps.has(stepFn);
    }
    removeStep(stepFn) {
        this.#steps.delete(stepFn);
        return this;
    }
    run(event, data) {
        const startEvent = event instanceof StartEvent ? event : new StartEvent(event);
        return new WorkflowContext({
            startEvent,
            wait: this.#nextTick,
            contextData: data,
            steps: new Map(this.#steps),
            timeout: this.#timeout,
            verbose: this.#verbose,
            queue: undefined,
            pendingInputQueue: undefined,
            resolved: null,
            rejected: null
        });
    }
    recover(data) {
        const jsonString = new TextDecoder().decode(data);
        const state = JSON.parse(jsonString);
        const reconstructedStartEvent = new StartEvent(state.startEvent);
        const AllEvents = [
            ...this.#steps
        ].map(([, { inputs, outputs }])=>[
                ...inputs,
                ...outputs ?? []
            ]).flat();
        const reconstructedQueue = state.queue.map((protocol)=>{
            switch(protocol.type){
                case "requestEvent":
                    {
                        const { requestEvent, id } = protocol;
                        const EventType = AllEvents.find((type)=>type.prototype.constructor.name === requestEvent.constructor);
                        if (!EventType) {
                            throw new TypeError(`Event type not found: ${requestEvent.constructor}`);
                        }
                        return {
                            type: "requestEvent",
                            id,
                            requestEvent: EventType
                        };
                    }
                case "event":
                    {
                        const { event } = protocol;
                        const EventType = AllEvents.find((type)=>type.prototype.constructor.name === event.constructor);
                        if (!EventType) {
                            throw new TypeError(`Event type not found: ${event.constructor}`);
                        }
                        return {
                            type: "event",
                            event: new EventType(event.data)
                        };
                    }
            }
        });
        const reconstructedPendingInputQueue = state.pendingInputQueue.map((event)=>{
            const EventType = AllEvents.find((type)=>type.prototype.constructor.name === event.constructor);
            if (!EventType) {
                throw new TypeError(`Event type not found: ${event.constructor}`);
            }
            return new EventType(event.data);
        });
        return new WorkflowContext({
            startEvent: reconstructedStartEvent,
            contextData: state.data,
            wait: this.#nextTick,
            steps: this.#steps,
            timeout: state.timeout,
            verbose: state.verbose,
            queue: reconstructedQueue,
            pendingInputQueue: reconstructedPendingInputQueue,
            resolved: state.resolved ? new StopEvent(state.resolved) : null,
            rejected: state.rejected ? new Error(state.rejected) : null
        });
    }
}
class AgentToolCall extends WorkflowEvent {
}
// TODO: Check for if we need a raw tool output
class AgentToolCallResult extends WorkflowEvent {
}
class AgentInput extends WorkflowEvent {
}
class AgentSetup extends WorkflowEvent {
}
class AgentStream extends WorkflowEvent {
}
class AgentOutput extends WorkflowEvent {
}
const DEFAULT_SYSTEM_PROMPT = "You are a helpful assistant. Use the provided tools to answer questions.";
class FunctionAgent {
    constructor({ name, llm, description, tools, canHandoffTo, systemPrompt }){
        this.name = name ?? "Agent";
        this.llm = llm ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$global$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Settings"].llm;
        if (!this.llm.supportToolCall) {
            throw new Error("FunctionAgent requires an LLM that supports tool calls");
        }
        this.description = description ?? "A single agent that uses the provided tools or functions.";
        this.tools = tools;
        if (tools.length === 0) {
            throw new Error("FunctionAgent must have at least one tool");
        }
        // Process canHandoffTo to extract agent names
        this.canHandoffTo = [];
        if (canHandoffTo) {
            if (Array.isArray(canHandoffTo)) {
                if (canHandoffTo.length > 0) {
                    if (typeof canHandoffTo[0] === "string") {
                        // string[] case
                        this.canHandoffTo = canHandoffTo;
                    } else if (canHandoffTo[0] instanceof AgentWorkflow) {
                        // AgentWorkflow[] case
                        const workflows = canHandoffTo;
                        workflows.forEach((workflow)=>{
                            const agentNames = workflow.getAgents().map((agent)=>agent.name);
                            this.canHandoffTo.push(...agentNames);
                        });
                    } else {
                        // BaseWorkflowAgent[] case
                        const agents = canHandoffTo;
                        this.canHandoffTo = agents.map((agent)=>agent.name);
                    }
                }
            }
        }
        const uniqueHandoffAgents = new Set(this.canHandoffTo);
        if (uniqueHandoffAgents.size !== this.canHandoffTo.length) {
            throw new Error("Duplicate handoff agents");
        }
        this.systemPrompt = systemPrompt ?? DEFAULT_SYSTEM_PROMPT;
    }
    async takeStep(ctx, llmInput, tools) {
        // Get scratchpad from context or initialize if not present
        const scratchpad = ctx.data.scratchpad;
        const currentLLMInput = [
            ...llmInput,
            ...scratchpad
        ];
        const responseStream = await this.llm.chat({
            messages: currentLLMInput,
            tools,
            stream: true
        });
        let response = "";
        let lastChunk;
        const toolCalls = new Map();
        for await (const chunk of responseStream){
            response += chunk.delta;
            ctx.sendEvent(new AgentStream({
                delta: chunk.delta,
                response: response,
                currentAgentName: this.name,
                raw: chunk.raw
            }));
            const toolCallsInChunk = this.getToolCallFromResponseChunk(chunk);
            if (toolCallsInChunk.length > 0) {
                // Just upsert the tool calls with the latest one if they exist
                toolCallsInChunk.forEach((toolCall)=>{
                    toolCalls.set(toolCall.data.toolId, toolCall);
                });
            }
        }
        const message = {
            role: "assistant",
            content: response
        };
        if (toolCalls.size > 0) {
            message.options = {
                toolCall: Array.from(toolCalls.values()).map((toolCall)=>({
                        name: toolCall.data.toolName,
                        input: toolCall.data.toolKwargs,
                        id: toolCall.data.toolId
                    }))
            };
        }
        scratchpad.push(message);
        ctx.data.scratchpad = scratchpad;
        return new AgentOutput({
            response: message,
            toolCalls: Array.from(toolCalls.values()),
            raw: lastChunk?.raw,
            currentAgentName: this.name
        });
    }
    async handleToolCallResults(ctx, results) {
        const scratchpad = ctx.data.scratchpad;
        for (const result of results){
            const content = result.data.toolOutput.result;
            const rawToolMessage = {
                role: "user",
                content,
                options: {
                    toolResult: {
                        id: result.data.toolId,
                        result: content,
                        isError: result.data.toolOutput.isError
                    }
                }
            };
            ctx.data.scratchpad.push(rawToolMessage);
        }
        ctx.data.scratchpad = scratchpad;
    }
    async finalize(ctx, output, memory) {
        // Get scratchpad messages
        const scratchpad = ctx.data.scratchpad;
        for (const msg of scratchpad){
            memory.put(msg);
        }
        // Clear scratchpad after finalization
        ctx.data.scratchpad = [];
        return output;
    }
    getToolCallFromResponseChunk(responseChunk) {
        const toolCalls = [];
        const options = responseChunk.options ?? {};
        if (options && "toolCall" in options && Array.isArray(options.toolCall)) {
            toolCalls.push(...options.toolCall.map((call)=>{
                // Convert input to arguments format
                let toolKwargs;
                if (typeof call.input === "string") {
                    try {
                        toolKwargs = JSON.parse(call.input);
                    } catch (e) {
                        toolKwargs = {
                            rawInput: call.input
                        };
                    }
                } else {
                    toolKwargs = call.input;
                }
                return new AgentToolCall({
                    agentName: this.name,
                    toolName: call.name,
                    toolKwargs: toolKwargs,
                    toolId: call.id
                });
            }));
        }
        const invalidToolCalls = toolCalls.filter((call)=>!this.tools.some((tool)=>tool.metadata.name === call.data.toolName));
        if (invalidToolCalls.length > 0) {
            const invalidToolNames = invalidToolCalls.map((call)=>call.data.toolName).join(", ");
            throw new Error(`Tools not found: ${invalidToolNames}`);
        }
        return toolCalls;
    }
}
const DEFAULT_HANDOFF_PROMPT = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$prompts$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["PromptTemplate"]({
    template: `Useful for handing off to another agent.
If you are currently not equipped to handle the user's request, or another agent is better suited to handle the request, please hand off to the appropriate agent.

Currently available agents: 
{agent_info}
`
});
const DEFAULT_HANDOFF_OUTPUT_PROMPT = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$prompts$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["PromptTemplate"]({
    template: `Agent {to_agent} is now handling the request due to the following reason: {reason}.\nPlease continue with the current request.`
});
// Wrapper events for multiple tool calls and results
class ToolCallsEvent extends WorkflowEvent {
}
class ToolResultsEvent extends WorkflowEvent {
}
class AgentStepEvent extends WorkflowEvent {
}
/**
 * Create a multi-agent workflow
 * @param params - Parameters for the AgentWorkflow
 * @returns A new AgentWorkflow instance
 */ const multiAgent = (params)=>{
    return new AgentWorkflow(params);
};
/**
 * Create a simple workflow with a single agent and specified tools
 * @param params - Parameters for the single agent workflow
 * @returns A new AgentWorkflow instance
 */ const agent = (params)=>{
    return AgentWorkflow.fromTools(params);
};
/**
 * AgentWorkflow - An event-driven workflow for executing agents with tools
 *
 * This class provides a simple interface for creating and running agent workflows
 * based on the LlamaIndexTS workflow system. It supports single agent workflows
 * with multiple tools.
 */ class AgentWorkflow {
    constructor({ agents, rootAgent, verbose, timeout }){
        this.agents = new Map();
        this.handleInputStep = async (ctx, event)=>{
            const { userInput, chatHistory } = event.data;
            const memory = ctx.data.memory;
            if (chatHistory) {
                chatHistory.forEach((message)=>{
                    memory.put(message);
                });
            }
            if (userInput) {
                const userMessage = {
                    role: "user",
                    content: userInput
                };
                memory.put(userMessage);
            } else if (chatHistory) {
                // If no user message, use the last message from chat history as user_msg_str
                const lastMessage = chatHistory[chatHistory.length - 1];
                if (lastMessage?.role !== "user") {
                    throw new Error("Either provide a user message or a chat history with a user message as the last message");
                }
                ctx.data.userInput = lastMessage.content;
            } else {
                throw new Error("No user message or chat history provided");
            }
            return new AgentInput({
                input: await memory.getMessages(),
                currentAgentName: this.rootAgentName
            });
        };
        this.setupAgent = async (ctx, event)=>{
            const currentAgentName = event.data.currentAgentName;
            const agent = this.agents.get(currentAgentName);
            if (!agent) {
                throw new Error(`Agent ${currentAgentName} not found`);
            }
            const llmInput = event.data.input;
            if (agent.systemPrompt) {
                llmInput.unshift({
                    role: "system",
                    content: agent.systemPrompt
                });
            }
            return new AgentSetup({
                input: llmInput,
                currentAgentName: currentAgentName
            });
        };
        this.runAgentStep = async (ctx, event)=>{
            const agent = this.agents.get(event.data.currentAgentName);
            if (!agent) {
                throw new Error("No valid agent found");
            }
            if (this.verbose) {
                console.log(`[Agent ${agent.name}]: Running for input: ${event.data.input[event.data.input.length - 1]?.content}`);
            }
            const output = await agent.takeStep(ctx, event.data.input, agent.tools);
            ctx.sendEvent(output);
            return new AgentStepEvent({
                agentName: agent.name,
                response: output.data.response,
                toolCalls: output.data.toolCalls
            });
        };
        this.parseAgentOutput = async (ctx, event)=>{
            const { agentName, response, toolCalls } = event.data;
            // If no tool calls, return final response
            if (!toolCalls || toolCalls.length === 0) {
                if (this.verbose) {
                    console.log(`[Agent ${agentName}]: No tool calls to process, returning final response`);
                }
                const agentOutput = new AgentOutput({
                    response,
                    toolCalls: [],
                    raw: response,
                    currentAgentName: agentName
                });
                const content = await this.agents.get(agentName)?.finalize(ctx, agentOutput, ctx.data.memory);
                return new StopEvent({
                    result: content?.data.response.content
                });
            }
            return new ToolCallsEvent({
                agentName,
                toolCalls
            });
        };
        this.executeToolCalls = async (ctx, event)=>{
            const { agentName, toolCalls } = event.data;
            const agent = this.agents.get(agentName);
            if (!agent) {
                throw new Error(`Agent ${agentName} not found`);
            }
            const results = [];
            // Execute each tool call
            for (const toolCall of toolCalls){
                // Send single tool call event, useful for UI
                ctx.sendEvent(toolCall);
                const toolResult = new AgentToolCallResult({
                    toolName: toolCall.data.toolName,
                    toolKwargs: toolCall.data.toolKwargs,
                    toolId: toolCall.data.toolId,
                    toolOutput: {
                        id: toolCall.data.toolId,
                        result: "",
                        isError: false
                    },
                    returnDirect: false
                });
                try {
                    const output = await this.callTool(toolCall, ctx);
                    toolResult.data.toolOutput.result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$utils$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["stringifyJSONToMessageContent"])(output);
                    toolResult.data.returnDirect = toolCall.data.toolName === "handOff";
                } catch (error) {
                    toolResult.data.toolOutput.isError = true;
                    toolResult.data.toolOutput.result = `Error: ${error}`;
                }
                results.push(toolResult);
                // Send single tool result event, useful for UI
                ctx.sendEvent(toolResult);
            }
            return new ToolResultsEvent({
                agentName,
                results
            });
        };
        this.processToolResults = async (ctx, event)=>{
            const { agentName, results } = event.data;
            // Get agent
            const agent = this.agents.get(agentName);
            if (!agent) {
                throw new Error(`Agent ${agentName} not found`);
            }
            await agent.handleToolCallResults(ctx, results);
            const directResult = results.find((r)=>r.data.returnDirect);
            if (directResult) {
                const isHandoff = directResult.data.toolName === "handOff";
                const output = typeof directResult.data.toolOutput.result === "string" ? directResult.data.toolOutput.result : JSON.stringify(directResult.data.toolOutput.result);
                const agentOutput = new AgentOutput({
                    response: {
                        role: "assistant",
                        content: output
                    },
                    toolCalls: [],
                    raw: output,
                    currentAgentName: agent.name
                });
                await agent.finalize(ctx, agentOutput, ctx.data.memory);
                if (isHandoff) {
                    const nextAgentName = ctx.data.nextAgentName;
                    console.log(`[Agent ${agentName}]: Handoff to ${nextAgentName}: ${directResult.data.toolOutput.result}`);
                    if (nextAgentName) {
                        ctx.data.currentAgentName = nextAgentName;
                        ctx.data.nextAgentName = null;
                        const messages = await ctx.data.memory.getMessages();
                        return new AgentInput({
                            input: messages,
                            currentAgentName: nextAgentName
                        });
                    }
                }
                return new StopEvent({
                    result: output
                });
            }
            // Continue with another agent step
            const messages = await ctx.data.memory.getMessages();
            return new AgentInput({
                input: messages,
                currentAgentName: agent.name
            });
        };
        this.workflow = new Workflow({
            verbose: verbose ?? false,
            timeout: timeout ?? 60
        });
        this.verbose = verbose ?? false;
        // Handle AgentWorkflow cases for agents
        const processedAgents = [];
        if (agents.length > 0) {
            if (agents[0] instanceof AgentWorkflow) {
                // If agents is AgentWorkflow[], extract the BaseWorkflowAgent from each workflow
                const agentWorkflows = agents;
                agentWorkflows.forEach((workflow)=>{
                    const workflowAgents = workflow.getAgents();
                    processedAgents.push(...workflowAgents);
                });
            } else {
                // Otherwise, agents is already BaseWorkflowAgent[]
                processedAgents.push(...agents);
            }
        }
        // Handle AgentWorkflow case for rootAgent and set rootAgentName
        if (rootAgent instanceof AgentWorkflow) {
            // If rootAgent is an AgentWorkflow, check if it has exactly one agent
            const rootAgents = rootAgent.getAgents();
            if (rootAgents.length !== 1) {
                throw new Error(`Root agent must be a single agent, but it is a workflow with ${rootAgents.length} agents`);
            }
            // We know rootAgents[0] exists because we checked length === 1 above
            this.rootAgentName = rootAgents[0].name;
        } else {
            // Otherwise, rootAgent is already a BaseWorkflowAgent
            this.rootAgentName = rootAgent.name;
        }
        // Validate root agent
        if (!processedAgents.some((a)=>a.name === this.rootAgentName)) {
            throw new Error(`Root agent ${this.rootAgentName} not found in agents`);
        }
        this.addAgents(processedAgents);
    }
    validateAgent(agent) {
        // Validate that all canHandoffTo agents exist
        const invalidAgents = agent.canHandoffTo.filter((name)=>!this.agents.has(name));
        if (invalidAgents.length > 0) {
            throw new Error(`Agent "${agent.name}" references non-existent agents in canHandoffTo: ${invalidAgents.join(", ")}`);
        }
    }
    addHandoffTool(agent) {
        const handoffTool = createHandoffTool(this.agents);
        if (agent.canHandoffTo.length > 0 && !agent.tools.some((t)=>t.metadata.name === handoffTool.metadata.name)) {
            agent.tools.push(handoffTool);
        }
    }
    addAgents(agents) {
        const agentNames = new Set(agents.map((a)=>a.name));
        if (agentNames.size !== agents.length) {
            throw new Error("The agent names must be unique!");
        }
        // First pass: add all agents to the map
        agents.forEach((agent)=>{
            this.agents.set(agent.name, agent);
        });
        // Second pass: validate and setup handoff tools
        agents.forEach((agent)=>{
            this.validateAgent(agent);
            this.addHandoffTool(agent);
        });
    }
    /**
   * Adds a new agent to the workflow
   */ addAgent(agent) {
        this.agents.set(agent.name, agent);
        this.validateAgent(agent);
        this.addHandoffTool(agent);
        return this;
    }
    /**
   * Gets all agents in this workflow
   * @returns Array of agents in this workflow
   */ getAgents() {
        return Array.from(this.agents.values());
    }
    /**
   * Create a simple workflow with a single agent and specified tools
   * @param params - Parameters for the single agent workflow
   * @returns A new AgentWorkflow instance
   */ static fromTools(params) {
        const agent = new FunctionAgent({
            name: params.name,
            description: params.description,
            tools: params.tools,
            llm: params.llm,
            systemPrompt: params.systemPrompt
        });
        const workflow = new AgentWorkflow({
            agents: [
                agent
            ],
            rootAgent: agent,
            verbose: params.verbose ?? false,
            timeout: params.timeout ?? 60
        });
        return workflow;
    }
    setupWorkflowSteps() {
        this.workflow.addStep({
            inputs: [
                StartEvent
            ],
            outputs: [
                AgentInput
            ]
        }, this.handleInputStep);
        this.workflow.addStep({
            inputs: [
                AgentInput
            ],
            outputs: [
                AgentSetup
            ]
        }, this.setupAgent);
        this.workflow.addStep({
            inputs: [
                AgentSetup
            ],
            outputs: [
                AgentStepEvent
            ]
        }, this.runAgentStep);
        this.workflow.addStep({
            inputs: [
                AgentStepEvent
            ],
            outputs: [
                ToolCallsEvent,
                StopEvent
            ]
        }, this.parseAgentOutput);
        this.workflow.addStep({
            inputs: [
                ToolCallsEvent
            ],
            outputs: [
                ToolResultsEvent,
                StopEvent
            ]
        }, this.executeToolCalls);
        this.workflow.addStep({
            inputs: [
                ToolResultsEvent
            ],
            outputs: [
                AgentInput,
                StopEvent
            ]
        }, this.processToolResults);
        return this;
    }
    callTool(toolCall, ctx) {
        const tool = this.agents.get(toolCall.data.agentName)?.tools.find((t)=>t.metadata.name === toolCall.data.toolName);
        if (!tool) {
            throw new Error(`Tool ${toolCall.data.toolName} not found`);
        }
        if (tool.metadata.requireContext) {
            const input = {
                context: ctx.data,
                ...toolCall.data.toolKwargs
            };
            return tool.call(input);
        } else {
            return tool.call(toolCall.data.toolKwargs);
        }
    }
    run(userInput, params) {
        if (this.agents.size === 0) {
            throw new Error("No agents added to workflow");
        }
        this.setupWorkflowSteps();
        const contextData = params?.context ?? {
            userInput: userInput,
            memory: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$memory$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ChatMemoryBuffer"](),
            scratchpad: [],
            currentAgentName: this.rootAgentName,
            agents: Array.from(this.agents.keys()),
            nextAgentName: null
        };
        const result = this.workflow.run({
            userInput: userInput,
            chatHistory: params?.chatHistory
        }, contextData);
        return result;
    }
}
const createHandoffTool = (agents)=>{
    const agentInfo = Array.from(agents.values()).reduce((acc, a)=>{
        acc[a.name] = a.description;
        return acc;
    }, {});
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$tools$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["FunctionTool"].from(({ context, toAgent, reason })=>{
        if (!context) {
            throw new Error("Context is required for handoff");
        }
        const agents = context.agents;
        if (!agents.includes(toAgent)) {
            return `Agent ${toAgent} not found. Select a valid agent to hand off to. Valid agents: ${agents.join(", ")}`;
        }
        context.nextAgentName = toAgent;
        return DEFAULT_HANDOFF_OUTPUT_PROMPT.format({
            to_agent: toAgent,
            reason: reason
        });
    }, {
        name: "handOff",
        description: DEFAULT_HANDOFF_PROMPT.format({
            agent_info: JSON.stringify(agentInfo)
        }),
        parameters: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["z"].object({
            toAgent: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["z"].string({
                description: "The name of the agent to hand off to"
            }),
            reason: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["z"].string({
                description: "The reason for handing off to the agent"
            })
        }),
        requireContext: true
    });
};
;
}}),
"[project]/node_modules/@llamaindex/node-parser/code/dist/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "CodeSplitter": (()=>CodeSplitter),
    "DEFAULT_MAX_CHARS": (()=>DEFAULT_MAX_CHARS)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$global$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@llamaindex/core/global/dist/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$node$2d$parser$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@llamaindex/core/node-parser/dist/index.js [app-rsc] (ecmascript)");
;
;
const DEFAULT_MAX_CHARS = 1500;
class CodeSplitter extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$node$2d$parser$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["TextSplitter"] {
    #parser;
    constructor(params){
        super(), this.maxChars = DEFAULT_MAX_CHARS;
        this.#parser = params.getParser();
        if (params.maxChars) {
            this.maxChars = params.maxChars;
        }
    }
    #chunkNode(node, text, lastEnd = 0) {
        let newChunks = [];
        let currentChunk = "";
        for (const child of node.children){
            if (child.endIndex - child.startIndex > this.maxChars) {
                // Child is too big, recursively chunk the child
                if (currentChunk.length > 0) {
                    newChunks.push(currentChunk.trim());
                    currentChunk = "";
                }
                newChunks = newChunks.concat(this.#chunkNode(child, text, lastEnd));
            } else if (currentChunk.length + (child.endIndex - child.startIndex) > this.maxChars) {
                // Child would make the current chunk too big, so start a new chunk
                newChunks.push(currentChunk.trim());
                currentChunk = text.slice(lastEnd, child.endIndex);
            } else {
                currentChunk += text.slice(lastEnd, child.endIndex);
            }
            lastEnd = child.endIndex;
        }
        if (currentChunk.length > 0) {
            newChunks.push(currentChunk.trim());
        }
        return newChunks;
    }
    splitText(text) {
        const callbackManager = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$global$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Settings"].callbackManager;
        callbackManager.dispatchEvent("chunking-start", {
            text: [
                text
            ]
        });
        const tree = this.#parser.parse(text);
        const rootNode = tree.rootNode;
        if (rootNode.children.length === 0 || rootNode.children[0]?.type === "ERROR") {
            throw new Error("Could not parse code with language");
        } else {
            const chunks = this.#chunkNode(rootNode, text);
            callbackManager.dispatchEvent("chunking-end", {
                chunks
            });
            return chunks;
        }
    }
}
;
}}),
"[project]/node_modules/@llamaindex/node-parser/html/dist/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "HTMLNodeParser": (()=>HTMLNodeParser)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$node$2d$parser$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@llamaindex/core/node-parser/dist/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$schema$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@llamaindex/core/schema/dist/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$text$2f$lib$2f$html$2d$to$2d$text$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/html-to-text/lib/html-to-text.mjs [app-rsc] (ecmascript)");
;
;
;
class HTMLNodeParser extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$node$2d$parser$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NodeParser"] {
    constructor(params){
        super(), this.htmlToTextOptions = undefined;
        if (params?.htmlToTextOptions) {
            this.htmlToTextOptions = params.htmlToTextOptions;
        }
    }
    parseNodes(documents) {
        const nodes = [];
        for (const document of documents){
            const text = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$text$2f$lib$2f$html$2d$to$2d$text$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["htmlToText"])(document.getContent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$schema$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MetadataMode"].NONE), this.htmlToTextOptions);
            nodes.push(...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$llamaindex$2f$core$2f$schema$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["buildNodeFromSplits"])([
                text
            ], document));
        }
        return nodes;
    }
}
;
}}),

};

//# sourceMappingURL=node_modules_%40llamaindex_b3c07b79._.js.map
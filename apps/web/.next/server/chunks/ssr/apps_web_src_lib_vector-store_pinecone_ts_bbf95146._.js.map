{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/vector-store/pinecone.ts"],"sourcesContent":["import type {\r\n  FetchResponse,\r\n  ListResponse,\r\n  QueryResponse,\r\n  RecordMetadata,\r\n} from \"@pinecone-database/pinecone\";\r\n\r\nexport class Pinecone {\r\n  private apiKey: string;\r\n  private indexHost: string;\r\n  private namespace: string;\r\n\r\n  constructor({\r\n    apiKey,\r\n    indexHost,\r\n    namespace,\r\n  }: {\r\n    apiKey: string;\r\n    indexHost: string;\r\n    namespace: string;\r\n  }) {\r\n    this.apiKey = apiKey;\r\n    this.indexHost = indexHost;\r\n    this.namespace = namespace;\r\n  }\r\n\r\n  private async makeRequest<T>(\r\n    method: string,\r\n    path: string,\r\n    body?: object,\r\n    { includeBody = true }: { includeBody?: boolean } = {},\r\n  ) {\r\n    const combinedBody = {\r\n      namespace: this.namespace,\r\n      ...body,\r\n    };\r\n\r\n    let finalPath = path;\r\n    let finalBody = undefined;\r\n\r\n    if (includeBody) {\r\n      if (method === \"GET\") {\r\n        const cleanObject = Object.fromEntries(\r\n          Object.entries(combinedBody as Record<string, string>).filter(\r\n            ([_, value]) => value !== undefined,\r\n          ),\r\n        );\r\n        finalPath = `${path}?${new URLSearchParams(cleanObject).toString()}`;\r\n      } else {\r\n        finalBody = JSON.stringify(combinedBody);\r\n      }\r\n    }\r\n\r\n    const response = await fetch(`${this.indexHost}${finalPath}`, {\r\n      method,\r\n      headers: {\r\n        \"Api-Key\": this.apiKey,\r\n        \"Content-Type\": \"application/json\",\r\n        \"X-Pinecone-Api-Version\": \"2025-01\",\r\n      },\r\n      body: finalBody,\r\n    });\r\n\r\n    const json = await response.json();\r\n\r\n    return json as T;\r\n  }\r\n\r\n  async list(\r\n    params: {\r\n      prefix?: string;\r\n      paginationToken?: string;\r\n    } = {},\r\n  ): Promise<ListResponse> {\r\n    return this.makeRequest<ListResponse>(\"GET\", \"/vectors/list\", params);\r\n  }\r\n\r\n  async fetch(\r\n    ids: string[],\r\n  ): Promise<\r\n    Omit<FetchResponse, \"records\"> & { vectors: FetchResponse[\"records\"] }\r\n  > {\r\n    return this.makeRequest<\r\n      Omit<FetchResponse, \"records\"> & { vectors: FetchResponse[\"records\"] }\r\n    >(\r\n      \"GET\",\r\n      `/vectors/fetch?namespace=${this.namespace}&${ids.map((id) => `ids=${encodeURIComponent(id)}`).join(\"&\")}`,\r\n      undefined,\r\n      { includeBody: false },\r\n    );\r\n  }\r\n\r\n  async query(params: {\r\n    vector: number[];\r\n    topK?: number;\r\n    filter?: object;\r\n    includeMetadata?: boolean;\r\n    includeValues?: boolean;\r\n    sparseVector?: {\r\n      indices: number[];\r\n      values: number[];\r\n    };\r\n    id?: string;\r\n  }): Promise<QueryResponse<RecordMetadata>> {\r\n    return this.makeRequest<QueryResponse<RecordMetadata>>(\r\n      \"POST\",\r\n      `/query`,\r\n      params,\r\n    );\r\n  }\r\n\r\n  async upsert(\r\n    chunks: {\r\n      id: string;\r\n      vector: number[];\r\n      metadata?: Record<string, unknown>;\r\n    }[],\r\n  ) {\r\n    return this.makeRequest<{ success: boolean }>(\"POST\", `/vectors/upsert`, {\r\n      vectors: chunks.map((chunk) => ({\r\n        id: chunk.id,\r\n        values: chunk.vector,\r\n        ...(chunk.metadata && { metadata: chunk.metadata }),\r\n      })),\r\n    });\r\n  }\r\n\r\n  async delete(ids: string[]) {\r\n    return this.makeRequest<{ success: boolean }>(\"POST\", `/vectors/delete`, {\r\n      ids,\r\n    });\r\n  }\r\n\r\n  async deleteNamespace() {\r\n    return this.makeRequest<{ success: boolean }>(\"POST\", `/vectors/delete`, {\r\n      deleteAll: true,\r\n    });\r\n  }\r\n\r\n  async getDimensions() {\r\n    const response = await this.makeRequest<{ dimension: number }>(\r\n      \"GET\",\r\n      \"/describe_index_stats\",\r\n      undefined,\r\n      { includeBody: false },\r\n    );\r\n    return response.dimension;\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;AAOO,MAAM;IACH,OAAe;IACf,UAAkB;IAClB,UAAkB;IAE1B,YAAY,EACV,MAAM,EACN,SAAS,EACT,SAAS,EAKV,CAAE;QACD,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,SAAS,GAAG;IACnB;IAEA,MAAc,YACZ,MAAc,EACd,IAAY,EACZ,IAAa,EACb,EAAE,cAAc,IAAI,EAA6B,GAAG,CAAC,CAAC,EACtD;QACA,MAAM,eAAe;YACnB,WAAW,IAAI,CAAC,SAAS;YACzB,GAAG,IAAI;QACT;QAEA,IAAI,YAAY;QAChB,IAAI,YAAY;QAEhB,IAAI,aAAa;YACf,IAAI,WAAW,OAAO;gBACpB,MAAM,cAAc,OAAO,WAAW,CACpC,OAAO,OAAO,CAAC,cAAwC,MAAM,CAC3D,CAAC,CAAC,GAAG,MAAM,GAAK,UAAU;gBAG9B,YAAY,GAAG,KAAK,CAAC,EAAE,IAAI,gBAAgB,aAAa,QAAQ,IAAI;YACtE,OAAO;gBACL,YAAY,KAAK,SAAS,CAAC;YAC7B;QACF;QAEA,MAAM,WAAW,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,GAAG,WAAW,EAAE;YAC5D;YACA,SAAS;gBACP,WAAW,IAAI,CAAC,MAAM;gBACtB,gBAAgB;gBAChB,0BAA0B;YAC5B;YACA,MAAM;QACR;QAEA,MAAM,OAAO,MAAM,SAAS,IAAI;QAEhC,OAAO;IACT;IAEA,MAAM,KACJ,SAGI,CAAC,CAAC,EACiB;QACvB,OAAO,IAAI,CAAC,WAAW,CAAe,OAAO,iBAAiB;IAChE;IAEA,MAAM,MACJ,GAAa,EAGb;QACA,OAAO,IAAI,CAAC,WAAW,CAGrB,OACA,CAAC,yBAAyB,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,IAAI,GAAG,CAAC,CAAC,KAAO,CAAC,IAAI,EAAE,mBAAmB,KAAK,EAAE,IAAI,CAAC,MAAM,EAC1G,WACA;YAAE,aAAa;QAAM;IAEzB;IAEA,MAAM,MAAM,MAWX,EAA0C;QACzC,OAAO,IAAI,CAAC,WAAW,CACrB,QACA,CAAC,MAAM,CAAC,EACR;IAEJ;IAEA,MAAM,OACJ,MAIG,EACH;QACA,OAAO,IAAI,CAAC,WAAW,CAAuB,QAAQ,CAAC,eAAe,CAAC,EAAE;YACvE,SAAS,OAAO,GAAG,CAAC,CAAC,QAAU,CAAC;oBAC9B,IAAI,MAAM,EAAE;oBACZ,QAAQ,MAAM,MAAM;oBACpB,GAAI,MAAM,QAAQ,IAAI;wBAAE,UAAU,MAAM,QAAQ;oBAAC,CAAC;gBACpD,CAAC;QACH;IACF;IAEA,MAAM,OAAO,GAAa,EAAE;QAC1B,OAAO,IAAI,CAAC,WAAW,CAAuB,QAAQ,CAAC,eAAe,CAAC,EAAE;YACvE;QACF;IACF;IAEA,MAAM,kBAAkB;QACtB,OAAO,IAAI,CAAC,WAAW,CAAuB,QAAQ,CAAC,eAAe,CAAC,EAAE;YACvE,WAAW;QACb;IACF;IAEA,MAAM,gBAAgB;QACpB,MAAM,WAAW,MAAM,IAAI,CAAC,WAAW,CACrC,OACA,yBACA,WACA;YAAE,aAAa;QAAM;QAEvB,OAAO,SAAS,SAAS;IAC3B;AACF","debugId":null}}]
}
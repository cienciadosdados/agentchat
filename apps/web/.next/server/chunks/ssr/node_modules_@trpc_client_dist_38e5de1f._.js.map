{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/links/internals/createChain.mjs"],"sourcesContent":["import { observable } from '@trpc/server/observable';\n\n/** @internal */ function createChain(opts) {\n    return observable((observer)=>{\n        function execute(index = 0, op = opts.op) {\n            const next = opts.links[index];\n            if (!next) {\n                throw new Error('No more links to execute - did you forget to add an ending link?');\n            }\n            const subscription = next({\n                op,\n                next (nextOp) {\n                    const nextObserver = execute(index + 1, nextOp);\n                    return nextObserver;\n                }\n            });\n            return subscription;\n        }\n        const obs$ = execute();\n        return obs$.subscribe(observer);\n    });\n}\n\nexport { createChain };\n"],"names":[],"mappings":";;;AAAA;AAAA;;AAEA,cAAc,GAAG,SAAS,YAAY,IAAI;IACtC,OAAO,CAAA,GAAA,qKAAA,CAAA,aAAU,AAAD,EAAE,CAAC;QACf,SAAS,QAAQ,QAAQ,CAAC,EAAE,KAAK,KAAK,EAAE;YACpC,MAAM,OAAO,KAAK,KAAK,CAAC,MAAM;YAC9B,IAAI,CAAC,MAAM;gBACP,MAAM,IAAI,MAAM;YACpB;YACA,MAAM,eAAe,KAAK;gBACtB;gBACA,MAAM,MAAM;oBACR,MAAM,eAAe,QAAQ,QAAQ,GAAG;oBACxC,OAAO;gBACX;YACJ;YACA,OAAO;QACX;QACA,MAAM,OAAO;QACb,OAAO,KAAK,SAAS,CAAC;IAC1B;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/TRPCClientError.mjs"],"sourcesContent":["import { isObject } from '@trpc/server/unstable-core-do-not-import';\n\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction isTRPCClientError(cause) {\n    return cause instanceof TRPCClientError || /**\n     * @deprecated\n     * Delete in next major\n     */ cause instanceof Error && cause.name === 'TRPCClientError';\n}\nfunction isTRPCErrorResponse(obj) {\n    return isObject(obj) && isObject(obj['error']) && typeof obj['error']['code'] === 'number' && typeof obj['error']['message'] === 'string';\n}\nfunction getMessageFromUnknownError(err, fallback) {\n    if (typeof err === 'string') {\n        return err;\n    }\n    if (isObject(err) && typeof err['message'] === 'string') {\n        return err['message'];\n    }\n    return fallback;\n}\nclass TRPCClientError extends Error {\n    static from(_cause, opts = {}) {\n        const cause = _cause;\n        if (isTRPCClientError(cause)) {\n            if (opts.meta) {\n                // Decorate with meta error data\n                cause.meta = {\n                    ...cause.meta,\n                    ...opts.meta\n                };\n            }\n            return cause;\n        }\n        if (isTRPCErrorResponse(cause)) {\n            return new TRPCClientError(cause.error.message, {\n                ...opts,\n                result: cause\n            });\n        }\n        return new TRPCClientError(getMessageFromUnknownError(cause, 'Unknown error'), {\n            ...opts,\n            cause: cause\n        });\n    }\n    constructor(message, opts){\n        const cause = opts?.cause;\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore https://github.com/tc39/proposal-error-cause\n        super(message, {\n            cause\n        }), // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore override doesn't work in all environments due to \"This member cannot have an 'override' modifier because it is not declared in the base class 'Error'\"\n        _define_property(this, \"cause\", void 0), _define_property(this, \"shape\", void 0), _define_property(this, \"data\", void 0), /**\n   * Additional meta data about the error\n   * In the case of HTTP-errors, we'll have `response` and potentially `responseJSON` here\n   */ _define_property(this, \"meta\", void 0);\n        this.meta = opts?.meta;\n        this.cause = cause;\n        this.shape = opts?.result?.error;\n        this.data = opts?.result?.error.data;\n        this.name = 'TRPCClientError';\n        Object.setPrototypeOf(this, TRPCClientError.prototype);\n    }\n}\n\nexport { TRPCClientError };\n"],"names":[],"mappings":";;;AAAA;AAAA;;AAEA,SAAS,iBAAiB,GAAG,EAAE,GAAG,EAAE,KAAK;IACrC,IAAI,OAAO,KAAK;QACZ,OAAO,cAAc,CAAC,KAAK,KAAK;YAC5B,OAAO;YACP,YAAY;YACZ,cAAc;YACd,UAAU;QACd;IACJ,OAAO;QACH,GAAG,CAAC,IAAI,GAAG;IACf;IACA,OAAO;AACX;AACA,SAAS,kBAAkB,KAAK;IAC5B,OAAO,iBAAiB,mBAAmB;;;KAG1C,GAAG,iBAAiB,SAAS,MAAM,IAAI,KAAK;AACjD;AACA,SAAS,oBAAoB,GAAG;IAC5B,OAAO,CAAA,GAAA,6LAAA,CAAA,WAAQ,AAAD,EAAE,QAAQ,CAAA,GAAA,6LAAA,CAAA,WAAQ,AAAD,EAAE,GAAG,CAAC,QAAQ,KAAK,OAAO,GAAG,CAAC,QAAQ,CAAC,OAAO,KAAK,YAAY,OAAO,GAAG,CAAC,QAAQ,CAAC,UAAU,KAAK;AACrI;AACA,SAAS,2BAA2B,GAAG,EAAE,QAAQ;IAC7C,IAAI,OAAO,QAAQ,UAAU;QACzB,OAAO;IACX;IACA,IAAI,CAAA,GAAA,6LAAA,CAAA,WAAQ,AAAD,EAAE,QAAQ,OAAO,GAAG,CAAC,UAAU,KAAK,UAAU;QACrD,OAAO,GAAG,CAAC,UAAU;IACzB;IACA,OAAO;AACX;AACA,MAAM,wBAAwB;IAC1B,OAAO,KAAK,MAAM,EAAE,OAAO,CAAC,CAAC,EAAE;QAC3B,MAAM,QAAQ;QACd,IAAI,kBAAkB,QAAQ;YAC1B,IAAI,KAAK,IAAI,EAAE;gBACX,gCAAgC;gBAChC,MAAM,IAAI,GAAG;oBACT,GAAG,MAAM,IAAI;oBACb,GAAG,KAAK,IAAI;gBAChB;YACJ;YACA,OAAO;QACX;QACA,IAAI,oBAAoB,QAAQ;YAC5B,OAAO,IAAI,gBAAgB,MAAM,KAAK,CAAC,OAAO,EAAE;gBAC5C,GAAG,IAAI;gBACP,QAAQ;YACZ;QACJ;QACA,OAAO,IAAI,gBAAgB,2BAA2B,OAAO,kBAAkB;YAC3E,GAAG,IAAI;YACP,OAAO;QACX;IACJ;IACA,YAAY,OAAO,EAAE,IAAI,CAAC;QACtB,MAAM,QAAQ,MAAM;QACpB,6DAA6D;QAC7D,0DAA0D;QAC1D,KAAK,CAAC,SAAS;YACX;QACJ,IACA,oKAAoK;QACpK,iBAAiB,IAAI,EAAE,SAAS,KAAK,IAAI,iBAAiB,IAAI,EAAE,SAAS,KAAK,IAAI,iBAAiB,IAAI,EAAE,QAAQ,KAAK,IAAI;;;GAG/H,GAAG,iBAAiB,IAAI,EAAE,QAAQ,KAAK;QAClC,IAAI,CAAC,IAAI,GAAG,MAAM;QAClB,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,KAAK,GAAG,MAAM,QAAQ;QAC3B,IAAI,CAAC,IAAI,GAAG,MAAM,QAAQ,MAAM;QAChC,IAAI,CAAC,IAAI,GAAG;QACZ,OAAO,cAAc,CAAC,IAAI,EAAE,gBAAgB,SAAS;IACzD;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 127, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/internals/TRPCUntypedClient.mjs"],"sourcesContent":["import { share, observableToPromise } from '@trpc/server/observable';\nimport { createChain } from '../links/internals/createChain.mjs';\nimport { TRPCClientError } from '../TRPCClientError.mjs';\n\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nclass TRPCUntypedClient {\n    $request(opts) {\n        const chain$ = createChain({\n            links: this.links,\n            op: {\n                ...opts,\n                context: opts.context ?? {},\n                id: ++this.requestId\n            }\n        });\n        return chain$.pipe(share());\n    }\n    async requestAsPromise(opts) {\n        try {\n            const req$ = this.$request(opts);\n            const envelope = await observableToPromise(req$);\n            const data = envelope.result.data;\n            return data;\n        } catch (err) {\n            throw TRPCClientError.from(err);\n        }\n    }\n    query(path, input, opts) {\n        return this.requestAsPromise({\n            type: 'query',\n            path,\n            input,\n            context: opts?.context,\n            signal: opts?.signal\n        });\n    }\n    mutation(path, input, opts) {\n        return this.requestAsPromise({\n            type: 'mutation',\n            path,\n            input,\n            context: opts?.context,\n            signal: opts?.signal\n        });\n    }\n    subscription(path, input, opts) {\n        const observable$ = this.$request({\n            type: 'subscription',\n            path,\n            input,\n            context: opts.context,\n            signal: opts.signal\n        });\n        return observable$.subscribe({\n            next (envelope) {\n                switch(envelope.result.type){\n                    case 'state':\n                        {\n                            opts.onConnectionStateChange?.(envelope.result);\n                            break;\n                        }\n                    case 'started':\n                        {\n                            opts.onStarted?.({\n                                context: envelope.context\n                            });\n                            break;\n                        }\n                    case 'stopped':\n                        {\n                            opts.onStopped?.();\n                            break;\n                        }\n                    case 'data':\n                    case undefined:\n                        {\n                            opts.onData?.(envelope.result.data);\n                            break;\n                        }\n                }\n            },\n            error (err) {\n                opts.onError?.(err);\n            },\n            complete () {\n                opts.onComplete?.();\n            }\n        });\n    }\n    constructor(opts){\n        _define_property(this, \"links\", void 0);\n        _define_property(this, \"runtime\", void 0);\n        _define_property(this, \"requestId\", void 0);\n        this.requestId = 0;\n        this.runtime = {};\n        // Initialize the links\n        this.links = opts.links.map((link)=>link(this.runtime));\n    }\n}\n\nexport { TRPCUntypedClient };\n"],"names":[],"mappings":";;;AAAA;AAAA;AAAA;AACA;AACA;;;;AAEA,SAAS,iBAAiB,GAAG,EAAE,GAAG,EAAE,KAAK;IACrC,IAAI,OAAO,KAAK;QACZ,OAAO,cAAc,CAAC,KAAK,KAAK;YAC5B,OAAO;YACP,YAAY;YACZ,cAAc;YACd,UAAU;QACd;IACJ,OAAO;QACH,GAAG,CAAC,IAAI,GAAG;IACf;IACA,OAAO;AACX;AACA,MAAM;IACF,SAAS,IAAI,EAAE;QACX,MAAM,SAAS,CAAA,GAAA,8KAAA,CAAA,cAAW,AAAD,EAAE;YACvB,OAAO,IAAI,CAAC,KAAK;YACjB,IAAI;gBACA,GAAG,IAAI;gBACP,SAAS,KAAK,OAAO,IAAI,CAAC;gBAC1B,IAAI,EAAE,IAAI,CAAC,SAAS;YACxB;QACJ;QACA,OAAO,OAAO,IAAI,CAAC,CAAA,GAAA,oKAAA,CAAA,QAAK,AAAD;IAC3B;IACA,MAAM,iBAAiB,IAAI,EAAE;QACzB,IAAI;YACA,MAAM,OAAO,IAAI,CAAC,QAAQ,CAAC;YAC3B,MAAM,WAAW,MAAM,CAAA,GAAA,qKAAA,CAAA,sBAAmB,AAAD,EAAE;YAC3C,MAAM,OAAO,SAAS,MAAM,CAAC,IAAI;YACjC,OAAO;QACX,EAAE,OAAO,KAAK;YACV,MAAM,4JAAA,CAAA,kBAAe,CAAC,IAAI,CAAC;QAC/B;IACJ;IACA,MAAM,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE;QACrB,OAAO,IAAI,CAAC,gBAAgB,CAAC;YACzB,MAAM;YACN;YACA;YACA,SAAS,MAAM;YACf,QAAQ,MAAM;QAClB;IACJ;IACA,SAAS,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE;QACxB,OAAO,IAAI,CAAC,gBAAgB,CAAC;YACzB,MAAM;YACN;YACA;YACA,SAAS,MAAM;YACf,QAAQ,MAAM;QAClB;IACJ;IACA,aAAa,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE;QAC5B,MAAM,cAAc,IAAI,CAAC,QAAQ,CAAC;YAC9B,MAAM;YACN;YACA;YACA,SAAS,KAAK,OAAO;YACrB,QAAQ,KAAK,MAAM;QACvB;QACA,OAAO,YAAY,SAAS,CAAC;YACzB,MAAM,QAAQ;gBACV,OAAO,SAAS,MAAM,CAAC,IAAI;oBACvB,KAAK;wBACD;4BACI,KAAK,uBAAuB,GAAG,SAAS,MAAM;4BAC9C;wBACJ;oBACJ,KAAK;wBACD;4BACI,KAAK,SAAS,GAAG;gCACb,SAAS,SAAS,OAAO;4BAC7B;4BACA;wBACJ;oBACJ,KAAK;wBACD;4BACI,KAAK,SAAS;4BACd;wBACJ;oBACJ,KAAK;oBACL,KAAK;wBACD;4BACI,KAAK,MAAM,GAAG,SAAS,MAAM,CAAC,IAAI;4BAClC;wBACJ;gBACR;YACJ;YACA,OAAO,GAAG;gBACN,KAAK,OAAO,GAAG;YACnB;YACA;gBACI,KAAK,UAAU;YACnB;QACJ;IACJ;IACA,YAAY,IAAI,CAAC;QACb,iBAAiB,IAAI,EAAE,SAAS,KAAK;QACrC,iBAAiB,IAAI,EAAE,WAAW,KAAK;QACvC,iBAAiB,IAAI,EAAE,aAAa,KAAK;QACzC,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,OAAO,GAAG,CAAC;QAChB,uBAAuB;QACvB,IAAI,CAAC,KAAK,GAAG,KAAK,KAAK,CAAC,GAAG,CAAC,CAAC,OAAO,KAAK,IAAI,CAAC,OAAO;IACzD;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 252, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/createTRPCUntypedClient.mjs"],"sourcesContent":["import { TRPCUntypedClient } from './internals/TRPCUntypedClient.mjs';\n\nfunction createTRPCUntypedClient(opts) {\n    return new TRPCUntypedClient(opts);\n}\n\nexport { TRPCUntypedClient, createTRPCUntypedClient };\n"],"names":[],"mappings":";;;AAAA;;AAEA,SAAS,wBAAwB,IAAI;IACjC,OAAO,IAAI,2KAAA,CAAA,oBAAiB,CAAC;AACjC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 276, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/createTRPCClient.mjs"],"sourcesContent":["import { createRecursiveProxy, createFlatProxy } from '@trpc/server/unstable-core-do-not-import';\nimport { TRPCUntypedClient } from './internals/TRPCUntypedClient.mjs';\n\nconst untypedClientSymbol = Symbol.for('trpc_untypedClient');\nconst clientCallTypeMap = {\n    query: 'query',\n    mutate: 'mutation',\n    subscribe: 'subscription'\n};\n/** @internal */ const clientCallTypeToProcedureType = (clientCallType)=>{\n    return clientCallTypeMap[clientCallType];\n};\n/**\n * @internal\n */ function createTRPCClientProxy(client) {\n    const proxy = createRecursiveProxy(({ path, args })=>{\n        const pathCopy = [\n            ...path\n        ];\n        const procedureType = clientCallTypeToProcedureType(pathCopy.pop());\n        const fullPath = pathCopy.join('.');\n        return client[procedureType](fullPath, ...args);\n    });\n    return createFlatProxy((key)=>{\n        if (key === untypedClientSymbol) {\n            return client;\n        }\n        return proxy[key];\n    });\n}\nfunction createTRPCClient(opts) {\n    const client = new TRPCUntypedClient(opts);\n    const proxy = createTRPCClientProxy(client);\n    return proxy;\n}\n/**\n * Get an untyped client from a proxy client\n * @internal\n */ function getUntypedClient(client) {\n    return client[untypedClientSymbol];\n}\n\nexport { clientCallTypeToProcedureType, createTRPCClient, createTRPCClientProxy, getUntypedClient };\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;AACA;;;AAEA,MAAM,sBAAsB,OAAO,GAAG,CAAC;AACvC,MAAM,oBAAoB;IACtB,OAAO;IACP,QAAQ;IACR,WAAW;AACf;AACA,cAAc,GAAG,MAAM,gCAAgC,CAAC;IACpD,OAAO,iBAAiB,CAAC,eAAe;AAC5C;AACA;;CAEC,GAAG,SAAS,sBAAsB,MAAM;IACrC,MAAM,QAAQ,CAAA,GAAA,mMAAA,CAAA,uBAAoB,AAAD,EAAE,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE;QAC9C,MAAM,WAAW;eACV;SACN;QACD,MAAM,gBAAgB,8BAA8B,SAAS,GAAG;QAChE,MAAM,WAAW,SAAS,IAAI,CAAC;QAC/B,OAAO,MAAM,CAAC,cAAc,CAAC,aAAa;IAC9C;IACA,OAAO,CAAA,GAAA,mMAAA,CAAA,kBAAe,AAAD,EAAE,CAAC;QACpB,IAAI,QAAQ,qBAAqB;YAC7B,OAAO;QACX;QACA,OAAO,KAAK,CAAC,IAAI;IACrB;AACJ;AACA,SAAS,iBAAiB,IAAI;IAC1B,MAAM,SAAS,IAAI,2KAAA,CAAA,oBAAiB,CAAC;IACrC,MAAM,QAAQ,sBAAsB;IACpC,OAAO;AACX;AACA;;;CAGC,GAAG,SAAS,iBAAiB,MAAM;IAChC,OAAO,MAAM,CAAC,oBAAoB;AACtC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 332, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/getFetch.mjs"],"sourcesContent":["const isFunction = (fn)=>typeof fn === 'function';\nfunction getFetch(customFetchImpl) {\n    if (customFetchImpl) {\n        return customFetchImpl;\n    }\n    if (typeof window !== 'undefined' && isFunction(window.fetch)) {\n        return window.fetch;\n    }\n    if (typeof globalThis !== 'undefined' && isFunction(globalThis.fetch)) {\n        return globalThis.fetch;\n    }\n    throw new Error('No fetch implementation found');\n}\n\nexport { getFetch };\n"],"names":[],"mappings":";;;AAAA,MAAM,aAAa,CAAC,KAAK,OAAO,OAAO;AACvC,SAAS,SAAS,eAAe;IAC7B,IAAI,iBAAiB;QACjB,OAAO;IACX;IACA,IAAI,OAAO,WAAW,eAAe,WAAW,OAAO,KAAK,GAAG;QAC3D,OAAO,OAAO,KAAK;IACvB;IACA,IAAI,OAAO,eAAe,eAAe,WAAW,WAAW,KAAK,GAAG;QACnE,OAAO,WAAW,KAAK;IAC3B;IACA,MAAM,IAAI,MAAM;AACpB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 355, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/links/internals/contentTypes.mjs"],"sourcesContent":["function isOctetType(input) {\n    return input instanceof Uint8Array || // File extends from Blob but is only available in nodejs from v20\n    input instanceof Blob;\n}\nfunction isFormData(input) {\n    return input instanceof FormData;\n}\nfunction isNonJsonSerializable(input) {\n    return isOctetType(input) || isFormData(input);\n}\n\nexport { isFormData, isNonJsonSerializable, isOctetType };\n"],"names":[],"mappings":";;;;;AAAA,SAAS,YAAY,KAAK;IACtB,OAAO,iBAAiB,cAAc,kEAAkE;IACxG,iBAAiB;AACrB;AACA,SAAS,WAAW,KAAK;IACrB,OAAO,iBAAiB;AAC5B;AACA,SAAS,sBAAsB,KAAK;IAChC,OAAO,YAAY,UAAU,WAAW;AAC5C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 377, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/internals/dataLoader.mjs"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-non-null-assertion */ /**\n * A function that should never be called unless we messed something up.\n */ const throwFatalError = ()=>{\n    throw new Error('Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new');\n};\n/**\n * Dataloader that's very inspired by https://github.com/graphql/dataloader\n * Less configuration, no caching, and allows you to cancel requests\n * When cancelling a single fetch the whole batch will be cancelled only when _all_ items are cancelled\n */ function dataLoader(batchLoader) {\n    let pendingItems = null;\n    let dispatchTimer = null;\n    const destroyTimerAndPendingItems = ()=>{\n        clearTimeout(dispatchTimer);\n        dispatchTimer = null;\n        pendingItems = null;\n    };\n    /**\n   * Iterate through the items and split them into groups based on the `batchLoader`'s validate function\n   */ function groupItems(items) {\n        const groupedItems = [\n            []\n        ];\n        let index = 0;\n        while(true){\n            const item = items[index];\n            if (!item) {\n                break;\n            }\n            const lastGroup = groupedItems[groupedItems.length - 1];\n            if (item.aborted) {\n                // Item was aborted before it was dispatched\n                item.reject?.(new Error('Aborted'));\n                index++;\n                continue;\n            }\n            const isValid = batchLoader.validate(lastGroup.concat(item).map((it)=>it.key));\n            if (isValid) {\n                lastGroup.push(item);\n                index++;\n                continue;\n            }\n            if (lastGroup.length === 0) {\n                item.reject?.(new Error('Input is too big for a single dispatch'));\n                index++;\n                continue;\n            }\n            // Create new group, next iteration will try to add the item to that\n            groupedItems.push([]);\n        }\n        return groupedItems;\n    }\n    function dispatch() {\n        const groupedItems = groupItems(pendingItems);\n        destroyTimerAndPendingItems();\n        // Create batches for each group of items\n        for (const items of groupedItems){\n            if (!items.length) {\n                continue;\n            }\n            const batch = {\n                items\n            };\n            for (const item of items){\n                item.batch = batch;\n            }\n            const promise = batchLoader.fetch(batch.items.map((_item)=>_item.key));\n            promise.then(async (result)=>{\n                await Promise.all(result.map(async (valueOrPromise, index)=>{\n                    const item = batch.items[index];\n                    try {\n                        const value = await Promise.resolve(valueOrPromise);\n                        item.resolve?.(value);\n                    } catch (cause) {\n                        item.reject?.(cause);\n                    }\n                    item.batch = null;\n                    item.reject = null;\n                    item.resolve = null;\n                }));\n                for (const item of batch.items){\n                    item.reject?.(new Error('Missing result'));\n                    item.batch = null;\n                }\n            }).catch((cause)=>{\n                for (const item of batch.items){\n                    item.reject?.(cause);\n                    item.batch = null;\n                }\n            });\n        }\n    }\n    function load(key) {\n        const item = {\n            aborted: false,\n            key,\n            batch: null,\n            resolve: throwFatalError,\n            reject: throwFatalError\n        };\n        const promise = new Promise((resolve, reject)=>{\n            item.reject = reject;\n            item.resolve = resolve;\n            if (!pendingItems) {\n                pendingItems = [];\n            }\n            pendingItems.push(item);\n        });\n        if (!dispatchTimer) {\n            dispatchTimer = setTimeout(dispatch);\n        }\n        return promise;\n    }\n    return {\n        load\n    };\n}\n\nexport { dataLoader };\n"],"names":[],"mappings":"AAAA,2DAA2D,GAAG;;CAE7D;;;AAAG,MAAM,kBAAkB;IACxB,MAAM,IAAI,MAAM;AACpB;AACA;;;;CAIC,GAAG,SAAS,WAAW,WAAW;IAC/B,IAAI,eAAe;IACnB,IAAI,gBAAgB;IACpB,MAAM,8BAA8B;QAChC,aAAa;QACb,gBAAgB;QAChB,eAAe;IACnB;IACA;;GAED,GAAG,SAAS,WAAW,KAAK;QACvB,MAAM,eAAe;YACjB,EAAE;SACL;QACD,IAAI,QAAQ;QACZ,MAAM,KAAK;YACP,MAAM,OAAO,KAAK,CAAC,MAAM;YACzB,IAAI,CAAC,MAAM;gBACP;YACJ;YACA,MAAM,YAAY,YAAY,CAAC,aAAa,MAAM,GAAG,EAAE;YACvD,IAAI,KAAK,OAAO,EAAE;gBACd,4CAA4C;gBAC5C,KAAK,MAAM,GAAG,IAAI,MAAM;gBACxB;gBACA;YACJ;YACA,MAAM,UAAU,YAAY,QAAQ,CAAC,UAAU,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,GAAG;YAC5E,IAAI,SAAS;gBACT,UAAU,IAAI,CAAC;gBACf;gBACA;YACJ;YACA,IAAI,UAAU,MAAM,KAAK,GAAG;gBACxB,KAAK,MAAM,GAAG,IAAI,MAAM;gBACxB;gBACA;YACJ;YACA,oEAAoE;YACpE,aAAa,IAAI,CAAC,EAAE;QACxB;QACA,OAAO;IACX;IACA,SAAS;QACL,MAAM,eAAe,WAAW;QAChC;QACA,yCAAyC;QACzC,KAAK,MAAM,SAAS,aAAa;YAC7B,IAAI,CAAC,MAAM,MAAM,EAAE;gBACf;YACJ;YACA,MAAM,QAAQ;gBACV;YACJ;YACA,KAAK,MAAM,QAAQ,MAAM;gBACrB,KAAK,KAAK,GAAG;YACjB;YACA,MAAM,UAAU,YAAY,KAAK,CAAC,MAAM,KAAK,CAAC,GAAG,CAAC,CAAC,QAAQ,MAAM,GAAG;YACpE,QAAQ,IAAI,CAAC,OAAO;gBAChB,MAAM,QAAQ,GAAG,CAAC,OAAO,GAAG,CAAC,OAAO,gBAAgB;oBAChD,MAAM,OAAO,MAAM,KAAK,CAAC,MAAM;oBAC/B,IAAI;wBACA,MAAM,QAAQ,MAAM,QAAQ,OAAO,CAAC;wBACpC,KAAK,OAAO,GAAG;oBACnB,EAAE,OAAO,OAAO;wBACZ,KAAK,MAAM,GAAG;oBAClB;oBACA,KAAK,KAAK,GAAG;oBACb,KAAK,MAAM,GAAG;oBACd,KAAK,OAAO,GAAG;gBACnB;gBACA,KAAK,MAAM,QAAQ,MAAM,KAAK,CAAC;oBAC3B,KAAK,MAAM,GAAG,IAAI,MAAM;oBACxB,KAAK,KAAK,GAAG;gBACjB;YACJ,GAAG,KAAK,CAAC,CAAC;gBACN,KAAK,MAAM,QAAQ,MAAM,KAAK,CAAC;oBAC3B,KAAK,MAAM,GAAG;oBACd,KAAK,KAAK,GAAG;gBACjB;YACJ;QACJ;IACJ;IACA,SAAS,KAAK,GAAG;QACb,MAAM,OAAO;YACT,SAAS;YACT;YACA,OAAO;YACP,SAAS;YACT,QAAQ;QACZ;QACA,MAAM,UAAU,IAAI,QAAQ,CAAC,SAAS;YAClC,KAAK,MAAM,GAAG;YACd,KAAK,OAAO,GAAG;YACf,IAAI,CAAC,cAAc;gBACf,eAAe,EAAE;YACrB;YACA,aAAa,IAAI,CAAC;QACtB;QACA,IAAI,CAAC,eAAe;YAChB,gBAAgB,WAAW;QAC/B;QACA,OAAO;IACX;IACA,OAAO;QACH;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 504, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/internals/signals.mjs"],"sourcesContent":["/**\n * Like `Promise.all()` but for abort signals\n * - When all signals have been aborted, the merged signal will be aborted\n * - If one signal is `null`, no signal will be aborted\n */ function allAbortSignals(...signals) {\n    const ac = new AbortController();\n    const count = signals.length;\n    let abortedCount = 0;\n    const onAbort = ()=>{\n        if (++abortedCount === count) {\n            ac.abort();\n        }\n    };\n    for (const signal of signals){\n        if (signal?.aborted) {\n            onAbort();\n        } else {\n            signal?.addEventListener('abort', onAbort, {\n                once: true\n            });\n        }\n    }\n    return ac.signal;\n}\n/**\n * Like `Promise.race` but for abort signals\n *\n * Basically, a ponyfill for\n * [`AbortSignal.any`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/any_static).\n */ function raceAbortSignals(...signals) {\n    const ac = new AbortController();\n    for (const signal of signals){\n        if (signal?.aborted) {\n            ac.abort();\n        } else {\n            signal?.addEventListener('abort', ()=>ac.abort(), {\n                once: true\n            });\n        }\n    }\n    return ac.signal;\n}\n\nexport { allAbortSignals, raceAbortSignals };\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;AAAG,SAAS,gBAAgB,GAAG,OAAO;IACnC,MAAM,KAAK,IAAI;IACf,MAAM,QAAQ,QAAQ,MAAM;IAC5B,IAAI,eAAe;IACnB,MAAM,UAAU;QACZ,IAAI,EAAE,iBAAiB,OAAO;YAC1B,GAAG,KAAK;QACZ;IACJ;IACA,KAAK,MAAM,UAAU,QAAQ;QACzB,IAAI,QAAQ,SAAS;YACjB;QACJ,OAAO;YACH,QAAQ,iBAAiB,SAAS,SAAS;gBACvC,MAAM;YACV;QACJ;IACJ;IACA,OAAO,GAAG,MAAM;AACpB;AACA;;;;;CAKC,GAAG,SAAS,iBAAiB,GAAG,OAAO;IACpC,MAAM,KAAK,IAAI;IACf,KAAK,MAAM,UAAU,QAAQ;QACzB,IAAI,QAAQ,SAAS;YACjB,GAAG,KAAK;QACZ,OAAO;YACH,QAAQ,iBAAiB,SAAS,IAAI,GAAG,KAAK,IAAI;gBAC9C,MAAM;YACV;QACJ;IACJ;IACA,OAAO,GAAG,MAAM;AACpB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 557, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/internals/transformer.mjs"],"sourcesContent":["/**\n * @internal\n */ /**\n * @internal\n */ function getTransformer(transformer) {\n    const _transformer = transformer;\n    if (!_transformer) {\n        return {\n            input: {\n                serialize: (data)=>data,\n                deserialize: (data)=>data\n            },\n            output: {\n                serialize: (data)=>data,\n                deserialize: (data)=>data\n            }\n        };\n    }\n    if ('input' in _transformer) {\n        return _transformer;\n    }\n    return {\n        input: _transformer,\n        output: _transformer\n    };\n}\n\nexport { getTransformer };\n"],"names":[],"mappings":"AAAA;;CAEC,GAAG;;CAEH;;;AAAG,SAAS,eAAe,WAAW;IACnC,MAAM,eAAe;IACrB,IAAI,CAAC,cAAc;QACf,OAAO;YACH,OAAO;gBACH,WAAW,CAAC,OAAO;gBACnB,aAAa,CAAC,OAAO;YACzB;YACA,QAAQ;gBACJ,WAAW,CAAC,OAAO;gBACnB,aAAa,CAAC,OAAO;YACzB;QACJ;IACJ;IACA,IAAI,WAAW,cAAc;QACzB,OAAO;IACX;IACA,OAAO;QACH,OAAO;QACP,QAAQ;IACZ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 593, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/links/internals/httpUtils.mjs"],"sourcesContent":["import { getFetch } from '../../getFetch.mjs';\nimport { getTransformer } from '../../internals/transformer.mjs';\n\nfunction resolveHTTPLinkOptions(opts) {\n    return {\n        url: opts.url.toString(),\n        fetch: opts.fetch,\n        transformer: getTransformer(opts.transformer),\n        methodOverride: opts.methodOverride\n    };\n}\n// https://github.com/trpc/trpc/pull/669\nfunction arrayToDict(array) {\n    const dict = {};\n    for(let index = 0; index < array.length; index++){\n        const element = array[index];\n        dict[index] = element;\n    }\n    return dict;\n}\nconst METHOD = {\n    query: 'GET',\n    mutation: 'POST',\n    subscription: 'PATCH'\n};\nfunction getInput(opts) {\n    return 'input' in opts ? opts.transformer.input.serialize(opts.input) : arrayToDict(opts.inputs.map((_input)=>opts.transformer.input.serialize(_input)));\n}\nconst getUrl = (opts)=>{\n    const parts = opts.url.split('?');\n    const base = parts[0].replace(/\\/$/, ''); // Remove any trailing slashes\n    let url = base + '/' + opts.path;\n    const queryParts = [];\n    if (parts[1]) {\n        queryParts.push(parts[1]);\n    }\n    if ('inputs' in opts) {\n        queryParts.push('batch=1');\n    }\n    if (opts.type === 'query' || opts.type === 'subscription') {\n        const input = getInput(opts);\n        if (input !== undefined && opts.methodOverride !== 'POST') {\n            queryParts.push(`input=${encodeURIComponent(JSON.stringify(input))}`);\n        }\n    }\n    if (queryParts.length) {\n        url += '?' + queryParts.join('&');\n    }\n    return url;\n};\nconst getBody = (opts)=>{\n    if (opts.type === 'query' && opts.methodOverride !== 'POST') {\n        return undefined;\n    }\n    const input = getInput(opts);\n    return input !== undefined ? JSON.stringify(input) : undefined;\n};\nconst jsonHttpRequester = (opts)=>{\n    return httpRequest({\n        ...opts,\n        contentTypeHeader: 'application/json',\n        getUrl,\n        getBody\n    });\n};\n/**\n * Polyfill for DOMException with AbortError name\n */ class AbortError extends Error {\n    constructor(){\n        const name = 'AbortError';\n        super(name);\n        this.name = name;\n        this.message = name;\n    }\n}\n/**\n * Polyfill for `signal.throwIfAborted()`\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/throwIfAborted\n */ const throwIfAborted = (signal)=>{\n    if (!signal?.aborted) {\n        return;\n    }\n    // If available, use the native implementation\n    signal.throwIfAborted?.();\n    // If we have `DOMException`, use it\n    if (typeof DOMException !== 'undefined') {\n        throw new DOMException('AbortError', 'AbortError');\n    }\n    // Otherwise, use our own implementation\n    throw new AbortError();\n};\nasync function fetchHTTPResponse(opts) {\n    throwIfAborted(opts.signal);\n    const url = opts.getUrl(opts);\n    const body = opts.getBody(opts);\n    const { type } = opts;\n    const resolvedHeaders = await (async ()=>{\n        const heads = await opts.headers();\n        if (Symbol.iterator in heads) {\n            return Object.fromEntries(heads);\n        }\n        return heads;\n    })();\n    const headers = {\n        ...opts.contentTypeHeader ? {\n            'content-type': opts.contentTypeHeader\n        } : {},\n        ...opts.trpcAcceptHeader ? {\n            'trpc-accept': opts.trpcAcceptHeader\n        } : undefined,\n        ...resolvedHeaders\n    };\n    return getFetch(opts.fetch)(url, {\n        method: opts.methodOverride ?? METHOD[type],\n        signal: opts.signal,\n        body,\n        headers\n    });\n}\nasync function httpRequest(opts) {\n    const meta = {};\n    const res = await fetchHTTPResponse(opts);\n    meta.response = res;\n    const json = await res.json();\n    meta.responseJSON = json;\n    return {\n        json: json,\n        meta\n    };\n}\n\nexport { fetchHTTPResponse, getBody, getInput, getUrl, httpRequest, jsonHttpRequester, resolveHTTPLinkOptions };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 741, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/links/httpBatchLink.mjs"],"sourcesContent":["import { observable } from '@trpc/server/observable';\nimport { transformResult } from '@trpc/server/unstable-core-do-not-import';\nimport { dataLoader } from '../internals/dataLoader.mjs';\nimport { allAbortSignals } from '../internals/signals.mjs';\nimport { TRPCClientError } from '../TRPCClientError.mjs';\nimport { resolveHTTPLinkOptions, jsonHttpRequester, getUrl } from './internals/httpUtils.mjs';\n\n/**\n * @see https://trpc.io/docs/client/links/httpBatchLink\n */ function httpBatchLink(opts) {\n    const resolvedOpts = resolveHTTPLinkOptions(opts);\n    const maxURLLength = opts.maxURLLength ?? Infinity;\n    const maxItems = opts.maxItems ?? Infinity;\n    return ()=>{\n        const batchLoader = (type)=>{\n            return {\n                validate (batchOps) {\n                    if (maxURLLength === Infinity && maxItems === Infinity) {\n                        // escape hatch for quick calcs\n                        return true;\n                    }\n                    if (batchOps.length > maxItems) {\n                        return false;\n                    }\n                    const path = batchOps.map((op)=>op.path).join(',');\n                    const inputs = batchOps.map((op)=>op.input);\n                    const url = getUrl({\n                        ...resolvedOpts,\n                        type,\n                        path,\n                        inputs,\n                        signal: null\n                    });\n                    return url.length <= maxURLLength;\n                },\n                async fetch (batchOps) {\n                    const path = batchOps.map((op)=>op.path).join(',');\n                    const inputs = batchOps.map((op)=>op.input);\n                    const signal = allAbortSignals(...batchOps.map((op)=>op.signal));\n                    const res = await jsonHttpRequester({\n                        ...resolvedOpts,\n                        path,\n                        inputs,\n                        type,\n                        headers () {\n                            if (!opts.headers) {\n                                return {};\n                            }\n                            if (typeof opts.headers === 'function') {\n                                return opts.headers({\n                                    opList: batchOps\n                                });\n                            }\n                            return opts.headers;\n                        },\n                        signal\n                    });\n                    const resJSON = Array.isArray(res.json) ? res.json : batchOps.map(()=>res.json);\n                    const result = resJSON.map((item)=>({\n                            meta: res.meta,\n                            json: item\n                        }));\n                    return result;\n                }\n            };\n        };\n        const query = dataLoader(batchLoader('query'));\n        const mutation = dataLoader(batchLoader('mutation'));\n        const loaders = {\n            query,\n            mutation\n        };\n        return ({ op })=>{\n            return observable((observer)=>{\n                /* istanbul ignore if -- @preserve */ if (op.type === 'subscription') {\n                    throw new Error('Subscriptions are unsupported by `httpLink` - use `httpSubscriptionLink` or `wsLink`');\n                }\n                const loader = loaders[op.type];\n                const promise = loader.load(op);\n                let _res = undefined;\n                promise.then((res)=>{\n                    _res = res;\n                    const transformed = transformResult(res.json, resolvedOpts.transformer.output);\n                    if (!transformed.ok) {\n                        observer.error(TRPCClientError.from(transformed.error, {\n                            meta: res.meta\n                        }));\n                        return;\n                    }\n                    observer.next({\n                        context: res.meta,\n                        result: transformed.result\n                    });\n                    observer.complete();\n                }).catch((err)=>{\n                    observer.error(TRPCClientError.from(err, {\n                        meta: _res?.meta\n                    }));\n                });\n                return ()=>{\n                // noop\n                };\n            });\n        };\n    };\n}\n\nexport { httpBatchLink };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 864, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/links/httpBatchStreamLink.mjs"],"sourcesContent":["import { observable } from '@trpc/server/observable';\nimport { jsonlStreamConsumer } from '@trpc/server/unstable-core-do-not-import';\nimport { dataLoader } from '../internals/dataLoader.mjs';\nimport { allAbortSignals, raceAbortSignals } from '../internals/signals.mjs';\nimport { TRPCClientError } from '../TRPCClientError.mjs';\nimport { resolveHTTPLinkOptions, fetchHTTPResponse, getBody, getUrl } from './internals/httpUtils.mjs';\n\n/**\n * @see https://trpc.io/docs/client/links/httpBatchStreamLink\n */ function httpBatchStreamLink(opts) {\n    const resolvedOpts = resolveHTTPLinkOptions(opts);\n    const maxURLLength = opts.maxURLLength ?? Infinity;\n    const maxItems = opts.maxItems ?? Infinity;\n    return ()=>{\n        const batchLoader = (type)=>{\n            return {\n                validate (batchOps) {\n                    if (maxURLLength === Infinity && maxItems === Infinity) {\n                        // escape hatch for quick calcs\n                        return true;\n                    }\n                    if (batchOps.length > maxItems) {\n                        return false;\n                    }\n                    const path = batchOps.map((op)=>op.path).join(',');\n                    const inputs = batchOps.map((op)=>op.input);\n                    const url = getUrl({\n                        ...resolvedOpts,\n                        type,\n                        path,\n                        inputs,\n                        signal: null\n                    });\n                    return url.length <= maxURLLength;\n                },\n                async fetch (batchOps) {\n                    const path = batchOps.map((op)=>op.path).join(',');\n                    const inputs = batchOps.map((op)=>op.input);\n                    const batchSignals = allAbortSignals(...batchOps.map((op)=>op.signal));\n                    const abortController = new AbortController();\n                    const responsePromise = fetchHTTPResponse({\n                        ...resolvedOpts,\n                        signal: raceAbortSignals(batchSignals, abortController.signal),\n                        type,\n                        contentTypeHeader: 'application/json',\n                        trpcAcceptHeader: 'application/jsonl',\n                        getUrl,\n                        getBody,\n                        inputs,\n                        path,\n                        headers () {\n                            if (!opts.headers) {\n                                return {};\n                            }\n                            if (typeof opts.headers === 'function') {\n                                return opts.headers({\n                                    opList: batchOps\n                                });\n                            }\n                            return opts.headers;\n                        }\n                    });\n                    const res = await responsePromise;\n                    const [head] = await jsonlStreamConsumer({\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        from: res.body,\n                        deserialize: resolvedOpts.transformer.output.deserialize,\n                        // onError: console.error,\n                        formatError (opts) {\n                            const error = opts.error;\n                            return TRPCClientError.from({\n                                error\n                            });\n                        },\n                        abortController\n                    });\n                    const promises = Object.keys(batchOps).map(async (key)=>{\n                        let json = await Promise.resolve(head[key]);\n                        if ('result' in json) {\n                            /**\n                 * Not very pretty, but we need to unwrap nested data as promises\n                 * Our stream producer will only resolve top-level async values or async values that are directly nested in another async value\n                 */ const result = await Promise.resolve(json.result);\n                            json = {\n                                result: {\n                                    data: await Promise.resolve(result.data)\n                                }\n                            };\n                        }\n                        return {\n                            json,\n                            meta: {\n                                response: res\n                            }\n                        };\n                    });\n                    return promises;\n                }\n            };\n        };\n        const query = dataLoader(batchLoader('query'));\n        const mutation = dataLoader(batchLoader('mutation'));\n        const loaders = {\n            query,\n            mutation\n        };\n        return ({ op })=>{\n            return observable((observer)=>{\n                /* istanbul ignore if -- @preserve */ if (op.type === 'subscription') {\n                    throw new Error('Subscriptions are unsupported by `httpBatchStreamLink` - use `httpSubscriptionLink` or `wsLink`');\n                }\n                const loader = loaders[op.type];\n                const promise = loader.load(op);\n                let _res = undefined;\n                promise.then((res)=>{\n                    _res = res;\n                    if ('error' in res.json) {\n                        observer.error(TRPCClientError.from(res.json, {\n                            meta: res.meta\n                        }));\n                        return;\n                    } else if ('result' in res.json) {\n                        observer.next({\n                            context: res.meta,\n                            result: res.json.result\n                        });\n                        observer.complete();\n                        return;\n                    }\n                    observer.complete();\n                }).catch((err)=>{\n                    observer.error(TRPCClientError.from(err, {\n                        meta: _res?.meta\n                    }));\n                });\n                return ()=>{\n                // noop\n                };\n            });\n        };\n    };\n}\n/**\n * @deprecated use {@link httpBatchStreamLink} instead\n */ const unstable_httpBatchStreamLink = httpBatchStreamLink;\n\nexport { httpBatchStreamLink, unstable_httpBatchStreamLink };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1027, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/links/httpLink.mjs"],"sourcesContent":["import { observable } from '@trpc/server/observable';\nimport { transformResult } from '@trpc/server/unstable-core-do-not-import';\nimport { TRPCClientError } from '../TRPCClientError.mjs';\nimport { resolveHTTPLinkOptions, httpRequest, jsonHttpRequester, getUrl } from './internals/httpUtils.mjs';\nimport { isFormData, isOctetType } from './internals/contentTypes.mjs';\n\nconst universalRequester = (opts)=>{\n    if ('input' in opts) {\n        const { input } = opts;\n        if (isFormData(input)) {\n            if (opts.type !== 'mutation' && opts.methodOverride !== 'POST') {\n                throw new Error('FormData is only supported for mutations');\n            }\n            return httpRequest({\n                ...opts,\n                // The browser will set this automatically and include the boundary= in it\n                contentTypeHeader: undefined,\n                getUrl,\n                getBody: ()=>input\n            });\n        }\n        if (isOctetType(input)) {\n            if (opts.type !== 'mutation' && opts.methodOverride !== 'POST') {\n                throw new Error('Octet type input is only supported for mutations');\n            }\n            return httpRequest({\n                ...opts,\n                contentTypeHeader: 'application/octet-stream',\n                getUrl,\n                getBody: ()=>input\n            });\n        }\n    }\n    return jsonHttpRequester(opts);\n};\n/**\n * @see https://trpc.io/docs/client/links/httpLink\n */ function httpLink(opts) {\n    const resolvedOpts = resolveHTTPLinkOptions(opts);\n    return ()=>{\n        return ({ op })=>{\n            return observable((observer)=>{\n                const { path, input, type } = op;\n                /* istanbul ignore if -- @preserve */ if (type === 'subscription') {\n                    throw new Error('Subscriptions are unsupported by `httpLink` - use `httpSubscriptionLink` or `wsLink`');\n                }\n                const request = universalRequester({\n                    ...resolvedOpts,\n                    type,\n                    path,\n                    input,\n                    signal: op.signal,\n                    headers () {\n                        if (!opts.headers) {\n                            return {};\n                        }\n                        if (typeof opts.headers === 'function') {\n                            return opts.headers({\n                                op\n                            });\n                        }\n                        return opts.headers;\n                    }\n                });\n                let meta = undefined;\n                request.then((res)=>{\n                    meta = res.meta;\n                    const transformed = transformResult(res.json, resolvedOpts.transformer.output);\n                    if (!transformed.ok) {\n                        observer.error(TRPCClientError.from(transformed.error, {\n                            meta\n                        }));\n                        return;\n                    }\n                    observer.next({\n                        context: res.meta,\n                        result: transformed.result\n                    });\n                    observer.complete();\n                }).catch((cause)=>{\n                    observer.error(TRPCClientError.from(cause, {\n                        meta\n                    }));\n                });\n                return ()=>{\n                // noop\n                };\n            });\n        };\n    };\n}\n\nexport { httpLink };\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;;;;;;AAEA,MAAM,qBAAqB,CAAC;IACxB,IAAI,WAAW,MAAM;QACjB,MAAM,EAAE,KAAK,EAAE,GAAG;QAClB,IAAI,CAAA,GAAA,+KAAA,CAAA,aAAU,AAAD,EAAE,QAAQ;YACnB,IAAI,KAAK,IAAI,KAAK,cAAc,KAAK,cAAc,KAAK,QAAQ;gBAC5D,MAAM,IAAI,MAAM;YACpB;YACA,OAAO,CAAA,GAAA,4KAAA,CAAA,cAAW,AAAD,EAAE;gBACf,GAAG,IAAI;gBACP,0EAA0E;gBAC1E,mBAAmB;gBACnB,QAAA,4KAAA,CAAA,SAAM;gBACN,SAAS,IAAI;YACjB;QACJ;QACA,IAAI,CAAA,GAAA,+KAAA,CAAA,cAAW,AAAD,EAAE,QAAQ;YACpB,IAAI,KAAK,IAAI,KAAK,cAAc,KAAK,cAAc,KAAK,QAAQ;gBAC5D,MAAM,IAAI,MAAM;YACpB;YACA,OAAO,CAAA,GAAA,4KAAA,CAAA,cAAW,AAAD,EAAE;gBACf,GAAG,IAAI;gBACP,mBAAmB;gBACnB,QAAA,4KAAA,CAAA,SAAM;gBACN,SAAS,IAAI;YACjB;QACJ;IACJ;IACA,OAAO,CAAA,GAAA,4KAAA,CAAA,oBAAiB,AAAD,EAAE;AAC7B;AACA;;CAEC,GAAG,SAAS,SAAS,IAAI;IACtB,MAAM,eAAe,CAAA,GAAA,4KAAA,CAAA,yBAAsB,AAAD,EAAE;IAC5C,OAAO;QACH,OAAO,CAAC,EAAE,EAAE,EAAE;YACV,OAAO,CAAA,GAAA,qKAAA,CAAA,aAAU,AAAD,EAAE,CAAC;gBACf,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG;gBAC9B,mCAAmC,GAAG,IAAI,SAAS,gBAAgB;oBAC/D,MAAM,IAAI,MAAM;gBACpB;gBACA,MAAM,UAAU,mBAAmB;oBAC/B,GAAG,YAAY;oBACf;oBACA;oBACA;oBACA,QAAQ,GAAG,MAAM;oBACjB;wBACI,IAAI,CAAC,KAAK,OAAO,EAAE;4BACf,OAAO,CAAC;wBACZ;wBACA,IAAI,OAAO,KAAK,OAAO,KAAK,YAAY;4BACpC,OAAO,KAAK,OAAO,CAAC;gCAChB;4BACJ;wBACJ;wBACA,OAAO,KAAK,OAAO;oBACvB;gBACJ;gBACA,IAAI,OAAO;gBACX,QAAQ,IAAI,CAAC,CAAC;oBACV,OAAO,IAAI,IAAI;oBACf,MAAM,cAAc,CAAA,GAAA,mMAAA,CAAA,kBAAe,AAAD,EAAE,IAAI,IAAI,EAAE,aAAa,WAAW,CAAC,MAAM;oBAC7E,IAAI,CAAC,YAAY,EAAE,EAAE;wBACjB,SAAS,KAAK,CAAC,4JAAA,CAAA,kBAAe,CAAC,IAAI,CAAC,YAAY,KAAK,EAAE;4BACnD;wBACJ;wBACA;oBACJ;oBACA,SAAS,IAAI,CAAC;wBACV,SAAS,IAAI,IAAI;wBACjB,QAAQ,YAAY,MAAM;oBAC9B;oBACA,SAAS,QAAQ;gBACrB,GAAG,KAAK,CAAC,CAAC;oBACN,SAAS,KAAK,CAAC,4JAAA,CAAA,kBAAe,CAAC,IAAI,CAAC,OAAO;wBACvC;oBACJ;gBACJ;gBACA,OAAO;gBACP,OAAO;gBACP;YACJ;QACJ;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1134, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/links/loggerLink.mjs"],"sourcesContent":["import { observable, tap } from '@trpc/server/observable';\n\n/// <reference lib=\"dom.iterable\" />\n// `dom.iterable` types are explicitly required for extracting `FormData` values,\n// as all implementations of `Symbol.iterable` are separated from the main `dom` types.\n// Using triple-slash directive makes sure that it will be available,\n// even if end-user `tsconfig.json` omits it in the `lib` array.\nfunction isFormData(value) {\n    if (typeof FormData === 'undefined') {\n        // FormData is not supported\n        return false;\n    }\n    return value instanceof FormData;\n}\nconst palettes = {\n    css: {\n        query: [\n            '72e3ff',\n            '3fb0d8'\n        ],\n        mutation: [\n            'c5a3fc',\n            '904dfc'\n        ],\n        subscription: [\n            'ff49e1',\n            'd83fbe'\n        ]\n    },\n    ansi: {\n        regular: {\n            // Cyan background, black and white text respectively\n            query: [\n                '\\x1b[30;46m',\n                '\\x1b[97;46m'\n            ],\n            // Magenta background, black and white text respectively\n            mutation: [\n                '\\x1b[30;45m',\n                '\\x1b[97;45m'\n            ],\n            // Green background, black and white text respectively\n            subscription: [\n                '\\x1b[30;42m',\n                '\\x1b[97;42m'\n            ]\n        },\n        bold: {\n            query: [\n                '\\x1b[1;30;46m',\n                '\\x1b[1;97;46m'\n            ],\n            mutation: [\n                '\\x1b[1;30;45m',\n                '\\x1b[1;97;45m'\n            ],\n            subscription: [\n                '\\x1b[1;30;42m',\n                '\\x1b[1;97;42m'\n            ]\n        }\n    }\n};\nfunction constructPartsAndArgs(opts) {\n    const { direction, type, withContext, path, id, input } = opts;\n    const parts = [];\n    const args = [];\n    if (opts.colorMode === 'none') {\n        parts.push(direction === 'up' ? '>>' : '<<', type, `#${id}`, path);\n    } else if (opts.colorMode === 'ansi') {\n        const [lightRegular, darkRegular] = palettes.ansi.regular[type];\n        const [lightBold, darkBold] = palettes.ansi.bold[type];\n        const reset = '\\x1b[0m';\n        parts.push(direction === 'up' ? lightRegular : darkRegular, direction === 'up' ? '>>' : '<<', type, direction === 'up' ? lightBold : darkBold, `#${id}`, path, reset);\n    } else {\n        // css color mode\n        const [light, dark] = palettes.css[type];\n        const css = `\n    background-color: #${direction === 'up' ? light : dark};\n    color: ${direction === 'up' ? 'black' : 'white'};\n    padding: 2px;\n  `;\n        parts.push('%c', direction === 'up' ? '>>' : '<<', type, `#${id}`, `%c${path}%c`, '%O');\n        args.push(css, `${css}; font-weight: bold;`, `${css}; font-weight: normal;`);\n    }\n    if (direction === 'up') {\n        args.push(withContext ? {\n            input,\n            context: opts.context\n        } : {\n            input\n        });\n    } else {\n        args.push({\n            input,\n            result: opts.result,\n            elapsedMs: opts.elapsedMs,\n            ...withContext && {\n                context: opts.context\n            }\n        });\n    }\n    return {\n        parts,\n        args\n    };\n}\n// maybe this should be moved to it's own package\nconst defaultLogger = ({ c = console, colorMode = 'css', withContext })=>(props)=>{\n        const rawInput = props.input;\n        const input = isFormData(rawInput) ? Object.fromEntries(rawInput) : rawInput;\n        const { parts, args } = constructPartsAndArgs({\n            ...props,\n            colorMode,\n            input,\n            withContext\n        });\n        const fn = props.direction === 'down' && props.result && (props.result instanceof Error || 'error' in props.result.result && props.result.result.error) ? 'error' : 'log';\n        c[fn].apply(null, [\n            parts.join(' ')\n        ].concat(args));\n    };\n/**\n * @see https://trpc.io/docs/v11/client/links/loggerLink\n */ function loggerLink(opts = {}) {\n    const { enabled = ()=>true } = opts;\n    const colorMode = opts.colorMode ?? (typeof window === 'undefined' ? 'ansi' : 'css');\n    const withContext = opts.withContext ?? colorMode === 'css';\n    const { logger = defaultLogger({\n        c: opts.console,\n        colorMode,\n        withContext\n    }) } = opts;\n    return ()=>{\n        return ({ op, next })=>{\n            return observable((observer)=>{\n                // ->\n                if (enabled({\n                    ...op,\n                    direction: 'up'\n                })) {\n                    logger({\n                        ...op,\n                        direction: 'up'\n                    });\n                }\n                const requestStartTime = Date.now();\n                function logResult(result) {\n                    const elapsedMs = Date.now() - requestStartTime;\n                    if (enabled({\n                        ...op,\n                        direction: 'down',\n                        result\n                    })) {\n                        logger({\n                            ...op,\n                            direction: 'down',\n                            elapsedMs,\n                            result\n                        });\n                    }\n                }\n                return next(op).pipe(tap({\n                    next (result) {\n                        logResult(result);\n                    },\n                    error (result) {\n                        logResult(result);\n                    }\n                })).subscribe(observer);\n            });\n        };\n    };\n}\n\nexport { loggerLink };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1320, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/links/splitLink.mjs"],"sourcesContent":["import { observable } from '@trpc/server/observable';\nimport { createChain } from './internals/createChain.mjs';\n\nfunction asArray(value) {\n    return Array.isArray(value) ? value : [\n        value\n    ];\n}\nfunction splitLink(opts) {\n    return (runtime)=>{\n        const yes = asArray(opts.true).map((link)=>link(runtime));\n        const no = asArray(opts.false).map((link)=>link(runtime));\n        return (props)=>{\n            return observable((observer)=>{\n                const links = opts.condition(props.op) ? yes : no;\n                return createChain({\n                    op: props.op,\n                    links\n                }).subscribe(observer);\n            });\n        };\n    };\n}\n\nexport { splitLink };\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;;;AAEA,SAAS,QAAQ,KAAK;IAClB,OAAO,MAAM,OAAO,CAAC,SAAS,QAAQ;QAClC;KACH;AACL;AACA,SAAS,UAAU,IAAI;IACnB,OAAO,CAAC;QACJ,MAAM,MAAM,QAAQ,KAAK,IAAI,EAAE,GAAG,CAAC,CAAC,OAAO,KAAK;QAChD,MAAM,KAAK,QAAQ,KAAK,KAAK,EAAE,GAAG,CAAC,CAAC,OAAO,KAAK;QAChD,OAAO,CAAC;YACJ,OAAO,CAAA,GAAA,qKAAA,CAAA,aAAU,AAAD,EAAE,CAAC;gBACf,MAAM,QAAQ,KAAK,SAAS,CAAC,MAAM,EAAE,IAAI,MAAM;gBAC/C,OAAO,CAAA,GAAA,8KAAA,CAAA,cAAW,AAAD,EAAE;oBACf,IAAI,MAAM,EAAE;oBACZ;gBACJ,GAAG,SAAS,CAAC;YACjB;QACJ;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1355, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/links/wsLink/wsClient/options.mjs"],"sourcesContent":["const lazyDefaults = {\n    enabled: false,\n    closeMs: 0\n};\nconst keepAliveDefaults = {\n    enabled: false,\n    pongTimeoutMs: 1000,\n    intervalMs: 5000\n};\n/**\n * Calculates a delay for exponential backoff based on the retry attempt index.\n * The delay starts at 0 for the first attempt and doubles for each subsequent attempt,\n * capped at 30 seconds.\n */ const exponentialBackoff = (attemptIndex)=>{\n    return attemptIndex === 0 ? 0 : Math.min(1000 * 2 ** attemptIndex, 30000);\n};\n\nexport { exponentialBackoff, keepAliveDefaults, lazyDefaults };\n"],"names":[],"mappings":";;;;;AAAA,MAAM,eAAe;IACjB,SAAS;IACT,SAAS;AACb;AACA,MAAM,oBAAoB;IACtB,SAAS;IACT,eAAe;IACf,YAAY;AAChB;AACA;;;;CAIC,GAAG,MAAM,qBAAqB,CAAC;IAC5B,OAAO,iBAAiB,IAAI,IAAI,KAAK,GAAG,CAAC,OAAO,KAAK,cAAc;AACvE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1383, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/links/internals/urlWithConnectionParams.mjs"],"sourcesContent":["/**\n * Get the result of a value or function that returns a value\n * It also optionally accepts typesafe arguments for the function\n */ const resultOf = (value, ...args)=>{\n    return typeof value === 'function' ? value(...args) : value;\n};\n\nexport { resultOf };\n"],"names":[],"mappings":"AAAA;;;CAGC;;;AAAG,MAAM,WAAW,CAAC,OAAO,GAAG;IAC5B,OAAO,OAAO,UAAU,aAAa,SAAS,QAAQ;AAC1D","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1399, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/links/wsLink/wsClient/utils.mjs"],"sourcesContent":["import { resultOf } from '../../internals/urlWithConnectionParams.mjs';\n\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nclass TRPCWebSocketClosedError extends Error {\n    constructor(opts){\n        super(opts.message, {\n            cause: opts.cause\n        });\n        this.name = 'TRPCWebSocketClosedError';\n        Object.setPrototypeOf(this, TRPCWebSocketClosedError.prototype);\n    }\n}\n/**\n * Utility class for managing a timeout that can be started, stopped, and reset.\n * Useful for scenarios where the timeout duration is reset dynamically based on events.\n */ class ResettableTimeout {\n    /**\n   * Resets the current timeout, restarting it with the same duration.\n   * Does nothing if no timeout is active.\n   */ reset() {\n        if (!this.timeout) return;\n        clearTimeout(this.timeout);\n        this.timeout = setTimeout(this.onTimeout, this.timeoutMs);\n    }\n    start() {\n        clearTimeout(this.timeout);\n        this.timeout = setTimeout(this.onTimeout, this.timeoutMs);\n    }\n    stop() {\n        clearTimeout(this.timeout);\n        this.timeout = undefined;\n    }\n    constructor(onTimeout, timeoutMs){\n        _define_property(this, \"onTimeout\", void 0);\n        _define_property(this, \"timeoutMs\", void 0);\n        _define_property(this, \"timeout\", void 0);\n        this.onTimeout = onTimeout;\n        this.timeoutMs = timeoutMs;\n    }\n}\n// Ponyfill for Promise.withResolvers https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers\nfunction withResolvers() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return {\n        promise,\n        resolve: resolve,\n        reject: reject\n    };\n}\n/**\n * Resolves a WebSocket URL and optionally appends connection parameters.\n *\n * If connectionParams are provided, appends 'connectionParams=1' query parameter.\n */ async function prepareUrl(urlOptions) {\n    const url = await resultOf(urlOptions.url);\n    if (!urlOptions.connectionParams) return url;\n    // append `?connectionParams=1` when connection params are used\n    const prefix = url.includes('?') ? '&' : '?';\n    const connectionParams = `${prefix}connectionParams=1`;\n    return url + connectionParams;\n}\nasync function buildConnectionMessage(connectionParams) {\n    const message = {\n        method: 'connectionParams',\n        data: await resultOf(connectionParams)\n    };\n    return JSON.stringify(message);\n}\n\nexport { ResettableTimeout, TRPCWebSocketClosedError, buildConnectionMessage, prepareUrl, withResolvers };\n"],"names":[],"mappings":";;;;;;;AAAA;;AAEA,SAAS,iBAAiB,GAAG,EAAE,GAAG,EAAE,KAAK;IACrC,IAAI,OAAO,KAAK;QACZ,OAAO,cAAc,CAAC,KAAK,KAAK;YAC5B,OAAO;YACP,YAAY;YACZ,cAAc;YACd,UAAU;QACd;IACJ,OAAO;QACH,GAAG,CAAC,IAAI,GAAG;IACf;IACA,OAAO;AACX;AACA,MAAM,iCAAiC;IACnC,YAAY,IAAI,CAAC;QACb,KAAK,CAAC,KAAK,OAAO,EAAE;YAChB,OAAO,KAAK,KAAK;QACrB;QACA,IAAI,CAAC,IAAI,GAAG;QACZ,OAAO,cAAc,CAAC,IAAI,EAAE,yBAAyB,SAAS;IAClE;AACJ;AACA;;;CAGC,GAAG,MAAM;IACN;;;GAGD,GAAG,QAAQ;QACN,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;QACnB,aAAa,IAAI,CAAC,OAAO;QACzB,IAAI,CAAC,OAAO,GAAG,WAAW,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,SAAS;IAC5D;IACA,QAAQ;QACJ,aAAa,IAAI,CAAC,OAAO;QACzB,IAAI,CAAC,OAAO,GAAG,WAAW,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,SAAS;IAC5D;IACA,OAAO;QACH,aAAa,IAAI,CAAC,OAAO;QACzB,IAAI,CAAC,OAAO,GAAG;IACnB;IACA,YAAY,SAAS,EAAE,SAAS,CAAC;QAC7B,iBAAiB,IAAI,EAAE,aAAa,KAAK;QACzC,iBAAiB,IAAI,EAAE,aAAa,KAAK;QACzC,iBAAiB,IAAI,EAAE,WAAW,KAAK;QACvC,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,SAAS,GAAG;IACrB;AACJ;AACA,4IAA4I;AAC5I,SAAS;IACL,IAAI;IACJ,IAAI;IACJ,MAAM,UAAU,IAAI,QAAQ,CAAC,KAAK;QAC9B,UAAU;QACV,SAAS;IACb;IACA,oEAAoE;IACpE,OAAO;QACH;QACA,SAAS;QACT,QAAQ;IACZ;AACJ;AACA;;;;CAIC,GAAG,eAAe,WAAW,UAAU;IACpC,MAAM,MAAM,MAAM,CAAA,GAAA,0LAAA,CAAA,WAAQ,AAAD,EAAE,WAAW,GAAG;IACzC,IAAI,CAAC,WAAW,gBAAgB,EAAE,OAAO;IACzC,+DAA+D;IAC/D,MAAM,SAAS,IAAI,QAAQ,CAAC,OAAO,MAAM;IACzC,MAAM,mBAAmB,GAAG,OAAO,kBAAkB,CAAC;IACtD,OAAO,MAAM;AACjB;AACA,eAAe,uBAAuB,gBAAgB;IAClD,MAAM,UAAU;QACZ,QAAQ;QACR,MAAM,MAAM,CAAA,GAAA,0LAAA,CAAA,WAAQ,AAAD,EAAE;IACzB;IACA,OAAO,KAAK,SAAS,CAAC;AAC1B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1499, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/links/wsLink/wsClient/requestManager.mjs"],"sourcesContent":["import { withResolvers } from './utils.mjs';\n\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\n/**\n * Manages WebSocket requests, tracking their lifecycle and providing utility methods\n * for handling outgoing and pending requests.\n *\n * - **Outgoing requests**: Requests that are queued and waiting to be sent.\n * - **Pending requests**: Requests that have been sent and are in flight awaiting a response.\n *   For subscriptions, multiple responses may be received until the subscription is closed.\n */ class RequestManager {\n    /**\n   * Registers a new request by adding it to the outgoing queue and setting up\n   * callbacks for lifecycle events such as completion or error.\n   *\n   * @param message - The outgoing message to be sent.\n   * @param callbacks - Callback functions to observe the request's state.\n   * @returns A cleanup function to manually remove the request.\n   */ register(message, callbacks) {\n        const { promise: end, resolve } = withResolvers();\n        this.outgoingRequests.push({\n            id: String(message.id),\n            message,\n            end,\n            callbacks: {\n                next: callbacks.next,\n                complete: ()=>{\n                    callbacks.complete();\n                    resolve();\n                },\n                error: (e)=>{\n                    callbacks.error(e);\n                    resolve();\n                }\n            }\n        });\n        return ()=>{\n            this.delete(message.id);\n            callbacks.complete();\n            resolve();\n        };\n    }\n    /**\n   * Deletes a request from both the outgoing and pending collections, if it exists.\n   */ delete(messageId) {\n        if (messageId === null) return;\n        this.outgoingRequests = this.outgoingRequests.filter(({ id })=>id !== String(messageId));\n        delete this.pendingRequests[String(messageId)];\n    }\n    /**\n   * Moves all outgoing requests to the pending state and clears the outgoing queue.\n   *\n   * The caller is expected to handle the actual sending of the requests\n   * (e.g., sending them over the network) after this method is called.\n   *\n   * @returns The list of requests that were transitioned to the pending state.\n   */ flush() {\n        const requests = this.outgoingRequests;\n        this.outgoingRequests = [];\n        for (const request of requests){\n            this.pendingRequests[request.id] = request;\n        }\n        return requests;\n    }\n    /**\n   * Retrieves all currently pending requests, which are in flight awaiting responses\n   * or handling ongoing subscriptions.\n   */ getPendingRequests() {\n        return Object.values(this.pendingRequests);\n    }\n    /**\n   * Retrieves a specific pending request by its message ID.\n   */ getPendingRequest(messageId) {\n        if (messageId === null) return null;\n        return this.pendingRequests[String(messageId)];\n    }\n    /**\n   * Retrieves all outgoing requests, which are waiting to be sent.\n   */ getOutgoingRequests() {\n        return this.outgoingRequests;\n    }\n    /**\n   * Retrieves all requests, both outgoing and pending, with their respective states.\n   *\n   * @returns An array of all requests with their state (\"outgoing\" or \"pending\").\n   */ getRequests() {\n        return [\n            ...this.getOutgoingRequests().map((request)=>({\n                    state: 'outgoing',\n                    message: request.message,\n                    end: request.end,\n                    callbacks: request.callbacks\n                })),\n            ...this.getPendingRequests().map((request)=>({\n                    state: 'pending',\n                    message: request.message,\n                    end: request.end,\n                    callbacks: request.callbacks\n                }))\n        ];\n    }\n    /**\n   * Checks if there are any pending requests, including ongoing subscriptions.\n   */ hasPendingRequests() {\n        return this.getPendingRequests().length > 0;\n    }\n    /**\n   * Checks if there are any outgoing requests waiting to be sent.\n   */ hasOutgoingRequests() {\n        return this.outgoingRequests.length > 0;\n    }\n    constructor(){\n        /**\n   * Stores requests that are outgoing, meaning they are registered but not yet sent over the WebSocket.\n   */ _define_property(this, \"outgoingRequests\", new Array());\n        /**\n   * Stores requests that are pending (in flight), meaning they have been sent over the WebSocket\n   * and are awaiting responses. For subscriptions, this includes requests\n   * that may receive multiple responses.\n   */ _define_property(this, \"pendingRequests\", {});\n    }\n}\n\nexport { RequestManager };\n"],"names":[],"mappings":";;;AAAA;;AAEA,SAAS,iBAAiB,GAAG,EAAE,GAAG,EAAE,KAAK;IACrC,IAAI,OAAO,KAAK;QACZ,OAAO,cAAc,CAAC,KAAK,KAAK;YAC5B,OAAO;YACP,YAAY;YACZ,cAAc;YACd,UAAU;QACd;IACJ,OAAO;QACH,GAAG,CAAC,IAAI,GAAG;IACf;IACA,OAAO;AACX;AACA;;;;;;;CAOC,GAAG,MAAM;IACN;;;;;;;GAOD,GAAG,SAAS,OAAO,EAAE,SAAS,EAAE;QAC3B,MAAM,EAAE,SAAS,GAAG,EAAE,OAAO,EAAE,GAAG,CAAA,GAAA,iLAAA,CAAA,gBAAa,AAAD;QAC9C,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC;YACvB,IAAI,OAAO,QAAQ,EAAE;YACrB;YACA;YACA,WAAW;gBACP,MAAM,UAAU,IAAI;gBACpB,UAAU;oBACN,UAAU,QAAQ;oBAClB;gBACJ;gBACA,OAAO,CAAC;oBACJ,UAAU,KAAK,CAAC;oBAChB;gBACJ;YACJ;QACJ;QACA,OAAO;YACH,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE;YACtB,UAAU,QAAQ;YAClB;QACJ;IACJ;IACA;;GAED,GAAG,OAAO,SAAS,EAAE;QAChB,IAAI,cAAc,MAAM;QACxB,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC,EAAE,EAAE,EAAE,GAAG,OAAO,OAAO;QAC7E,OAAO,IAAI,CAAC,eAAe,CAAC,OAAO,WAAW;IAClD;IACA;;;;;;;GAOD,GAAG,QAAQ;QACN,MAAM,WAAW,IAAI,CAAC,gBAAgB;QACtC,IAAI,CAAC,gBAAgB,GAAG,EAAE;QAC1B,KAAK,MAAM,WAAW,SAAS;YAC3B,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,CAAC,GAAG;QACvC;QACA,OAAO;IACX;IACA;;;GAGD,GAAG,qBAAqB;QACnB,OAAO,OAAO,MAAM,CAAC,IAAI,CAAC,eAAe;IAC7C;IACA;;GAED,GAAG,kBAAkB,SAAS,EAAE;QAC3B,IAAI,cAAc,MAAM,OAAO;QAC/B,OAAO,IAAI,CAAC,eAAe,CAAC,OAAO,WAAW;IAClD;IACA;;GAED,GAAG,sBAAsB;QACpB,OAAO,IAAI,CAAC,gBAAgB;IAChC;IACA;;;;GAID,GAAG,cAAc;QACZ,OAAO;eACA,IAAI,CAAC,mBAAmB,GAAG,GAAG,CAAC,CAAC,UAAU,CAAC;oBACtC,OAAO;oBACP,SAAS,QAAQ,OAAO;oBACxB,KAAK,QAAQ,GAAG;oBAChB,WAAW,QAAQ,SAAS;gBAChC,CAAC;eACF,IAAI,CAAC,kBAAkB,GAAG,GAAG,CAAC,CAAC,UAAU,CAAC;oBACrC,OAAO;oBACP,SAAS,QAAQ,OAAO;oBACxB,KAAK,QAAQ,GAAG;oBAChB,WAAW,QAAQ,SAAS;gBAChC,CAAC;SACR;IACL;IACA;;GAED,GAAG,qBAAqB;QACnB,OAAO,IAAI,CAAC,kBAAkB,GAAG,MAAM,GAAG;IAC9C;IACA;;GAED,GAAG,sBAAsB;QACpB,OAAO,IAAI,CAAC,gBAAgB,CAAC,MAAM,GAAG;IAC1C;IACA,aAAa;QACT;;GAEL,GAAG,iBAAiB,IAAI,EAAE,oBAAoB,IAAI;QAC7C;;;;GAIL,GAAG,iBAAiB,IAAI,EAAE,mBAAmB,CAAC;IAC7C;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1643, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/links/wsLink/wsClient/wsConnection.mjs"],"sourcesContent":["import { behaviorSubject } from '@trpc/server/observable';\nimport { prepareUrl, buildConnectionMessage, withResolvers } from './utils.mjs';\n\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\n/**\n * Opens a WebSocket connection asynchronously and returns a promise\n * that resolves when the connection is successfully established.\n * The promise rejects if an error occurs during the connection attempt.\n */ function asyncWsOpen(ws) {\n    const { promise, resolve, reject } = withResolvers();\n    ws.addEventListener('open', ()=>{\n        ws.removeEventListener('error', reject);\n        resolve();\n    });\n    ws.addEventListener('error', reject);\n    return promise;\n}\n/**\n * Sets up a periodic ping-pong mechanism to keep the WebSocket connection alive.\n *\n * - Sends \"PING\" messages at regular intervals defined by `intervalMs`.\n * - If a \"PONG\" response is not received within the `pongTimeoutMs`, the WebSocket is closed.\n * - The ping timer resets upon receiving any message to maintain activity.\n * - Automatically starts the ping process when the WebSocket connection is opened.\n * - Cleans up timers when the WebSocket is closed.\n *\n * @param ws - The WebSocket instance to manage.\n * @param options - Configuration options for ping-pong intervals and timeouts.\n */ function setupPingInterval(ws, { intervalMs, pongTimeoutMs }) {\n    let pingTimeout;\n    let pongTimeout;\n    function start() {\n        pingTimeout = setTimeout(()=>{\n            ws.send('PING');\n            pongTimeout = setTimeout(()=>{\n                ws.close();\n            }, pongTimeoutMs);\n        }, intervalMs);\n    }\n    function reset() {\n        clearTimeout(pingTimeout);\n        start();\n    }\n    function pong() {\n        clearTimeout(pongTimeout);\n        reset();\n    }\n    ws.addEventListener('open', start);\n    ws.addEventListener('message', ({ data })=>{\n        clearTimeout(pingTimeout);\n        start();\n        if (data === 'PONG') {\n            pong();\n        }\n    });\n    ws.addEventListener('close', ()=>{\n        clearTimeout(pingTimeout);\n        clearTimeout(pongTimeout);\n    });\n}\n/**\n * Manages a WebSocket connection with support for reconnection, keep-alive mechanisms,\n * and observable state tracking.\n */ class WsConnection {\n    get ws() {\n        return this.wsObservable.get();\n    }\n    set ws(ws) {\n        this.wsObservable.next(ws);\n    }\n    /**\n   * Checks if the WebSocket connection is open and ready to communicate.\n   */ isOpen() {\n        return !!this.ws && this.ws.readyState === this.WebSocketPonyfill.OPEN && !this.openPromise;\n    }\n    /**\n   * Checks if the WebSocket connection is closed or in the process of closing.\n   */ isClosed() {\n        return !!this.ws && (this.ws.readyState === this.WebSocketPonyfill.CLOSING || this.ws.readyState === this.WebSocketPonyfill.CLOSED);\n    }\n    async open() {\n        if (this.openPromise) return this.openPromise;\n        this.id = ++WsConnection.connectCount;\n        const wsPromise = prepareUrl(this.urlOptions).then((url)=>new this.WebSocketPonyfill(url));\n        this.openPromise = wsPromise.then(async (ws)=>{\n            this.ws = ws;\n            // Setup ping listener\n            ws.addEventListener('message', function({ data }) {\n                if (data === 'PING') {\n                    this.send('PONG');\n                }\n            });\n            if (this.keepAliveOpts.enabled) {\n                setupPingInterval(ws, this.keepAliveOpts);\n            }\n            ws.addEventListener('close', ()=>{\n                if (this.ws === ws) {\n                    this.ws = null;\n                }\n            });\n            await asyncWsOpen(ws);\n            if (this.urlOptions.connectionParams) {\n                ws.send(await buildConnectionMessage(this.urlOptions.connectionParams));\n            }\n        });\n        try {\n            await this.openPromise;\n        } finally{\n            this.openPromise = null;\n        }\n    }\n    /**\n   * Closes the WebSocket connection gracefully.\n   * Waits for any ongoing open operation to complete before closing.\n   */ async close() {\n        try {\n            await this.openPromise;\n        } finally{\n            this.ws?.close();\n        }\n    }\n    constructor(opts){\n        _define_property(this, \"id\", ++WsConnection.connectCount);\n        _define_property(this, \"WebSocketPonyfill\", void 0);\n        _define_property(this, \"urlOptions\", void 0);\n        _define_property(this, \"keepAliveOpts\", void 0);\n        _define_property(this, \"wsObservable\", behaviorSubject(null));\n        /**\n   * Manages the WebSocket opening process, ensuring that only one open operation\n   * occurs at a time. Tracks the ongoing operation with `openPromise` to avoid\n   * redundant calls and ensure proper synchronization.\n   *\n   * Sets up the keep-alive mechanism and necessary event listeners for the connection.\n   *\n   * @returns A promise that resolves once the WebSocket connection is successfully opened.\n   */ _define_property(this, \"openPromise\", null);\n        this.WebSocketPonyfill = opts.WebSocketPonyfill ?? WebSocket;\n        if (!this.WebSocketPonyfill) {\n            throw new Error(\"No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill\");\n        }\n        this.urlOptions = opts.urlOptions;\n        this.keepAliveOpts = opts.keepAlive;\n    }\n}\n_define_property(WsConnection, \"connectCount\", 0);\n/**\n * Provides a backward-compatible representation of the connection state.\n */ function backwardCompatibility(connection) {\n    if (connection.isOpen()) {\n        return {\n            id: connection.id,\n            state: 'open',\n            ws: connection.ws\n        };\n    }\n    if (connection.isClosed()) {\n        return {\n            id: connection.id,\n            state: 'closed',\n            ws: connection.ws\n        };\n    }\n    if (!connection.ws) {\n        return null;\n    }\n    return {\n        id: connection.id,\n        state: 'connecting',\n        ws: connection.ws\n    };\n}\n\nexport { WsConnection, backwardCompatibility };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1839, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/links/wsLink/wsClient/wsClient.mjs"],"sourcesContent":["import { observable, behaviorSubject } from '@trpc/server/observable';\nimport { transformResult, run, sleep } from '@trpc/server/unstable-core-do-not-import';\nimport { TRPCClientError } from '../../../TRPCClientError.mjs';\nimport { lazyDefaults, keepAliveDefaults, exponentialBackoff } from './options.mjs';\nimport { RequestManager } from './requestManager.mjs';\nimport { TRPCWebSocketClosedError, ResettableTimeout } from './utils.mjs';\nimport { backwardCompatibility, WsConnection } from './wsConnection.mjs';\n\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\n/**\n * A WebSocket client for managing TRPC operations, supporting lazy initialization,\n * reconnection, keep-alive, and request management.\n */ class WsClient {\n    /**\n   * Opens the WebSocket connection. Handles reconnection attempts and updates\n   * the connection state accordingly.\n   */ async open() {\n        this.allowReconnect = true;\n        if (this.connectionState.get().state !== 'connecting') {\n            this.connectionState.next({\n                type: 'state',\n                state: 'connecting',\n                error: null\n            });\n        }\n        try {\n            await this.activeConnection.open();\n        } catch (error) {\n            this.reconnect(new TRPCWebSocketClosedError({\n                message: 'Initialization error',\n                cause: error\n            }));\n            return this.reconnecting;\n        }\n    }\n    /**\n   * Closes the WebSocket connection and stops managing requests.\n   * Ensures all outgoing and pending requests are properly finalized.\n   */ async close() {\n        this.allowReconnect = false;\n        this.inactivityTimeout.stop();\n        const requestsToAwait = [];\n        for (const request of this.requestManager.getRequests()){\n            if (request.message.method === 'subscription') {\n                request.callbacks.complete();\n            } else if (request.state === 'outgoing') {\n                request.callbacks.error(TRPCClientError.from(new TRPCWebSocketClosedError({\n                    message: 'Closed before connection was established'\n                })));\n            } else {\n                requestsToAwait.push(request.end);\n            }\n        }\n        await Promise.all(requestsToAwait).catch(()=>null);\n        await this.activeConnection.close().catch(()=>null);\n        this.connectionState.next({\n            type: 'state',\n            state: 'idle',\n            error: null\n        });\n    }\n    /**\n   * Method to request the server.\n   * Handles data transformation, batching of requests, and subscription lifecycle.\n   *\n   * @param op - The operation details including id, type, path, input and signal\n   * @param transformer - Data transformer for serializing requests and deserializing responses\n   * @param lastEventId - Optional ID of the last received event for subscriptions\n   *\n   * @returns An observable that emits operation results and handles cleanup\n   */ request({ op: { id, type, path, input, signal }, transformer, lastEventId }) {\n        return observable((observer)=>{\n            const abort = this.batchSend({\n                id,\n                method: type,\n                params: {\n                    input: transformer.input.serialize(input),\n                    path,\n                    lastEventId\n                }\n            }, {\n                ...observer,\n                next (event) {\n                    const transformed = transformResult(event, transformer.output);\n                    if (!transformed.ok) {\n                        observer.error(TRPCClientError.from(transformed.error));\n                        return;\n                    }\n                    observer.next({\n                        result: transformed.result\n                    });\n                }\n            });\n            return ()=>{\n                abort();\n                if (type === 'subscription' && this.activeConnection.isOpen()) {\n                    this.send({\n                        id,\n                        method: 'subscription.stop'\n                    });\n                }\n                signal?.removeEventListener('abort', abort);\n            };\n        });\n    }\n    get connection() {\n        return backwardCompatibility(this.activeConnection);\n    }\n    reconnect(closedError) {\n        this.connectionState.next({\n            type: 'state',\n            state: 'connecting',\n            error: TRPCClientError.from(closedError)\n        });\n        if (this.reconnecting) return;\n        const tryReconnect = async (attemptIndex)=>{\n            try {\n                await sleep(this.reconnectRetryDelay(attemptIndex));\n                if (this.allowReconnect) {\n                    await this.activeConnection.close();\n                    await this.activeConnection.open();\n                    if (this.requestManager.hasPendingRequests()) {\n                        this.send(this.requestManager.getPendingRequests().map(({ message })=>message));\n                    }\n                }\n                this.reconnecting = null;\n            } catch  {\n                await tryReconnect(attemptIndex + 1);\n            }\n        };\n        this.reconnecting = tryReconnect(0);\n    }\n    setupWebSocketListeners(ws) {\n        const handleCloseOrError = (cause)=>{\n            const reqs = this.requestManager.getPendingRequests();\n            for (const { message, callbacks } of reqs){\n                if (message.method === 'subscription') continue;\n                callbacks.error(TRPCClientError.from(cause ?? new TRPCWebSocketClosedError({\n                    message: 'WebSocket closed',\n                    cause\n                })));\n                this.requestManager.delete(message.id);\n            }\n        };\n        ws.addEventListener('open', ()=>{\n            run(async ()=>{\n                if (this.lazyMode) {\n                    this.inactivityTimeout.start();\n                }\n                this.callbacks.onOpen?.();\n                this.connectionState.next({\n                    type: 'state',\n                    state: 'pending',\n                    error: null\n                });\n            }).catch((error)=>{\n                ws.close(3000);\n                handleCloseOrError(error);\n            });\n        });\n        ws.addEventListener('message', ({ data })=>{\n            this.inactivityTimeout.reset();\n            if (typeof data !== 'string' || [\n                'PING',\n                'PONG'\n            ].includes(data)) return;\n            const incomingMessage = JSON.parse(data);\n            if ('method' in incomingMessage) {\n                this.handleIncomingRequest(incomingMessage);\n                return;\n            }\n            this.handleResponseMessage(incomingMessage);\n        });\n        ws.addEventListener('close', (event)=>{\n            handleCloseOrError(event);\n            this.callbacks.onClose?.(event);\n            if (!this.lazyMode) {\n                this.reconnect(new TRPCWebSocketClosedError({\n                    message: 'WebSocket closed',\n                    cause: event\n                }));\n            }\n        });\n        ws.addEventListener('error', (event)=>{\n            handleCloseOrError(event);\n            this.callbacks.onError?.(event);\n            this.reconnect(new TRPCWebSocketClosedError({\n                message: 'WebSocket closed',\n                cause: event\n            }));\n        });\n    }\n    handleResponseMessage(message) {\n        const request = this.requestManager.getPendingRequest(message.id);\n        if (!request) return;\n        request.callbacks.next(message);\n        let completed = true;\n        if ('result' in message && request.message.method === 'subscription') {\n            if (message.result.type === 'data') {\n                request.message.params.lastEventId = message.result.id;\n            }\n            if (message.result.type !== 'stopped') {\n                completed = false;\n            }\n        }\n        if (completed) {\n            request.callbacks.complete();\n            this.requestManager.delete(message.id);\n        }\n    }\n    handleIncomingRequest(message) {\n        if (message.method === 'reconnect') {\n            this.reconnect(new TRPCWebSocketClosedError({\n                message: 'Server requested reconnect'\n            }));\n        }\n    }\n    /**\n   * Sends a message or batch of messages directly to the server.\n   */ send(messageOrMessages) {\n        if (!this.activeConnection.isOpen()) {\n            throw new Error('Active connection is not open');\n        }\n        const messages = messageOrMessages instanceof Array ? messageOrMessages : [\n            messageOrMessages\n        ];\n        this.activeConnection.ws.send(JSON.stringify(messages.length === 1 ? messages[0] : messages));\n    }\n    /**\n   * Groups requests for batch sending.\n   *\n   * @returns A function to abort the batched request.\n   */ batchSend(message, callbacks) {\n        this.inactivityTimeout.reset();\n        run(async ()=>{\n            if (!this.activeConnection.isOpen()) {\n                await this.open();\n            }\n            await sleep(0);\n            if (!this.requestManager.hasOutgoingRequests()) return;\n            this.send(this.requestManager.flush().map(({ message })=>message));\n        }).catch((err)=>{\n            this.requestManager.delete(message.id);\n            callbacks.error(TRPCClientError.from(err));\n        });\n        return this.requestManager.register(message, callbacks);\n    }\n    constructor(opts){\n        /**\n   * Observable tracking the current connection state, including errors.\n   */ _define_property(this, \"connectionState\", void 0);\n        _define_property(this, \"allowReconnect\", false);\n        _define_property(this, \"requestManager\", new RequestManager());\n        _define_property(this, \"activeConnection\", void 0);\n        _define_property(this, \"reconnectRetryDelay\", void 0);\n        _define_property(this, \"inactivityTimeout\", void 0);\n        _define_property(this, \"callbacks\", void 0);\n        _define_property(this, \"lazyMode\", void 0);\n        /**\n   * Manages the reconnection process for the WebSocket using retry logic.\n   * Ensures that only one reconnection attempt is active at a time by tracking the current\n   * reconnection state in the `reconnecting` promise.\n   */ _define_property(this, \"reconnecting\", null);\n        // Initialize callbacks, connection parameters, and options.\n        this.callbacks = {\n            onOpen: opts.onOpen,\n            onClose: opts.onClose,\n            onError: opts.onError\n        };\n        const lazyOptions = {\n            ...lazyDefaults,\n            ...opts.lazy\n        };\n        // Set up inactivity timeout for lazy connections.\n        this.inactivityTimeout = new ResettableTimeout(()=>{\n            if (this.requestManager.hasOutgoingRequests() || this.requestManager.hasPendingRequests()) {\n                this.inactivityTimeout.reset();\n                return;\n            }\n            this.close().catch(()=>null);\n        }, lazyOptions.closeMs);\n        // Initialize the WebSocket connection.\n        this.activeConnection = new WsConnection({\n            WebSocketPonyfill: opts.WebSocket,\n            urlOptions: opts,\n            keepAlive: {\n                ...keepAliveDefaults,\n                ...opts.keepAlive\n            }\n        });\n        this.activeConnection.wsObservable.subscribe({\n            next: (ws)=>{\n                if (!ws) return;\n                this.setupWebSocketListeners(ws);\n            }\n        });\n        this.reconnectRetryDelay = opts.retryDelayMs ?? exponentialBackoff;\n        this.lazyMode = lazyOptions.enabled;\n        this.connectionState = behaviorSubject({\n            type: 'state',\n            state: lazyOptions.enabled ? 'idle' : 'connecting',\n            error: null\n        });\n        // Automatically open the connection if lazy mode is disabled.\n        if (!this.lazyMode) {\n            this.open().catch(()=>null);\n        }\n    }\n}\n\nexport { WsClient };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2180, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/links/wsLink/createWsClient.mjs"],"sourcesContent":["import { WsClient } from './wsClient/wsClient.mjs';\n\nfunction createWSClient(opts) {\n    return new WsClient(opts);\n}\n\nexport { createWSClient };\n"],"names":[],"mappings":";;;AAAA;;AAEA,SAAS,eAAe,IAAI;IACxB,OAAO,IAAI,oLAAA,CAAA,WAAQ,CAAC;AACxB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2195, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/links/wsLink/wsLink.mjs"],"sourcesContent":["import { observable } from '@trpc/server/observable';\nimport { getTransformer } from '../../internals/transformer.mjs';\nexport { createWSClient } from './createWsClient.mjs';\n\nfunction wsLink(opts) {\n    const { client } = opts;\n    const transformer = getTransformer(opts.transformer);\n    return ()=>{\n        return ({ op })=>{\n            return observable((observer)=>{\n                const connStateSubscription = op.type === 'subscription' ? client.connectionState.subscribe({\n                    next (result) {\n                        observer.next({\n                            result,\n                            context: op.context\n                        });\n                    }\n                }) : null;\n                const requestSubscription = client.request({\n                    op,\n                    transformer\n                }).subscribe(observer);\n                return ()=>{\n                    requestSubscription.unsubscribe();\n                    connStateSubscription?.unsubscribe();\n                };\n            });\n        };\n    };\n}\n\nexport { wsLink };\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;AACA;;;;AAEA,SAAS,OAAO,IAAI;IAChB,MAAM,EAAE,MAAM,EAAE,GAAG;IACnB,MAAM,cAAc,CAAA,GAAA,qKAAA,CAAA,iBAAc,AAAD,EAAE,KAAK,WAAW;IACnD,OAAO;QACH,OAAO,CAAC,EAAE,EAAE,EAAE;YACV,OAAO,CAAA,GAAA,qKAAA,CAAA,aAAU,AAAD,EAAE,CAAC;gBACf,MAAM,wBAAwB,GAAG,IAAI,KAAK,iBAAiB,OAAO,eAAe,CAAC,SAAS,CAAC;oBACxF,MAAM,MAAM;wBACR,SAAS,IAAI,CAAC;4BACV;4BACA,SAAS,GAAG,OAAO;wBACvB;oBACJ;gBACJ,KAAK;gBACL,MAAM,sBAAsB,OAAO,OAAO,CAAC;oBACvC;oBACA;gBACJ,GAAG,SAAS,CAAC;gBACb,OAAO;oBACH,oBAAoB,WAAW;oBAC/B,uBAAuB;gBAC3B;YACJ;QACJ;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2249, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/internals/inputWithTrackedEventId.mjs"],"sourcesContent":["function inputWithTrackedEventId(input, lastEventId) {\n    if (!lastEventId) {\n        return input;\n    }\n    if (input != null && typeof input !== 'object') {\n        return input;\n    }\n    return {\n        ...input ?? {},\n        lastEventId\n    };\n}\n\nexport { inputWithTrackedEventId };\n"],"names":[],"mappings":";;;AAAA,SAAS,wBAAwB,KAAK,EAAE,WAAW;IAC/C,IAAI,CAAC,aAAa;QACd,OAAO;IACX;IACA,IAAI,SAAS,QAAQ,OAAO,UAAU,UAAU;QAC5C,OAAO;IACX;IACA,OAAO;QACH,GAAG,SAAS,CAAC,CAAC;QACd;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2271, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/links/httpSubscriptionLink.mjs"],"sourcesContent":["import { observable, behaviorSubject } from '@trpc/server/observable';\nimport { TRPC_ERROR_CODES_BY_KEY } from '@trpc/server/rpc';\nimport { sseStreamConsumer, run } from '@trpc/server/unstable-core-do-not-import';\nimport { inputWithTrackedEventId } from '../internals/inputWithTrackedEventId.mjs';\nimport { raceAbortSignals } from '../internals/signals.mjs';\nimport { TRPCClientError } from '../TRPCClientError.mjs';\nimport { getTransformer } from '../internals/transformer.mjs';\nimport { getUrl } from './internals/httpUtils.mjs';\nimport { resultOf } from './internals/urlWithConnectionParams.mjs';\n\nasync function urlWithConnectionParams(opts) {\n    let url = await resultOf(opts.url);\n    if (opts.connectionParams) {\n        const params = await resultOf(opts.connectionParams);\n        const prefix = url.includes('?') ? '&' : '?';\n        url += prefix + 'connectionParams=' + encodeURIComponent(JSON.stringify(params));\n    }\n    return url;\n}\n/**\n * tRPC error codes that are considered retryable\n * With out of the box SSE, the client will reconnect when these errors are encountered\n */ const codes5xx = [\n    TRPC_ERROR_CODES_BY_KEY.BAD_GATEWAY,\n    TRPC_ERROR_CODES_BY_KEY.SERVICE_UNAVAILABLE,\n    TRPC_ERROR_CODES_BY_KEY.GATEWAY_TIMEOUT,\n    TRPC_ERROR_CODES_BY_KEY.INTERNAL_SERVER_ERROR\n];\n/**\n * @see https://trpc.io/docs/client/links/httpSubscriptionLink\n */ function httpSubscriptionLink(opts) {\n    const transformer = getTransformer(opts.transformer);\n    return ()=>{\n        return ({ op })=>{\n            return observable((observer)=>{\n                const { type, path, input } = op;\n                /* istanbul ignore if -- @preserve */ if (type !== 'subscription') {\n                    throw new Error('httpSubscriptionLink only supports subscriptions');\n                }\n                let lastEventId = undefined;\n                const ac = new AbortController();\n                const signal = raceAbortSignals(op.signal, ac.signal);\n                const eventSourceStream = sseStreamConsumer({\n                    url: async ()=>getUrl({\n                            transformer,\n                            url: await urlWithConnectionParams(opts),\n                            input: inputWithTrackedEventId(input, lastEventId),\n                            path,\n                            type,\n                            signal: null\n                        }),\n                    init: ()=>resultOf(opts.eventSourceOptions, {\n                            op\n                        }),\n                    signal,\n                    deserialize: transformer.output.deserialize,\n                    EventSource: opts.EventSource ?? globalThis.EventSource\n                });\n                const connectionState = behaviorSubject({\n                    type: 'state',\n                    state: 'connecting',\n                    error: null\n                });\n                const connectionSub = connectionState.subscribe({\n                    next (state) {\n                        observer.next({\n                            result: state\n                        });\n                    }\n                });\n                run(async ()=>{\n                    for await (const chunk of eventSourceStream){\n                        switch(chunk.type){\n                            case 'ping':\n                                break;\n                            case 'data':\n                                const chunkData = chunk.data;\n                                let result;\n                                if (chunkData.id) {\n                                    // if the `tracked()`-helper is used, we always have an `id` field\n                                    lastEventId = chunkData.id;\n                                    result = {\n                                        id: chunkData.id,\n                                        data: chunkData\n                                    };\n                                } else {\n                                    result = {\n                                        data: chunkData.data\n                                    };\n                                }\n                                observer.next({\n                                    result,\n                                    context: {\n                                        eventSource: chunk.eventSource\n                                    }\n                                });\n                                break;\n                            case 'connected':\n                                {\n                                    observer.next({\n                                        result: {\n                                            type: 'started'\n                                        },\n                                        context: {\n                                            eventSource: chunk.eventSource\n                                        }\n                                    });\n                                    connectionState.next({\n                                        type: 'state',\n                                        state: 'pending',\n                                        error: null\n                                    });\n                                    break;\n                                }\n                            case 'serialized-error':\n                                {\n                                    const error = TRPCClientError.from({\n                                        error: chunk.error\n                                    });\n                                    if (codes5xx.includes(chunk.error.code)) {\n                                        //\n                                        connectionState.next({\n                                            type: 'state',\n                                            state: 'connecting',\n                                            error\n                                        });\n                                        break;\n                                    }\n                                    //\n                                    // non-retryable error, cancel the subscription\n                                    throw error;\n                                }\n                            case 'connecting':\n                                {\n                                    const lastState = connectionState.get();\n                                    const error = chunk.event && TRPCClientError.from(chunk.event);\n                                    if (!error && lastState.state === 'connecting') {\n                                        break;\n                                    }\n                                    connectionState.next({\n                                        type: 'state',\n                                        state: 'connecting',\n                                        error\n                                    });\n                                    break;\n                                }\n                            case 'timeout':\n                                {\n                                    connectionState.next({\n                                        type: 'state',\n                                        state: 'connecting',\n                                        error: new TRPCClientError(`Timeout of ${chunk.ms}ms reached while waiting for a response`)\n                                    });\n                                }\n                        }\n                    }\n                    observer.next({\n                        result: {\n                            type: 'stopped'\n                        }\n                    });\n                    connectionState.next({\n                        type: 'state',\n                        state: 'idle',\n                        error: null\n                    });\n                    observer.complete();\n                }).catch((error)=>{\n                    observer.error(TRPCClientError.from(error));\n                });\n                return ()=>{\n                    observer.complete();\n                    ac.abort();\n                    connectionSub.unsubscribe();\n                };\n            });\n        };\n    };\n}\n/**\n * @deprecated use {@link httpSubscriptionLink} instead\n */ const unstable_httpSubscriptionLink = httpSubscriptionLink;\n\nexport { httpSubscriptionLink, unstable_httpSubscriptionLink };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2477, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/links/retryLink.mjs"],"sourcesContent":["import { observable } from '@trpc/server/observable';\nimport { inputWithTrackedEventId } from '../internals/inputWithTrackedEventId.mjs';\n\n/* istanbul ignore file -- @preserve */ // We're not actually exporting this link\n/**\n * @see https://trpc.io/docs/v11/client/links/retryLink\n */ function retryLink(opts) {\n    // initialized config\n    return ()=>{\n        // initialized in app\n        return (callOpts)=>{\n            // initialized for request\n            return observable((observer)=>{\n                let next$;\n                let callNextTimeout = undefined;\n                let lastEventId = undefined;\n                attempt(1);\n                function opWithLastEventId() {\n                    const op = callOpts.op;\n                    if (!lastEventId) {\n                        return op;\n                    }\n                    return {\n                        ...op,\n                        input: inputWithTrackedEventId(op.input, lastEventId)\n                    };\n                }\n                function attempt(attempts) {\n                    const op = opWithLastEventId();\n                    next$ = callOpts.next(op).subscribe({\n                        error (error) {\n                            const shouldRetry = opts.retry({\n                                op,\n                                attempts,\n                                error\n                            });\n                            if (!shouldRetry) {\n                                observer.error(error);\n                                return;\n                            }\n                            const delayMs = opts.retryDelayMs?.(attempts) ?? 0;\n                            if (delayMs <= 0) {\n                                attempt(attempts + 1);\n                                return;\n                            }\n                            callNextTimeout = setTimeout(()=>attempt(attempts + 1), delayMs);\n                        },\n                        next (envelope) {\n                            //\n                            if ((!envelope.result.type || envelope.result.type === 'data') && envelope.result.id) {\n                                //\n                                lastEventId = envelope.result.id;\n                            }\n                            observer.next(envelope);\n                        },\n                        complete () {\n                            observer.complete();\n                        }\n                    });\n                }\n                return ()=>{\n                    next$.unsubscribe();\n                    clearTimeout(callNextTimeout);\n                };\n            });\n        };\n    };\n}\n\nexport { retryLink };\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;;;AAEA,qCAAqC,GAAG,yCAAyC;AACjF;;CAEC,GAAG,SAAS,UAAU,IAAI;IACvB,qBAAqB;IACrB,OAAO;QACH,qBAAqB;QACrB,OAAO,CAAC;YACJ,0BAA0B;YAC1B,OAAO,CAAA,GAAA,qKAAA,CAAA,aAAU,AAAD,EAAE,CAAC;gBACf,IAAI;gBACJ,IAAI,kBAAkB;gBACtB,IAAI,cAAc;gBAClB,QAAQ;gBACR,SAAS;oBACL,MAAM,KAAK,SAAS,EAAE;oBACtB,IAAI,CAAC,aAAa;wBACd,OAAO;oBACX;oBACA,OAAO;wBACH,GAAG,EAAE;wBACL,OAAO,CAAA,GAAA,iLAAA,CAAA,0BAAuB,AAAD,EAAE,GAAG,KAAK,EAAE;oBAC7C;gBACJ;gBACA,SAAS,QAAQ,QAAQ;oBACrB,MAAM,KAAK;oBACX,QAAQ,SAAS,IAAI,CAAC,IAAI,SAAS,CAAC;wBAChC,OAAO,KAAK;4BACR,MAAM,cAAc,KAAK,KAAK,CAAC;gCAC3B;gCACA;gCACA;4BACJ;4BACA,IAAI,CAAC,aAAa;gCACd,SAAS,KAAK,CAAC;gCACf;4BACJ;4BACA,MAAM,UAAU,KAAK,YAAY,GAAG,aAAa;4BACjD,IAAI,WAAW,GAAG;gCACd,QAAQ,WAAW;gCACnB;4BACJ;4BACA,kBAAkB,WAAW,IAAI,QAAQ,WAAW,IAAI;wBAC5D;wBACA,MAAM,QAAQ;4BACV,EAAE;4BACF,IAAI,CAAC,CAAC,SAAS,MAAM,CAAC,IAAI,IAAI,SAAS,MAAM,CAAC,IAAI,KAAK,MAAM,KAAK,SAAS,MAAM,CAAC,EAAE,EAAE;gCAClF,EAAE;gCACF,cAAc,SAAS,MAAM,CAAC,EAAE;4BACpC;4BACA,SAAS,IAAI,CAAC;wBAClB;wBACA;4BACI,SAAS,QAAQ;wBACrB;oBACJ;gBACJ;gBACA,OAAO;oBACH,MAAM,WAAW;oBACjB,aAAa;gBACjB;YACJ;QACJ;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2557, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/%40trpc/client/dist/index.mjs"],"sourcesContent":["export { createTRPCUntypedClient } from './createTRPCUntypedClient.mjs';\nexport { clientCallTypeToProcedureType, createTRPCClient, createTRPCClientProxy, createTRPCClient as createTRPCProxyClient, getUntypedClient } from './createTRPCClient.mjs';\nexport { getFetch } from './getFetch.mjs';\nexport { TRPCClientError } from './TRPCClientError.mjs';\nexport { isFormData, isNonJsonSerializable, isOctetType } from './links/internals/contentTypes.mjs';\nexport { httpBatchLink } from './links/httpBatchLink.mjs';\nexport { httpBatchStreamLink, unstable_httpBatchStreamLink } from './links/httpBatchStreamLink.mjs';\nexport { httpLink } from './links/httpLink.mjs';\nexport { loggerLink } from './links/loggerLink.mjs';\nexport { splitLink } from './links/splitLink.mjs';\nexport { wsLink } from './links/wsLink/wsLink.mjs';\nexport { httpSubscriptionLink, unstable_httpSubscriptionLink } from './links/httpSubscriptionLink.mjs';\nexport { retryLink } from './links/retryLink.mjs';\nexport { TRPCUntypedClient } from './internals/TRPCUntypedClient.mjs';\nexport { createWSClient } from './links/wsLink/createWsClient.mjs';\n"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[0],"debugId":null}}]
}
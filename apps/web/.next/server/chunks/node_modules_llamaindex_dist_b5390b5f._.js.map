{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/Settings.js"],"sourcesContent":["import { Settings as CoreSettings } from \"@llamaindex/core/global\";\nimport { PromptHelper } from \"@llamaindex/core/indices\";\nimport { SentenceSplitter } from \"@llamaindex/core/node-parser\";\nimport { AsyncLocalStorage } from \"@llamaindex/env\";\n/**\n * @internal\n */ class GlobalSettings {\n    #prompt = {};\n    #promptHelper = null;\n    #nodeParser = null;\n    #chunkOverlap;\n    #promptHelperAsyncLocalStorage = new AsyncLocalStorage();\n    #nodeParserAsyncLocalStorage = new AsyncLocalStorage();\n    #chunkOverlapAsyncLocalStorage = new AsyncLocalStorage();\n    #promptAsyncLocalStorage = new AsyncLocalStorage();\n    get debug() {\n        return CoreSettings.debug;\n    }\n    get llm() {\n        return CoreSettings.llm;\n    }\n    set llm(llm) {\n        CoreSettings.llm = llm;\n    }\n    withLLM(llm, fn) {\n        return CoreSettings.withLLM(llm, fn);\n    }\n    get promptHelper() {\n        if (this.#promptHelper === null) {\n            this.#promptHelper = new PromptHelper();\n        }\n        return this.#promptHelperAsyncLocalStorage.getStore() ?? this.#promptHelper;\n    }\n    set promptHelper(promptHelper) {\n        this.#promptHelper = promptHelper;\n    }\n    withPromptHelper(promptHelper, fn) {\n        return this.#promptHelperAsyncLocalStorage.run(promptHelper, fn);\n    }\n    get embedModel() {\n        return CoreSettings.embedModel;\n    }\n    set embedModel(embedModel) {\n        CoreSettings.embedModel = embedModel;\n    }\n    withEmbedModel(embedModel, fn) {\n        return CoreSettings.withEmbedModel(embedModel, fn);\n    }\n    get nodeParser() {\n        if (this.#nodeParser === null) {\n            this.#nodeParser = new SentenceSplitter({\n                chunkSize: this.chunkSize,\n                chunkOverlap: this.chunkOverlap\n            });\n        }\n        return this.#nodeParserAsyncLocalStorage.getStore() ?? this.#nodeParser;\n    }\n    set nodeParser(nodeParser) {\n        this.#nodeParser = nodeParser;\n    }\n    withNodeParser(nodeParser, fn) {\n        return this.#nodeParserAsyncLocalStorage.run(nodeParser, fn);\n    }\n    get callbackManager() {\n        return CoreSettings.callbackManager;\n    }\n    set callbackManager(callbackManager) {\n        CoreSettings.callbackManager = callbackManager;\n    }\n    withCallbackManager(callbackManager, fn) {\n        return CoreSettings.withCallbackManager(callbackManager, fn);\n    }\n    set chunkSize(chunkSize) {\n        CoreSettings.chunkSize = chunkSize;\n    }\n    get chunkSize() {\n        return CoreSettings.chunkSize;\n    }\n    withChunkSize(chunkSize, fn) {\n        return CoreSettings.withChunkSize(chunkSize, fn);\n    }\n    get chunkOverlap() {\n        return this.#chunkOverlapAsyncLocalStorage.getStore() ?? this.#chunkOverlap;\n    }\n    set chunkOverlap(chunkOverlap) {\n        if (typeof chunkOverlap === \"number\") {\n            this.#chunkOverlap = chunkOverlap;\n        }\n    }\n    withChunkOverlap(chunkOverlap, fn) {\n        return this.#chunkOverlapAsyncLocalStorage.run(chunkOverlap, fn);\n    }\n    get prompt() {\n        return this.#promptAsyncLocalStorage.getStore() ?? this.#prompt;\n    }\n    set prompt(prompt) {\n        this.#prompt = prompt;\n    }\n    withPrompt(prompt, fn) {\n        return this.#promptAsyncLocalStorage.run(prompt, fn);\n    }\n}\nexport const Settings = new GlobalSettings();\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AAAA;;;;;AACA;;CAEC,GAAG,MAAM;IACN,CAAA,MAAO,GAAG,CAAC,EAAE;IACb,CAAA,YAAa,GAAG,KAAK;IACrB,CAAA,UAAW,GAAG,KAAK;IACnB,CAAA,YAAa,CAAC;IACd,CAAA,6BAA8B,GAAG,IAAI,+HAAA,CAAA,oBAAiB,GAAG;IACzD,CAAA,2BAA4B,GAAG,IAAI,+HAAA,CAAA,oBAAiB,GAAG;IACvD,CAAA,6BAA8B,GAAG,IAAI,+HAAA,CAAA,oBAAiB,GAAG;IACzD,CAAA,uBAAwB,GAAG,IAAI,+HAAA,CAAA,oBAAiB,GAAG;IACnD,IAAI,QAAQ;QACR,OAAO,iKAAA,CAAA,WAAY,CAAC,KAAK;IAC7B;IACA,IAAI,MAAM;QACN,OAAO,iKAAA,CAAA,WAAY,CAAC,GAAG;IAC3B;IACA,IAAI,IAAI,GAAG,EAAE;QACT,iKAAA,CAAA,WAAY,CAAC,GAAG,GAAG;IACvB;IACA,QAAQ,GAAG,EAAE,EAAE,EAAE;QACb,OAAO,iKAAA,CAAA,WAAY,CAAC,OAAO,CAAC,KAAK;IACrC;IACA,IAAI,eAAe;QACf,IAAI,IAAI,CAAC,CAAA,YAAa,KAAK,MAAM;YAC7B,IAAI,CAAC,CAAA,YAAa,GAAG,IAAI,kKAAA,CAAA,eAAY;QACzC;QACA,OAAO,IAAI,CAAC,CAAA,6BAA8B,CAAC,QAAQ,MAAM,IAAI,CAAC,CAAA,YAAa;IAC/E;IACA,IAAI,aAAa,YAAY,EAAE;QAC3B,IAAI,CAAC,CAAA,YAAa,GAAG;IACzB;IACA,iBAAiB,YAAY,EAAE,EAAE,EAAE;QAC/B,OAAO,IAAI,CAAC,CAAA,6BAA8B,CAAC,GAAG,CAAC,cAAc;IACjE;IACA,IAAI,aAAa;QACb,OAAO,iKAAA,CAAA,WAAY,CAAC,UAAU;IAClC;IACA,IAAI,WAAW,UAAU,EAAE;QACvB,iKAAA,CAAA,WAAY,CAAC,UAAU,GAAG;IAC9B;IACA,eAAe,UAAU,EAAE,EAAE,EAAE;QAC3B,OAAO,iKAAA,CAAA,WAAY,CAAC,cAAc,CAAC,YAAY;IACnD;IACA,IAAI,aAAa;QACb,IAAI,IAAI,CAAC,CAAA,UAAW,KAAK,MAAM;YAC3B,IAAI,CAAC,CAAA,UAAW,GAAG,IAAI,yKAAA,CAAA,mBAAgB,CAAC;gBACpC,WAAW,IAAI,CAAC,SAAS;gBACzB,cAAc,IAAI,CAAC,YAAY;YACnC;QACJ;QACA,OAAO,IAAI,CAAC,CAAA,2BAA4B,CAAC,QAAQ,MAAM,IAAI,CAAC,CAAA,UAAW;IAC3E;IACA,IAAI,WAAW,UAAU,EAAE;QACvB,IAAI,CAAC,CAAA,UAAW,GAAG;IACvB;IACA,eAAe,UAAU,EAAE,EAAE,EAAE;QAC3B,OAAO,IAAI,CAAC,CAAA,2BAA4B,CAAC,GAAG,CAAC,YAAY;IAC7D;IACA,IAAI,kBAAkB;QAClB,OAAO,iKAAA,CAAA,WAAY,CAAC,eAAe;IACvC;IACA,IAAI,gBAAgB,eAAe,EAAE;QACjC,iKAAA,CAAA,WAAY,CAAC,eAAe,GAAG;IACnC;IACA,oBAAoB,eAAe,EAAE,EAAE,EAAE;QACrC,OAAO,iKAAA,CAAA,WAAY,CAAC,mBAAmB,CAAC,iBAAiB;IAC7D;IACA,IAAI,UAAU,SAAS,EAAE;QACrB,iKAAA,CAAA,WAAY,CAAC,SAAS,GAAG;IAC7B;IACA,IAAI,YAAY;QACZ,OAAO,iKAAA,CAAA,WAAY,CAAC,SAAS;IACjC;IACA,cAAc,SAAS,EAAE,EAAE,EAAE;QACzB,OAAO,iKAAA,CAAA,WAAY,CAAC,aAAa,CAAC,WAAW;IACjD;IACA,IAAI,eAAe;QACf,OAAO,IAAI,CAAC,CAAA,6BAA8B,CAAC,QAAQ,MAAM,IAAI,CAAC,CAAA,YAAa;IAC/E;IACA,IAAI,aAAa,YAAY,EAAE;QAC3B,IAAI,OAAO,iBAAiB,UAAU;YAClC,IAAI,CAAC,CAAA,YAAa,GAAG;QACzB;IACJ;IACA,iBAAiB,YAAY,EAAE,EAAE,EAAE;QAC/B,OAAO,IAAI,CAAC,CAAA,6BAA8B,CAAC,GAAG,CAAC,cAAc;IACjE;IACA,IAAI,SAAS;QACT,OAAO,IAAI,CAAC,CAAA,uBAAwB,CAAC,QAAQ,MAAM,IAAI,CAAC,CAAA,MAAO;IACnE;IACA,IAAI,OAAO,MAAM,EAAE;QACf,IAAI,CAAC,CAAA,MAAO,GAAG;IACnB;IACA,WAAW,MAAM,EAAE,EAAE,EAAE;QACnB,OAAO,IAAI,CAAC,CAAA,uBAAwB,CAAC,GAAG,CAAC,QAAQ;IACrD;AACJ;AACO,MAAM,WAAW,IAAI","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 124, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/agent/contextAwareMixin.js"],"sourcesContent":["import { MetadataMode } from \"@llamaindex/core/schema\";\n/**\n * ContextAwareAgentRunner enhances the base AgentRunner with the ability to retrieve and inject relevant context\n * for each query. This allows the agent to access and utilize appropriate information from a given index or retriever,\n * providing more informed and context-specific responses to user queries.\n */ export function withContextAwareness(Base) {\n    return class ContextAwareAgent extends Base {\n        contextRetriever;\n        retrievedContext = null;\n        constructor(params){\n            super(params);\n            this.contextRetriever = params.contextRetriever;\n        }\n        async retrieveContext(query) {\n            const nodes = await this.contextRetriever.retrieve({\n                query\n            });\n            return nodes.map((node)=>node.node.getContent(MetadataMode.NONE)).join(\"\\n\");\n        }\n        async injectContext(context) {\n            const systemMessage = this.chatHistory.find((msg)=>msg.role === \"system\");\n            if (systemMessage) {\n                systemMessage.content = `${context}\\n\\n${systemMessage.content}`;\n            } else {\n                this.chatHistory.unshift({\n                    role: \"system\",\n                    content: context\n                });\n            }\n        }\n        async chat(params) {\n            const context = await this.retrieveContext(params.message);\n            await this.injectContext(context);\n            if (\"stream\" in params && params.stream === true) {\n                return super.chat(params);\n            } else {\n                return super.chat(params);\n            }\n        }\n    };\n}\n"],"names":[],"mappings":";;;AAAA;;AAKW,SAAS,qBAAqB,IAAI;IACzC,OAAO,MAAM,0BAA0B;QACnC,iBAAiB;QACjB,mBAAmB,KAAK;QACxB,YAAY,MAAM,CAAC;YACf,KAAK,CAAC;YACN,IAAI,CAAC,gBAAgB,GAAG,OAAO,gBAAgB;QACnD;QACA,MAAM,gBAAgB,KAAK,EAAE;YACzB,MAAM,QAAQ,MAAM,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC;gBAC/C;YACJ;YACA,OAAO,MAAM,GAAG,CAAC,CAAC,OAAO,KAAK,IAAI,CAAC,UAAU,CAAC,iKAAA,CAAA,eAAY,CAAC,IAAI,GAAG,IAAI,CAAC;QAC3E;QACA,MAAM,cAAc,OAAO,EAAE;YACzB,MAAM,gBAAgB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,MAAM,IAAI,IAAI,KAAK;YAChE,IAAI,eAAe;gBACf,cAAc,OAAO,GAAG,GAAG,QAAQ,IAAI,EAAE,cAAc,OAAO,EAAE;YACpE,OAAO;gBACH,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC;oBACrB,MAAM;oBACN,SAAS;gBACb;YACJ;QACJ;QACA,MAAM,KAAK,MAAM,EAAE;YACf,MAAM,UAAU,MAAM,IAAI,CAAC,eAAe,CAAC,OAAO,OAAO;YACzD,MAAM,IAAI,CAAC,aAAa,CAAC;YACzB,IAAI,YAAY,UAAU,OAAO,MAAM,KAAK,MAAM;gBAC9C,OAAO,KAAK,CAAC,KAAK;YACtB,OAAO;gBACH,OAAO,KAAK,CAAC,KAAK;YACtB;QACJ;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 171, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/agent/openai.js"],"sourcesContent":["import { OpenAIAgent } from \"@llamaindex/openai\";\nimport { withContextAwareness } from \"./contextAwareMixin.js\";\nexport const OpenAIContextAwareAgent = withContextAwareness(OpenAIAgent);\nexport * from \"@llamaindex/openai\";\n"],"names":[],"mappings":";;;AAAA;AACA;;;AACO,MAAM,0BAA0B,CAAA,GAAA,kKAAA,CAAA,uBAAoB,AAAD,EAAE,yJAAA,CAAA,cAAW","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 196, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/internal/prompt/react.js"],"sourcesContent":["export const getReACTAgentSystemHeader = (tools)=>{\n    const description = tools.map((tool)=>`- ${tool.metadata.name}: ${tool.metadata.description} with schema: ${JSON.stringify(tool.metadata.parameters)}`).join(\"\\n\");\n    const names = tools.map((tool)=>tool.metadata.name).join(\", \");\n    return `You are designed to help with a variety of tasks, from answering questions to providing summaries to other types of analyses.\n\n## Tools\nYou have access to a wide variety of tools. You are responsible for using\nthe tools in any sequence you deem appropriate to complete the task at hand.\nThis may require breaking the task into subtasks and using different tools\nto complete each subtask.\n\nYou have access to the following tools:\n${description}\n\n## Output Format\nTo answer the question, please use the following format.\n\n\"\"\"\nThought: I need to use a tool to help me answer the question.\nAction: tool name (one of ${names}) if using a tool.\nAction Input: the input to the tool, in a JSON format representing the kwargs (e.g. {{\"input\": \"hello world\", \"num_beams\": 5}})\n\"\"\"\n\nPlease ALWAYS start with a Thought.\n\nPlease use a valid JSON format for the Action Input. Do NOT do this {{'input': 'hello world', 'num_beams': 5}}.\n\nIf this format is used, the user will respond in the following format:\n\n\"\"\"\"\nObservation: tool response\n\"\"\"\"\n\nYou should keep repeating the above format until you have enough information\nto answer the question without using any more tools. At that point, you MUST respond\nin the one of the following two formats:\n\n\"\"\"\"\nThought: I can answer without using any more tools.\nAnswer: [your answer here]\n\"\"\"\"\n\n\"\"\"\"\nThought: I cannot answer the question with the provided tools.\nAnswer: Sorry, I cannot answer your query.\n\"\"\"\"\n\n## Current Conversation\nBelow is the current conversation consisting of interleaving human and assistant messages.`;\n};\n"],"names":[],"mappings":";;;AAAO,MAAM,4BAA4B,CAAC;IACtC,MAAM,cAAc,MAAM,GAAG,CAAC,CAAC,OAAO,CAAC,EAAE,EAAE,KAAK,QAAQ,CAAC,IAAI,CAAC,EAAE,EAAE,KAAK,QAAQ,CAAC,WAAW,CAAC,cAAc,EAAE,KAAK,SAAS,CAAC,KAAK,QAAQ,CAAC,UAAU,GAAG,EAAE,IAAI,CAAC;IAC7J,MAAM,QAAQ,MAAM,GAAG,CAAC,CAAC,OAAO,KAAK,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC;IACzD,OAAO,CAAC;;;;;;;;;AASZ,EAAE,YAAY;;;;;;;0BAOY,EAAE,MAAM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0FA6BwD,CAAC;AAC3F","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 255, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/internal/utils.js"],"sourcesContent":["import { fs } from \"@llamaindex/env\";\nimport { filetypemime } from \"magic-bytes.js\";\nexport const isAsyncIterable = (obj)=>{\n    return obj != null && typeof obj === \"object\" && Symbol.asyncIterator in obj;\n};\nexport const isReadableStream = (obj)=>{\n    return obj instanceof ReadableStream;\n};\nexport const isIterable = (obj)=>{\n    return obj != null && typeof obj === \"object\" && Symbol.iterator in obj;\n};\nasync function blobToDataUrl(input) {\n    const buffer = Buffer.from(await input.arrayBuffer());\n    const mimes = filetypemime(buffer);\n    if (mimes.length < 1) {\n        throw new Error(\"Unsupported image type\");\n    }\n    return \"data:\" + mimes[0] + \";base64,\" + buffer.toString(\"base64\");\n}\nexport async function imageToString(input) {\n    if (input instanceof Blob) {\n        // if the image is a Blob, convert it to a base64 data URL\n        return await blobToDataUrl(input);\n    } else if (typeof input === \"string\") {\n        return input;\n    } else if (input instanceof URL) {\n        return input.toString();\n    } else {\n        throw new Error(`Unsupported input type: ${typeof input}`);\n    }\n}\nexport function stringToImage(input) {\n    if (input.startsWith(\"data:\")) {\n        // if the input is a base64 data URL, convert it back to a Blob\n        const base64Data = input.split(\",\")[1];\n        const byteArray = Buffer.from(base64Data, \"base64\");\n        return new Blob([\n            byteArray\n        ]);\n    } else if (input.startsWith(\"http://\") || input.startsWith(\"https://\")) {\n        return new URL(input);\n    } else {\n        return input;\n    }\n}\nexport async function imageToDataUrl(input) {\n    // first ensure, that the input is a Blob\n    if (input instanceof URL && input.protocol === \"file:\" || typeof input === \"string\") {\n        // string or file URL\n        const dataBuffer = await fs.readFile(input instanceof URL ? input.pathname : input);\n        input = new Blob([\n            dataBuffer\n        ]);\n    } else if (!(input instanceof Blob)) {\n        if (input instanceof URL) {\n            throw new Error(`Unsupported URL with protocol: ${input.protocol}`);\n        } else if (input instanceof Uint8Array) {\n            input = new Blob([\n                input\n            ]); // convert Uint8Array to Blob\n        } else {\n            throw new Error(`Unsupported input type: ${typeof input}`);\n        }\n    }\n    return await blobToDataUrl(input);\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AACA;;;AACO,MAAM,kBAAkB,CAAC;IAC5B,OAAO,OAAO,QAAQ,OAAO,QAAQ,YAAY,OAAO,aAAa,IAAI;AAC7E;AACO,MAAM,mBAAmB,CAAC;IAC7B,OAAO,eAAe;AAC1B;AACO,MAAM,aAAa,CAAC;IACvB,OAAO,OAAO,QAAQ,OAAO,QAAQ,YAAY,OAAO,QAAQ,IAAI;AACxE;AACA,eAAe,cAAc,KAAK;IAC9B,MAAM,SAAS,OAAO,IAAI,CAAC,MAAM,MAAM,WAAW;IAClD,MAAM,QAAQ,CAAA,GAAA,uJAAA,CAAA,eAAY,AAAD,EAAE;IAC3B,IAAI,MAAM,MAAM,GAAG,GAAG;QAClB,MAAM,IAAI,MAAM;IACpB;IACA,OAAO,UAAU,KAAK,CAAC,EAAE,GAAG,aAAa,OAAO,QAAQ,CAAC;AAC7D;AACO,eAAe,cAAc,KAAK;IACrC,IAAI,iBAAiB,MAAM;QACvB,0DAA0D;QAC1D,OAAO,MAAM,cAAc;IAC/B,OAAO,IAAI,OAAO,UAAU,UAAU;QAClC,OAAO;IACX,OAAO,IAAI,iBAAiB,KAAK;QAC7B,OAAO,MAAM,QAAQ;IACzB,OAAO;QACH,MAAM,IAAI,MAAM,CAAC,wBAAwB,EAAE,OAAO,OAAO;IAC7D;AACJ;AACO,SAAS,cAAc,KAAK;IAC/B,IAAI,MAAM,UAAU,CAAC,UAAU;QAC3B,+DAA+D;QAC/D,MAAM,aAAa,MAAM,KAAK,CAAC,IAAI,CAAC,EAAE;QACtC,MAAM,YAAY,OAAO,IAAI,CAAC,YAAY;QAC1C,OAAO,IAAI,KAAK;YACZ;SACH;IACL,OAAO,IAAI,MAAM,UAAU,CAAC,cAAc,MAAM,UAAU,CAAC,aAAa;QACpE,OAAO,IAAI,IAAI;IACnB,OAAO;QACH,OAAO;IACX;AACJ;AACO,eAAe,eAAe,KAAK;IACtC,yCAAyC;IACzC,IAAI,iBAAiB,OAAO,MAAM,QAAQ,KAAK,WAAW,OAAO,UAAU,UAAU;QACjF,qBAAqB;QACrB,MAAM,aAAa,MAAM,sKAAA,CAAA,KAAE,CAAC,QAAQ,CAAC,iBAAiB,MAAM,MAAM,QAAQ,GAAG;QAC7E,QAAQ,IAAI,KAAK;YACb;SACH;IACL,OAAO,IAAI,CAAC,CAAC,iBAAiB,IAAI,GAAG;QACjC,IAAI,iBAAiB,KAAK;YACtB,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,MAAM,QAAQ,EAAE;QACtE,OAAO,IAAI,iBAAiB,YAAY;YACpC,QAAQ,IAAI,KAAK;gBACb;aACH,GAAG,6BAA6B;QACrC,OAAO;YACH,MAAM,IAAI,MAAM,CAAC,wBAAwB,EAAE,OAAO,OAAO;QAC7D;IACJ;IACA,OAAO,MAAM,cAAc;AAC/B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 338, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/agent/react.js"],"sourcesContent":["import { AgentRunner, AgentWorker, callTool, consumeAsyncIterable, createReadableStream, validateAgentParams } from \"@llamaindex/core/agent\";\nimport { extractText, stringifyJSONToMessageContent } from \"@llamaindex/core/utils\";\nimport { randomUUID } from \"@llamaindex/env\";\nimport { getReACTAgentSystemHeader } from \"../internal/prompt/react.js\";\nimport { isAsyncIterable } from \"../internal/utils.js\";\nimport { Settings } from \"../Settings.js\";\nfunction reasonFormatter(reason) {\n    switch(reason.type){\n        case \"observation\":\n            return `Observation: ${stringifyJSONToMessageContent(reason.observation)}`;\n        case \"action\":\n            return `Thought: ${reason.thought}\\nAction: ${reason.action}\\nInput: ${stringifyJSONToMessageContent(reason.input)}`;\n        case \"response\":\n            {\n                return `Thought: ${reason.thought}\\nAnswer: ${extractText(reason.response.message.content)}`;\n            }\n    }\n}\nfunction extractJsonStr(text) {\n    const pattern = /\\{.*\\}/s;\n    const match = text.match(pattern);\n    if (!match) {\n        throw new SyntaxError(`Could not extract json string from output: ${text}`);\n    }\n    return match[0];\n}\nfunction extractFinalResponse(inputText) {\n    const pattern = /\\s*Thought:(.*?)Answer:(.*?)$/s;\n    const match = inputText.match(pattern);\n    if (!match) {\n        throw new Error(`Could not extract final answer from input text: ${inputText}`);\n    }\n    const thought = match[1].trim();\n    const answer = match[2].trim();\n    return [\n        thought,\n        answer\n    ];\n}\nfunction extractToolUse(inputText) {\n    const pattern = /\\s*Thought: (.*?)\\nAction: ([a-zA-Z0-9_]+).*?\\.*[Input:]*.*?(\\{.*?\\})/s;\n    const match = inputText.match(pattern);\n    if (!match) {\n        throw new Error(`Could not extract tool use from input text: \"${inputText}\"`);\n    }\n    const thought = match[1].trim();\n    const action = match[2].trim();\n    const actionInput = match[3].trim();\n    return [\n        thought,\n        action,\n        actionInput\n    ];\n}\nfunction actionInputParser(jsonStr) {\n    const processedString = jsonStr.replace(/(?<!\\w)'|'(?!\\w)/g, '\"');\n    const pattern = /\"(\\w+)\":\\s*\"([^\"]*)\"/g;\n    const matches = [\n        ...processedString.matchAll(pattern)\n    ];\n    return Object.fromEntries(matches);\n}\nconst reACTOutputParser = async (output, onResolveType)=>{\n    let reason = null;\n    if (isAsyncIterable(output)) {\n        const [peakStream, finalStream] = createReadableStream(output).tee();\n        const reader = peakStream.getReader();\n        let type = null;\n        let content = \"\";\n        for(;;){\n            const { done, value } = await reader.read();\n            if (done) {\n                break;\n            }\n            content += value.delta;\n            if (content.includes(\"Action:\")) {\n                type = \"action\";\n            } else if (content.includes(\"Answer:\")) {\n                type = \"answer\";\n            }\n        }\n        if (type === null) {\n            // `Thought:` is always present at the beginning of the output.\n            type = \"thought\";\n        }\n        reader.releaseLock();\n        if (!type) {\n            throw new Error(\"Could not determine type of output\");\n        }\n        onResolveType(type, finalStream);\n        // step 2: do the parsing from content\n        switch(type){\n            case \"action\":\n                {\n                    // have to consume the stream to get the full content\n                    const response = await consumeAsyncIterable(peakStream, content);\n                    const [thought, action, input] = extractToolUse(response.content);\n                    const jsonStr = extractJsonStr(input);\n                    let json;\n                    try {\n                        json = JSON.parse(jsonStr);\n                    } catch (e) {\n                        json = actionInputParser(jsonStr);\n                    }\n                    reason = {\n                        type: \"action\",\n                        thought,\n                        action,\n                        input: json\n                    };\n                    break;\n                }\n            case \"thought\":\n                {\n                    const thought = \"(Implicit) I can answer without any more tools!\";\n                    const response = await consumeAsyncIterable(peakStream, content);\n                    reason = {\n                        type: \"response\",\n                        thought,\n                        response: {\n                            raw: peakStream,\n                            message: response\n                        }\n                    };\n                    break;\n                }\n            case \"answer\":\n                {\n                    const response = await consumeAsyncIterable(peakStream, content);\n                    const [thought, answer] = extractFinalResponse(response.content);\n                    reason = {\n                        type: \"response\",\n                        thought,\n                        response: {\n                            raw: response,\n                            message: {\n                                role: \"assistant\",\n                                content: answer\n                            }\n                        }\n                    };\n                    break;\n                }\n            default:\n                {\n                    throw new Error(`Invalid type: ${type}`);\n                }\n        }\n    } else {\n        const content = extractText(output.message.content);\n        const type = content.includes(\"Answer:\") ? \"answer\" : content.includes(\"Action:\") ? \"action\" : \"thought\";\n        onResolveType(type, output);\n        // step 2: do the parsing from content\n        switch(type){\n            case \"action\":\n                {\n                    const [thought, action, input] = extractToolUse(content);\n                    const jsonStr = extractJsonStr(input);\n                    let json;\n                    try {\n                        json = JSON.parse(jsonStr);\n                    } catch (e) {\n                        json = actionInputParser(jsonStr);\n                    }\n                    reason = {\n                        type: \"action\",\n                        thought,\n                        action,\n                        input: json\n                    };\n                    break;\n                }\n            case \"thought\":\n                {\n                    const thought = \"(Implicit) I can answer without any more tools!\";\n                    reason = {\n                        type: \"response\",\n                        thought,\n                        response: {\n                            raw: output,\n                            message: {\n                                role: \"assistant\",\n                                content: extractText(output.message.content)\n                            }\n                        }\n                    };\n                    break;\n                }\n            case \"answer\":\n                {\n                    const [thought, answer] = extractFinalResponse(content);\n                    reason = {\n                        type: \"response\",\n                        thought,\n                        response: {\n                            raw: output,\n                            message: {\n                                role: \"assistant\",\n                                content: answer\n                            }\n                        }\n                    };\n                    break;\n                }\n            default:\n                {\n                    throw new Error(`Invalid type: ${type}`);\n                }\n        }\n    }\n    if (reason === null) {\n        throw new TypeError(\"Reason is null\");\n    }\n    return reason;\n};\nconst chatFormatter = async (tools, messages, currentReasons)=>{\n    const header = getReACTAgentSystemHeader(tools);\n    const reasonMessages = [];\n    for (const reason of currentReasons){\n        const response = await reasonFormatter(reason);\n        reasonMessages.push({\n            role: reason.type === \"observation\" ? \"user\" : \"assistant\",\n            content: response\n        });\n    }\n    return [\n        {\n            role: \"system\",\n            content: header\n        },\n        ...messages,\n        ...reasonMessages\n    ];\n};\nexport class ReACTAgentWorker extends AgentWorker {\n    taskHandler = ReActAgent.taskHandler;\n}\nexport class ReActAgent extends AgentRunner {\n    constructor(params){\n        validateAgentParams(params);\n        super({\n            llm: params.llm ?? Settings.llm,\n            chatHistory: params.chatHistory ?? [],\n            runner: new ReACTAgentWorker(),\n            systemPrompt: params.systemPrompt ?? null,\n            tools: \"tools\" in params ? params.tools : params.toolRetriever.retrieve.bind(params.toolRetriever),\n            verbose: params.verbose ?? false\n        });\n    }\n    createStore() {\n        return {\n            reasons: []\n        };\n    }\n    static taskHandler = async (step, enqueueOutput)=>{\n        const { llm, stream, getTools } = step.context;\n        const lastMessage = step.context.store.messages.at(-1).content;\n        const tools = await getTools(lastMessage);\n        const messages = await chatFormatter(tools, step.context.store.messages, step.context.store.reasons);\n        const response = await llm.chat({\n            // @ts-expect-error boolean\n            stream,\n            messages\n        });\n        const reason = await reACTOutputParser(response, (type, response)=>{\n            enqueueOutput({\n                taskStep: step,\n                output: response,\n                isLast: type !== \"action\"\n            });\n        });\n        step.context.logger.log(\"current reason: %O\", reason);\n        step.context.store.reasons = [\n            ...step.context.store.reasons,\n            reason\n        ];\n        if (reason.type === \"action\") {\n            const tool = tools.find((tool)=>tool.metadata.name === reason.action);\n            const toolOutput = await callTool(tool, {\n                id: randomUUID(),\n                input: reason.input,\n                name: reason.action\n            }, step.context.logger);\n            step.context.store.reasons = [\n                ...step.context.store.reasons,\n                {\n                    type: \"observation\",\n                    observation: toolOutput.output\n                }\n            ];\n        }\n    };\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 648, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/agent/index.js"],"sourcesContent":["export * from \"@llamaindex/core/agent\";\nexport { OpenAIContextAwareAgent } from \"./openai.js\";\nexport { ReACTAgentWorker, ReActAgent } from \"./react.js\"; // todo: ParallelAgent\n // todo: CustomAgent\n // todo: ReactMultiModal\n"],"names":[],"mappings":";AAAA;AACA;AACA,wQAA2D,sBAAsB;CAChF,oBAAoB;CACpB,wBAAwB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 674, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/cloud/utils.js"],"sourcesContent":["import { client, listProjectsApiV1ProjectsGet, searchPipelinesApiV1PipelinesGet } from \"@llamaindex/cloud/api\";\nimport { DEFAULT_BASE_URL } from \"@llamaindex/core/global\";\nimport { getEnv } from \"@llamaindex/env\";\nfunction getBaseUrl(baseUrl) {\n    return baseUrl ?? getEnv(\"LLAMA_CLOUD_BASE_URL\") ?? DEFAULT_BASE_URL;\n}\nexport function getAppBaseUrl() {\n    return client.getConfig().baseUrl?.replace(/api\\./, \"\") ?? \"\";\n}\n// fixme: refactor this to init at the top level or module level\nlet initOnce = false;\nexport function initService({ apiKey, baseUrl } = {}) {\n    if (initOnce) {\n        return;\n    }\n    initOnce = true;\n    client.setConfig({\n        baseUrl: getBaseUrl(baseUrl),\n        throwOnError: true\n    });\n    const token = apiKey ?? getEnv(\"LLAMA_CLOUD_API_KEY\");\n    client.interceptors.request.use((request)=>{\n        request.headers.set(\"Authorization\", `Bearer ${token}`);\n        return request;\n    });\n    client.interceptors.error.use((error)=>{\n        throw new Error(`LlamaCloud API request failed. Error details: ${JSON.stringify(error)}`);\n    });\n    if (!token) {\n        throw new Error(\"API Key is required for LlamaCloudIndex. Please pass the apiKey parameter\");\n    }\n}\nexport async function getProjectId(projectName, organizationId) {\n    const { data: projects } = await listProjectsApiV1ProjectsGet({\n        query: {\n            project_name: projectName,\n            organization_id: organizationId ?? null\n        },\n        throwOnError: true\n    });\n    if (projects.length === 0) {\n        throw new Error(`Unknown project name ${projectName}. Please confirm a managed project with this name exists.`);\n    } else if (projects.length > 1) {\n        throw new Error(`Multiple projects found with name ${projectName}. Please specify organization_id.`);\n    }\n    const project = projects[0];\n    if (!project.id) {\n        throw new Error(`No project found with name ${projectName}`);\n    }\n    return project.id;\n}\nexport async function getPipelineId(name, projectName, organizationId) {\n    const { data: pipelines } = await searchPipelinesApiV1PipelinesGet({\n        query: {\n            project_id: await getProjectId(projectName, organizationId),\n            pipeline_name: name\n        },\n        throwOnError: true\n    });\n    if (pipelines.length === 0 || !pipelines[0].id) {\n        throw new Error(`No pipeline found with name ${name} in project ${projectName}`);\n    }\n    return pipelines[0].id;\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AAAA;;;;AACA,SAAS,WAAW,OAAO;IACvB,OAAO,WAAW,CAAA,GAAA,sKAAA,CAAA,SAAM,AAAD,EAAE,2BAA2B,iKAAA,CAAA,mBAAgB;AACxE;AACO,SAAS;IACZ,OAAO,+JAAA,CAAA,SAAM,CAAC,SAAS,GAAG,OAAO,EAAE,QAAQ,SAAS,OAAO;AAC/D;AACA,gEAAgE;AAChE,IAAI,WAAW;AACR,SAAS,YAAY,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,CAAC,CAAC;IAChD,IAAI,UAAU;QACV;IACJ;IACA,WAAW;IACX,+JAAA,CAAA,SAAM,CAAC,SAAS,CAAC;QACb,SAAS,WAAW;QACpB,cAAc;IAClB;IACA,MAAM,QAAQ,UAAU,CAAA,GAAA,sKAAA,CAAA,SAAM,AAAD,EAAE;IAC/B,+JAAA,CAAA,SAAM,CAAC,YAAY,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QAC7B,QAAQ,OAAO,CAAC,GAAG,CAAC,iBAAiB,CAAC,OAAO,EAAE,OAAO;QACtD,OAAO;IACX;IACA,+JAAA,CAAA,SAAM,CAAC,YAAY,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAC3B,MAAM,IAAI,MAAM,CAAC,8CAA8C,EAAE,KAAK,SAAS,CAAC,QAAQ;IAC5F;IACA,IAAI,CAAC,OAAO;QACR,MAAM,IAAI,MAAM;IACpB;AACJ;AACO,eAAe,aAAa,WAAW,EAAE,cAAc;IAC1D,MAAM,EAAE,MAAM,QAAQ,EAAE,GAAG,MAAM,CAAA,GAAA,+JAAA,CAAA,+BAA4B,AAAD,EAAE;QAC1D,OAAO;YACH,cAAc;YACd,iBAAiB,kBAAkB;QACvC;QACA,cAAc;IAClB;IACA,IAAI,SAAS,MAAM,KAAK,GAAG;QACvB,MAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,YAAY,yDAAyD,CAAC;IAClH,OAAO,IAAI,SAAS,MAAM,GAAG,GAAG;QAC5B,MAAM,IAAI,MAAM,CAAC,kCAAkC,EAAE,YAAY,iCAAiC,CAAC;IACvG;IACA,MAAM,UAAU,QAAQ,CAAC,EAAE;IAC3B,IAAI,CAAC,QAAQ,EAAE,EAAE;QACb,MAAM,IAAI,MAAM,CAAC,2BAA2B,EAAE,aAAa;IAC/D;IACA,OAAO,QAAQ,EAAE;AACrB;AACO,eAAe,cAAc,IAAI,EAAE,WAAW,EAAE,cAAc;IACjE,MAAM,EAAE,MAAM,SAAS,EAAE,GAAG,MAAM,CAAA,GAAA,+JAAA,CAAA,mCAAgC,AAAD,EAAE;QAC/D,OAAO;YACH,YAAY,MAAM,aAAa,aAAa;YAC5C,eAAe;QACnB;QACA,cAAc;IAClB;IACA,IAAI,UAAU,MAAM,KAAK,KAAK,CAAC,SAAS,CAAC,EAAE,CAAC,EAAE,EAAE;QAC5C,MAAM,IAAI,MAAM,CAAC,4BAA4B,EAAE,KAAK,YAAY,EAAE,aAAa;IACnF;IACA,OAAO,SAAS,CAAC,EAAE,CAAC,EAAE;AAC1B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 754, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/cloud/LLamaCloudFileService.js"],"sourcesContent":["import { addFilesToPipelineApiV1PipelinesPipelineIdFilesPut, getPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGet, listPipelineFilesApiV1PipelinesPipelineIdFilesGet, listProjectsApiV1ProjectsGet, readFileContentApiV1FilesIdContentGet, searchPipelinesApiV1PipelinesGet, uploadFileApiV1FilesPost } from \"@llamaindex/cloud/api\";\nimport { initService } from \"./utils.js\";\nexport class LLamaCloudFileService {\n    /**\n   * Get list of projects, each project contains a list of pipelines\n   */ static async getAllProjectsWithPipelines() {\n        initService();\n        try {\n            const { data: projects } = await listProjectsApiV1ProjectsGet({\n                throwOnError: true\n            });\n            const { data: pipelines } = await searchPipelinesApiV1PipelinesGet({\n                throwOnError: true\n            });\n            return projects.map((project)=>({\n                    ...project,\n                    pipelines: pipelines.filter((p)=>p.project_id === project.id)\n                }));\n        } catch (error) {\n            console.error(\"Error listing projects and pipelines:\", error);\n            return [];\n        }\n    }\n    /**\n   * Upload a file to a pipeline in LlamaCloud\n   */ static async addFileToPipeline(projectId, pipelineId, uploadFile, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    customMetadata = {}) {\n        initService();\n        const { data: file } = await uploadFileApiV1FilesPost({\n            query: {\n                project_id: projectId\n            },\n            body: {\n                upload_file: uploadFile\n            },\n            throwOnError: true\n        });\n        const files = [\n            {\n                file_id: file.id,\n                custom_metadata: {\n                    file_id: file.id,\n                    ...customMetadata\n                }\n            }\n        ];\n        await addFilesToPipelineApiV1PipelinesPipelineIdFilesPut({\n            path: {\n                pipeline_id: pipelineId\n            },\n            body: files\n        });\n        // Wait 2s for the file to be processed\n        const maxAttempts = 20;\n        let attempt = 0;\n        while(attempt < maxAttempts){\n            const { data: result } = await getPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGet({\n                path: {\n                    pipeline_id: pipelineId,\n                    file_id: file.id\n                },\n                throwOnError: true\n            });\n            if (result.status === \"ERROR\") {\n                throw new Error(`File processing failed: ${JSON.stringify(result)}`);\n            }\n            if (result.status === \"SUCCESS\") {\n                // File is ingested - return the file id\n                return file.id;\n            }\n            attempt += 1;\n            await new Promise((resolve)=>setTimeout(resolve, 100)); // Sleep for 100ms\n        }\n        throw new Error(`File processing did not complete after ${maxAttempts} attempts. Check your LlamaCloud index at https://cloud.llamaindex.ai/project/${projectId}/deploy/${pipelineId} for more details.`);\n    }\n    /**\n   * Get download URL for a file in LlamaCloud\n   */ static async getFileUrl(pipelineId, filename) {\n        initService();\n        const { data: allPipelineFiles } = await listPipelineFilesApiV1PipelinesPipelineIdFilesGet({\n            path: {\n                pipeline_id: pipelineId\n            },\n            throwOnError: true\n        });\n        const file = allPipelineFiles.find((file)=>file.name === filename);\n        if (!file?.file_id) return null;\n        const { data: fileContent } = await readFileContentApiV1FilesIdContentGet({\n            path: {\n                id: file.file_id\n            },\n            query: {\n                project_id: file.project_id\n            },\n            throwOnError: true\n        });\n        return fileContent.url;\n    }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AACO,MAAM;IACT;;GAED,GAAG,aAAa,8BAA8B;QACzC,CAAA,GAAA,sJAAA,CAAA,cAAW,AAAD;QACV,IAAI;YACA,MAAM,EAAE,MAAM,QAAQ,EAAE,GAAG,MAAM,CAAA,GAAA,+JAAA,CAAA,+BAA4B,AAAD,EAAE;gBAC1D,cAAc;YAClB;YACA,MAAM,EAAE,MAAM,SAAS,EAAE,GAAG,MAAM,CAAA,GAAA,+JAAA,CAAA,mCAAgC,AAAD,EAAE;gBAC/D,cAAc;YAClB;YACA,OAAO,SAAS,GAAG,CAAC,CAAC,UAAU,CAAC;oBACxB,GAAG,OAAO;oBACV,WAAW,UAAU,MAAM,CAAC,CAAC,IAAI,EAAE,UAAU,KAAK,QAAQ,EAAE;gBAChE,CAAC;QACT,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,yCAAyC;YACvD,OAAO,EAAE;QACb;IACJ;IACA;;GAED,GAAG,aAAa,kBAAkB,SAAS,EAAE,UAAU,EAAE,UAAU,EAClE,iBAAiB,CAAC,CAAC,EAAE;QACjB,CAAA,GAAA,sJAAA,CAAA,cAAW,AAAD;QACV,MAAM,EAAE,MAAM,IAAI,EAAE,GAAG,MAAM,CAAA,GAAA,+JAAA,CAAA,2BAAwB,AAAD,EAAE;YAClD,OAAO;gBACH,YAAY;YAChB;YACA,MAAM;gBACF,aAAa;YACjB;YACA,cAAc;QAClB;QACA,MAAM,QAAQ;YACV;gBACI,SAAS,KAAK,EAAE;gBAChB,iBAAiB;oBACb,SAAS,KAAK,EAAE;oBAChB,GAAG,cAAc;gBACrB;YACJ;SACH;QACD,MAAM,CAAA,GAAA,+JAAA,CAAA,qDAAkD,AAAD,EAAE;YACrD,MAAM;gBACF,aAAa;YACjB;YACA,MAAM;QACV;QACA,uCAAuC;QACvC,MAAM,cAAc;QACpB,IAAI,UAAU;QACd,MAAM,UAAU,YAAY;YACxB,MAAM,EAAE,MAAM,MAAM,EAAE,GAAG,MAAM,CAAA,GAAA,+JAAA,CAAA,oEAAiE,AAAD,EAAE;gBAC7F,MAAM;oBACF,aAAa;oBACb,SAAS,KAAK,EAAE;gBACpB;gBACA,cAAc;YAClB;YACA,IAAI,OAAO,MAAM,KAAK,SAAS;gBAC3B,MAAM,IAAI,MAAM,CAAC,wBAAwB,EAAE,KAAK,SAAS,CAAC,SAAS;YACvE;YACA,IAAI,OAAO,MAAM,KAAK,WAAW;gBAC7B,wCAAwC;gBACxC,OAAO,KAAK,EAAE;YAClB;YACA,WAAW;YACX,MAAM,IAAI,QAAQ,CAAC,UAAU,WAAW,SAAS,OAAO,kBAAkB;QAC9E;QACA,MAAM,IAAI,MAAM,CAAC,uCAAuC,EAAE,YAAY,8EAA8E,EAAE,UAAU,QAAQ,EAAE,WAAW,kBAAkB,CAAC;IAC5M;IACA;;GAED,GAAG,aAAa,WAAW,UAAU,EAAE,QAAQ,EAAE;QAC5C,CAAA,GAAA,sJAAA,CAAA,cAAW,AAAD;QACV,MAAM,EAAE,MAAM,gBAAgB,EAAE,GAAG,MAAM,CAAA,GAAA,+JAAA,CAAA,oDAAiD,AAAD,EAAE;YACvF,MAAM;gBACF,aAAa;YACjB;YACA,cAAc;QAClB;QACA,MAAM,OAAO,iBAAiB,IAAI,CAAC,CAAC,OAAO,KAAK,IAAI,KAAK;QACzD,IAAI,CAAC,MAAM,SAAS,OAAO;QAC3B,MAAM,EAAE,MAAM,WAAW,EAAE,GAAG,MAAM,CAAA,GAAA,+JAAA,CAAA,wCAAqC,AAAD,EAAE;YACtE,MAAM;gBACF,IAAI,KAAK,OAAO;YACpB;YACA,OAAO;gBACH,YAAY,KAAK,UAAU;YAC/B;YACA,cAAc;QAClB;QACA,OAAO,YAAY,GAAG;IAC1B;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 863, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/engines/query/RetrieverQueryEngine.js"],"sourcesContent":["/**\n * todo: this file should be removed in the major release\n */ export { RetrieverQueryEngine } from \"@llamaindex/core/query-engine\";\n"],"names":[],"mappings":"AAAA;;CAEC;AAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 883, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/cloud/LlamaCloudRetriever.js"],"sourcesContent":["import { runSearchApiV1PipelinesPipelineIdRetrievePost } from \"@llamaindex/cloud/api\";\nimport { DEFAULT_PROJECT_NAME } from \"@llamaindex/core/global\";\nimport { BaseRetriever } from \"@llamaindex/core/retriever\";\nimport { jsonToNode, ObjectType } from \"@llamaindex/core/schema\";\nimport { extractText } from \"@llamaindex/core/utils\";\nimport { getPipelineId, initService } from \"./utils.js\";\nexport class LlamaCloudRetriever extends BaseRetriever {\n    clientParams;\n    retrieveParams;\n    organizationId;\n    projectName = DEFAULT_PROJECT_NAME;\n    pipelineName;\n    resultNodesToNodeWithScore(nodes) {\n        return nodes.map((node)=>{\n            const textNode = jsonToNode(node.node, ObjectType.TEXT);\n            textNode.metadata = {\n                ...textNode.metadata,\n                ...node.node.extra_info\n            };\n            return {\n                // Currently LlamaCloud only supports text nodes\n                node: textNode,\n                score: node.score ?? undefined\n            };\n        });\n    }\n    // LlamaCloud expects null values for filters, but LlamaIndexTS uses undefined for empty values\n    // This function converts the undefined values to null\n    convertFilter(filters) {\n        if (!filters) return null;\n        const processFilter = (filter)=>{\n            if (\"filters\" in filter) {\n                // type MetadataFilters\n                return {\n                    ...filter,\n                    filters: filter.filters.map(processFilter)\n                };\n            }\n            return {\n                ...filter,\n                value: filter.value ?? null\n            };\n        };\n        return {\n            ...filters,\n            filters: filters.filters.map(processFilter)\n        };\n    }\n    constructor(params){\n        super();\n        this.clientParams = {\n            apiKey: params.apiKey,\n            baseUrl: params.baseUrl\n        };\n        initService(this.clientParams);\n        this.retrieveParams = params;\n        this.pipelineName = params.name;\n        if (params.projectName) {\n            this.projectName = params.projectName;\n        }\n        if (params.organizationId) {\n            this.organizationId = params.organizationId;\n        }\n    }\n    async _retrieve(query) {\n        const pipelineId = await getPipelineId(this.pipelineName, this.projectName, this.organizationId);\n        const filters = this.convertFilter(this.retrieveParams.filters);\n        const { data: results } = await runSearchApiV1PipelinesPipelineIdRetrievePost({\n            throwOnError: true,\n            path: {\n                pipeline_id: pipelineId\n            },\n            body: {\n                ...this.retrieveParams,\n                query: extractText(query),\n                search_filters: filters,\n                dense_similarity_top_k: this.retrieveParams.similarityTopK\n            }\n        });\n        return this.resultNodesToNodeWithScore(results.retrieval_nodes);\n    }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AACO,MAAM,4BAA4B,oKAAA,CAAA,gBAAa;IAClD,aAAa;IACb,eAAe;IACf,eAAe;IACf,cAAc,iKAAA,CAAA,uBAAoB,CAAC;IACnC,aAAa;IACb,2BAA2B,KAAK,EAAE;QAC9B,OAAO,MAAM,GAAG,CAAC,CAAC;YACd,MAAM,WAAW,CAAA,GAAA,iKAAA,CAAA,aAAU,AAAD,EAAE,KAAK,IAAI,EAAE,iKAAA,CAAA,aAAU,CAAC,IAAI;YACtD,SAAS,QAAQ,GAAG;gBAChB,GAAG,SAAS,QAAQ;gBACpB,GAAG,KAAK,IAAI,CAAC,UAAU;YAC3B;YACA,OAAO;gBACH,gDAAgD;gBAChD,MAAM;gBACN,OAAO,KAAK,KAAK,IAAI;YACzB;QACJ;IACJ;IACA,+FAA+F;IAC/F,sDAAsD;IACtD,cAAc,OAAO,EAAE;QACnB,IAAI,CAAC,SAAS,OAAO;QACrB,MAAM,gBAAgB,CAAC;YACnB,IAAI,aAAa,QAAQ;gBACrB,uBAAuB;gBACvB,OAAO;oBACH,GAAG,MAAM;oBACT,SAAS,OAAO,OAAO,CAAC,GAAG,CAAC;gBAChC;YACJ;YACA,OAAO;gBACH,GAAG,MAAM;gBACT,OAAO,OAAO,KAAK,IAAI;YAC3B;QACJ;QACA,OAAO;YACH,GAAG,OAAO;YACV,SAAS,QAAQ,OAAO,CAAC,GAAG,CAAC;QACjC;IACJ;IACA,YAAY,MAAM,CAAC;QACf,KAAK;QACL,IAAI,CAAC,YAAY,GAAG;YAChB,QAAQ,OAAO,MAAM;YACrB,SAAS,OAAO,OAAO;QAC3B;QACA,CAAA,GAAA,sJAAA,CAAA,cAAW,AAAD,EAAE,IAAI,CAAC,YAAY;QAC7B,IAAI,CAAC,cAAc,GAAG;QACtB,IAAI,CAAC,YAAY,GAAG,OAAO,IAAI;QAC/B,IAAI,OAAO,WAAW,EAAE;YACpB,IAAI,CAAC,WAAW,GAAG,OAAO,WAAW;QACzC;QACA,IAAI,OAAO,cAAc,EAAE;YACvB,IAAI,CAAC,cAAc,GAAG,OAAO,cAAc;QAC/C;IACJ;IACA,MAAM,UAAU,KAAK,EAAE;QACnB,MAAM,aAAa,MAAM,CAAA,GAAA,sJAAA,CAAA,gBAAa,AAAD,EAAE,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,cAAc;QAC/F,MAAM,UAAU,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,cAAc,CAAC,OAAO;QAC9D,MAAM,EAAE,MAAM,OAAO,EAAE,GAAG,MAAM,CAAA,GAAA,+JAAA,CAAA,gDAA6C,AAAD,EAAE;YAC1E,cAAc;YACd,MAAM;gBACF,aAAa;YACjB;YACA,MAAM;gBACF,GAAG,IAAI,CAAC,cAAc;gBACtB,OAAO,CAAA,GAAA,gKAAA,CAAA,cAAW,AAAD,EAAE;gBACnB,gBAAgB;gBAChB,wBAAwB,IAAI,CAAC,cAAc,CAAC,cAAc;YAC9D;QACJ;QACA,OAAO,IAAI,CAAC,0BAA0B,CAAC,QAAQ,eAAe;IAClE;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 980, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/cloud/LlamaCloudIndex.js"],"sourcesContent":["import { RetrieverQueryEngine } from \"../engines/query/RetrieverQueryEngine.js\";\nimport { LlamaCloudRetriever } from \"./LlamaCloudRetriever.js\";\nimport { getAppBaseUrl, getPipelineId, getProjectId, initService } from \"./utils.js\";\nimport { createBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPost, deletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDelete, getPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGet, getPipelineStatusApiV1PipelinesPipelineIdStatusGet, searchPipelinesApiV1PipelinesGet, upsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPut, upsertPipelineApiV1PipelinesPut } from \"@llamaindex/cloud/api\";\nimport { getEnv } from \"@llamaindex/env\";\nimport { Settings } from \"../Settings.js\";\nexport class LlamaCloudIndex {\n    params;\n    constructor(params){\n        this.params = params;\n        initService(this.params);\n    }\n    async waitForPipelineIngestion(verbose = Settings.debug, raiseOnError = false) {\n        const pipelineId = await this.getPipelineId();\n        if (verbose) {\n            console.log(\"Waiting for pipeline ingestion: \");\n        }\n        while(true){\n            const { data: pipelineStatus } = await getPipelineStatusApiV1PipelinesPipelineIdStatusGet({\n                path: {\n                    pipeline_id: pipelineId\n                },\n                throwOnError: true\n            });\n            if (pipelineStatus.status === \"SUCCESS\") {\n                if (verbose) {\n                    console.log(\"Pipeline ingestion completed successfully\");\n                }\n                break;\n            }\n            if (pipelineStatus.status === \"ERROR\") {\n                if (verbose) {\n                    console.error(\"Pipeline ingestion failed\");\n                }\n                if (raiseOnError) {\n                    throw new Error(\"Pipeline ingestion failed\");\n                }\n            }\n            if (verbose) {\n                process.stdout.write(\".\");\n            }\n            await new Promise((resolve)=>setTimeout(resolve, 1000));\n        }\n    }\n    async waitForDocumentIngestion(docIds, verbose = Settings.debug, raiseOnError = false) {\n        const pipelineId = await this.getPipelineId();\n        if (verbose) {\n            console.log(\"Loading data: \");\n        }\n        const pendingDocs = new Set(docIds);\n        while(pendingDocs.size){\n            const docsToRemove = new Set();\n            for (const doc of pendingDocs){\n                const { data: { status } } = await getPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGet({\n                    path: {\n                        pipeline_id: pipelineId,\n                        document_id: doc\n                    },\n                    throwOnError: true\n                });\n                if (status === \"NOT_STARTED\" || status === \"IN_PROGRESS\") {\n                    continue;\n                }\n                if (status === \"ERROR\") {\n                    if (verbose) {\n                        console.error(`Document ingestion failed for ${doc}`);\n                    }\n                    if (raiseOnError) {\n                        throw new Error(`Document ingestion failed for ${doc}`);\n                    }\n                }\n                docsToRemove.add(doc);\n            }\n            for (const doc of docsToRemove){\n                pendingDocs.delete(doc);\n            }\n            if (pendingDocs.size) {\n                if (verbose) {\n                    process.stdout.write(\".\");\n                }\n                await new Promise((resolve)=>setTimeout(resolve, 500));\n            }\n        }\n        if (verbose) {\n            console.log(\"Done!\");\n        }\n        await this.waitForPipelineIngestion(verbose, raiseOnError);\n    }\n    async getPipelineId(name, projectName, organizationId) {\n        return await getPipelineId(name ?? this.params.name, projectName ?? this.params.projectName, organizationId ?? this.params.organizationId);\n    }\n    async getProjectId(projectName, organizationId) {\n        return await getProjectId(projectName ?? this.params.projectName, organizationId ?? this.params.organizationId);\n    }\n    /**\n   * Adds documents to the given index parameters. If the index does not exist, it will be created.\n   *\n   * @param params - An object containing the following properties:\n   *   - documents: An array of Document objects to be added to the index.\n   *   - verbose: Optional boolean to enable verbose logging.\n   *   - Additional properties from CloudConstructorParams.\n   * @returns A Promise that resolves to a new LlamaCloudIndex instance.\n   */ static async fromDocuments(params, config) {\n        const index = new LlamaCloudIndex({\n            ...params\n        });\n        await index.ensureIndex({\n            ...config,\n            verbose: params.verbose ?? false\n        });\n        await index.addDocuments(params.documents, params.verbose);\n        return index;\n    }\n    async addDocuments(documents, verbose) {\n        const apiUrl = getAppBaseUrl();\n        const projectId = await this.getProjectId();\n        const pipelineId = await this.getPipelineId();\n        await upsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPut({\n            path: {\n                pipeline_id: pipelineId\n            },\n            body: documents.map((doc)=>({\n                    metadata: doc.metadata,\n                    text: doc.text,\n                    excluded_embed_metadata_keys: doc.excludedEmbedMetadataKeys,\n                    excluded_llm_metadata_keys: doc.excludedEmbedMetadataKeys,\n                    id: doc.id_\n                }))\n        });\n        while(true){\n            const { data: pipelineStatus } = await getPipelineStatusApiV1PipelinesPipelineIdStatusGet({\n                path: {\n                    pipeline_id: pipelineId\n                },\n                throwOnError: true\n            });\n            if (pipelineStatus.status === \"SUCCESS\") {\n                console.info(\"Documents ingested successfully, pipeline is ready to use\");\n                break;\n            }\n            if (pipelineStatus.status === \"ERROR\") {\n                console.error(`Some documents failed to ingest, check your pipeline logs at ${apiUrl}/project/${projectId}/deploy/${pipelineId}`);\n                throw new Error(\"Some documents failed to ingest\");\n            }\n            if (pipelineStatus.status === \"PARTIAL_SUCCESS\") {\n                console.info(`Documents ingestion partially succeeded, to check a more complete status check your pipeline at ${apiUrl}/project/${projectId}/deploy/${pipelineId}`);\n                break;\n            }\n            if (verbose) {\n                process.stdout.write(\".\");\n            }\n            await new Promise((resolve)=>setTimeout(resolve, 1000));\n        }\n        if (verbose) {\n            console.info(`Ingestion completed, find your index at ${apiUrl}/project/${projectId}/deploy/${pipelineId}`);\n        }\n    }\n    asRetriever(params = {}) {\n        return new LlamaCloudRetriever({\n            ...this.params,\n            ...params\n        });\n    }\n    asQueryEngine(params) {\n        const retriever = new LlamaCloudRetriever({\n            ...this.params,\n            ...params\n        });\n        return new RetrieverQueryEngine(retriever, params?.responseSynthesizer, params?.nodePostprocessors);\n    }\n    async insert(document) {\n        const pipelineId = await this.getPipelineId();\n        await createBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPost({\n            path: {\n                pipeline_id: pipelineId\n            },\n            body: [\n                {\n                    metadata: document.metadata,\n                    text: document.text,\n                    excluded_embed_metadata_keys: document.excludedLlmMetadataKeys,\n                    excluded_llm_metadata_keys: document.excludedEmbedMetadataKeys,\n                    id: document.id_\n                }\n            ]\n        });\n        await this.waitForDocumentIngestion([\n            document.id_\n        ]);\n    }\n    async delete(document) {\n        const pipelineId = await this.getPipelineId();\n        await deletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDelete({\n            path: {\n                pipeline_id: pipelineId,\n                document_id: document.id_\n            }\n        });\n        await this.waitForPipelineIngestion();\n    }\n    async refreshDoc(document) {\n        const pipelineId = await this.getPipelineId();\n        await upsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPut({\n            path: {\n                pipeline_id: pipelineId\n            },\n            body: [\n                {\n                    metadata: document.metadata,\n                    text: document.text,\n                    excluded_embed_metadata_keys: document.excludedLlmMetadataKeys,\n                    excluded_llm_metadata_keys: document.excludedEmbedMetadataKeys,\n                    id: document.id_\n                }\n            ]\n        });\n        await this.waitForDocumentIngestion([\n            document.id_\n        ]);\n    }\n    async ensureIndex(config) {\n        const projectId = await this.getProjectId();\n        const { data: pipelines } = await searchPipelinesApiV1PipelinesGet({\n            query: {\n                project_id: projectId,\n                pipeline_name: this.params.name\n            },\n            throwOnError: true\n        });\n        if (pipelines.length === 0) {\n            // no pipeline found, create a new one\n            let embeddingConfig = config?.embedding;\n            if (!embeddingConfig) {\n                // no embedding config provided, use OpenAI as default\n                const openAIApiKey = getEnv(\"OPENAI_API_KEY\");\n                const embeddingModel = getEnv(\"EMBEDDING_MODEL\");\n                if (!openAIApiKey || !embeddingModel) {\n                    throw new Error(\"No embedding configuration provided. Fallback to OpenAI embedding model. OPENAI_API_KEY and EMBEDDING_MODEL environment variables must be set.\");\n                }\n                embeddingConfig = {\n                    type: \"OPENAI_EMBEDDING\",\n                    component: {\n                        api_key: openAIApiKey,\n                        model_name: embeddingModel\n                    }\n                };\n            }\n            let transformConfig = config?.transform;\n            if (!transformConfig) {\n                transformConfig = {\n                    mode: \"auto\",\n                    chunk_size: 1024,\n                    chunk_overlap: 200\n                };\n            }\n            const { data: pipeline } = await upsertPipelineApiV1PipelinesPut({\n                query: {\n                    project_id: projectId\n                },\n                body: {\n                    name: this.params.name,\n                    embedding_config: embeddingConfig,\n                    transform_config: transformConfig\n                },\n                throwOnError: true\n            });\n            if (config?.verbose) {\n                console.log(`Created pipeline ${pipeline.id} with name ${pipeline.name}`);\n            }\n        }\n    }\n}\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;;;;AACO,MAAM;IACT,OAAO;IACP,YAAY,MAAM,CAAC;QACf,IAAI,CAAC,MAAM,GAAG;QACd,CAAA,GAAA,sJAAA,CAAA,cAAW,AAAD,EAAE,IAAI,CAAC,MAAM;IAC3B;IACA,MAAM,yBAAyB,UAAU,gJAAA,CAAA,WAAQ,CAAC,KAAK,EAAE,eAAe,KAAK,EAAE;QAC3E,MAAM,aAAa,MAAM,IAAI,CAAC,aAAa;QAC3C,IAAI,SAAS;YACT,QAAQ,GAAG,CAAC;QAChB;QACA,MAAM,KAAK;YACP,MAAM,EAAE,MAAM,cAAc,EAAE,GAAG,MAAM,CAAA,GAAA,+JAAA,CAAA,qDAAkD,AAAD,EAAE;gBACtF,MAAM;oBACF,aAAa;gBACjB;gBACA,cAAc;YAClB;YACA,IAAI,eAAe,MAAM,KAAK,WAAW;gBACrC,IAAI,SAAS;oBACT,QAAQ,GAAG,CAAC;gBAChB;gBACA;YACJ;YACA,IAAI,eAAe,MAAM,KAAK,SAAS;gBACnC,IAAI,SAAS;oBACT,QAAQ,KAAK,CAAC;gBAClB;gBACA,IAAI,cAAc;oBACd,MAAM,IAAI,MAAM;gBACpB;YACJ;YACA,IAAI,SAAS;gBACT,QAAQ,MAAM,CAAC,KAAK,CAAC;YACzB;YACA,MAAM,IAAI,QAAQ,CAAC,UAAU,WAAW,SAAS;QACrD;IACJ;IACA,MAAM,yBAAyB,MAAM,EAAE,UAAU,gJAAA,CAAA,WAAQ,CAAC,KAAK,EAAE,eAAe,KAAK,EAAE;QACnF,MAAM,aAAa,MAAM,IAAI,CAAC,aAAa;QAC3C,IAAI,SAAS;YACT,QAAQ,GAAG,CAAC;QAChB;QACA,MAAM,cAAc,IAAI,IAAI;QAC5B,MAAM,YAAY,IAAI,CAAC;YACnB,MAAM,eAAe,IAAI;YACzB,KAAK,MAAM,OAAO,YAAY;gBAC1B,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,EAAE,GAAG,MAAM,CAAA,GAAA,+JAAA,CAAA,gFAA6E,AAAD,EAAE;oBAC7G,MAAM;wBACF,aAAa;wBACb,aAAa;oBACjB;oBACA,cAAc;gBAClB;gBACA,IAAI,WAAW,iBAAiB,WAAW,eAAe;oBACtD;gBACJ;gBACA,IAAI,WAAW,SAAS;oBACpB,IAAI,SAAS;wBACT,QAAQ,KAAK,CAAC,CAAC,8BAA8B,EAAE,KAAK;oBACxD;oBACA,IAAI,cAAc;wBACd,MAAM,IAAI,MAAM,CAAC,8BAA8B,EAAE,KAAK;oBAC1D;gBACJ;gBACA,aAAa,GAAG,CAAC;YACrB;YACA,KAAK,MAAM,OAAO,aAAa;gBAC3B,YAAY,MAAM,CAAC;YACvB;YACA,IAAI,YAAY,IAAI,EAAE;gBAClB,IAAI,SAAS;oBACT,QAAQ,MAAM,CAAC,KAAK,CAAC;gBACzB;gBACA,MAAM,IAAI,QAAQ,CAAC,UAAU,WAAW,SAAS;YACrD;QACJ;QACA,IAAI,SAAS;YACT,QAAQ,GAAG,CAAC;QAChB;QACA,MAAM,IAAI,CAAC,wBAAwB,CAAC,SAAS;IACjD;IACA,MAAM,cAAc,IAAI,EAAE,WAAW,EAAE,cAAc,EAAE;QACnD,OAAO,MAAM,CAAA,GAAA,sJAAA,CAAA,gBAAa,AAAD,EAAE,QAAQ,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,eAAe,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE,kBAAkB,IAAI,CAAC,MAAM,CAAC,cAAc;IAC7I;IACA,MAAM,aAAa,WAAW,EAAE,cAAc,EAAE;QAC5C,OAAO,MAAM,CAAA,GAAA,sJAAA,CAAA,eAAY,AAAD,EAAE,eAAe,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE,kBAAkB,IAAI,CAAC,MAAM,CAAC,cAAc;IAClH;IACA;;;;;;;;GAQD,GAAG,aAAa,cAAc,MAAM,EAAE,MAAM,EAAE;QACzC,MAAM,QAAQ,IAAI,gBAAgB;YAC9B,GAAG,MAAM;QACb;QACA,MAAM,MAAM,WAAW,CAAC;YACpB,GAAG,MAAM;YACT,SAAS,OAAO,OAAO,IAAI;QAC/B;QACA,MAAM,MAAM,YAAY,CAAC,OAAO,SAAS,EAAE,OAAO,OAAO;QACzD,OAAO;IACX;IACA,MAAM,aAAa,SAAS,EAAE,OAAO,EAAE;QACnC,MAAM,SAAS,CAAA,GAAA,sJAAA,CAAA,gBAAa,AAAD;QAC3B,MAAM,YAAY,MAAM,IAAI,CAAC,YAAY;QACzC,MAAM,aAAa,MAAM,IAAI,CAAC,aAAa;QAC3C,MAAM,CAAA,GAAA,+JAAA,CAAA,mEAAgE,AAAD,EAAE;YACnE,MAAM;gBACF,aAAa;YACjB;YACA,MAAM,UAAU,GAAG,CAAC,CAAC,MAAM,CAAC;oBACpB,UAAU,IAAI,QAAQ;oBACtB,MAAM,IAAI,IAAI;oBACd,8BAA8B,IAAI,yBAAyB;oBAC3D,4BAA4B,IAAI,yBAAyB;oBACzD,IAAI,IAAI,GAAG;gBACf,CAAC;QACT;QACA,MAAM,KAAK;YACP,MAAM,EAAE,MAAM,cAAc,EAAE,GAAG,MAAM,CAAA,GAAA,+JAAA,CAAA,qDAAkD,AAAD,EAAE;gBACtF,MAAM;oBACF,aAAa;gBACjB;gBACA,cAAc;YAClB;YACA,IAAI,eAAe,MAAM,KAAK,WAAW;gBACrC,QAAQ,IAAI,CAAC;gBACb;YACJ;YACA,IAAI,eAAe,MAAM,KAAK,SAAS;gBACnC,QAAQ,KAAK,CAAC,CAAC,6DAA6D,EAAE,OAAO,SAAS,EAAE,UAAU,QAAQ,EAAE,YAAY;gBAChI,MAAM,IAAI,MAAM;YACpB;YACA,IAAI,eAAe,MAAM,KAAK,mBAAmB;gBAC7C,QAAQ,IAAI,CAAC,CAAC,gGAAgG,EAAE,OAAO,SAAS,EAAE,UAAU,QAAQ,EAAE,YAAY;gBAClK;YACJ;YACA,IAAI,SAAS;gBACT,QAAQ,MAAM,CAAC,KAAK,CAAC;YACzB;YACA,MAAM,IAAI,QAAQ,CAAC,UAAU,WAAW,SAAS;QACrD;QACA,IAAI,SAAS;YACT,QAAQ,IAAI,CAAC,CAAC,wCAAwC,EAAE,OAAO,SAAS,EAAE,UAAU,QAAQ,EAAE,YAAY;QAC9G;IACJ;IACA,YAAY,SAAS,CAAC,CAAC,EAAE;QACrB,OAAO,IAAI,oKAAA,CAAA,sBAAmB,CAAC;YAC3B,GAAG,IAAI,CAAC,MAAM;YACd,GAAG,MAAM;QACb;IACJ;IACA,cAAc,MAAM,EAAE;QAClB,MAAM,YAAY,IAAI,oKAAA,CAAA,sBAAmB,CAAC;YACtC,GAAG,IAAI,CAAC,MAAM;YACd,GAAG,MAAM;QACb;QACA,OAAO,IAAI,0KAAA,CAAA,uBAAoB,CAAC,WAAW,QAAQ,qBAAqB,QAAQ;IACpF;IACA,MAAM,OAAO,QAAQ,EAAE;QACnB,MAAM,aAAa,MAAM,IAAI,CAAC,aAAa;QAC3C,MAAM,CAAA,GAAA,+JAAA,CAAA,oEAAiE,AAAD,EAAE;YACpE,MAAM;gBACF,aAAa;YACjB;YACA,MAAM;gBACF;oBACI,UAAU,SAAS,QAAQ;oBAC3B,MAAM,SAAS,IAAI;oBACnB,8BAA8B,SAAS,uBAAuB;oBAC9D,4BAA4B,SAAS,yBAAyB;oBAC9D,IAAI,SAAS,GAAG;gBACpB;aACH;QACL;QACA,MAAM,IAAI,CAAC,wBAAwB,CAAC;YAChC,SAAS,GAAG;SACf;IACL;IACA,MAAM,OAAO,QAAQ,EAAE;QACnB,MAAM,aAAa,MAAM,IAAI,CAAC,aAAa;QAC3C,MAAM,CAAA,GAAA,+JAAA,CAAA,0EAAuE,AAAD,EAAE;YAC1E,MAAM;gBACF,aAAa;gBACb,aAAa,SAAS,GAAG;YAC7B;QACJ;QACA,MAAM,IAAI,CAAC,wBAAwB;IACvC;IACA,MAAM,WAAW,QAAQ,EAAE;QACvB,MAAM,aAAa,MAAM,IAAI,CAAC,aAAa;QAC3C,MAAM,CAAA,GAAA,+JAAA,CAAA,mEAAgE,AAAD,EAAE;YACnE,MAAM;gBACF,aAAa;YACjB;YACA,MAAM;gBACF;oBACI,UAAU,SAAS,QAAQ;oBAC3B,MAAM,SAAS,IAAI;oBACnB,8BAA8B,SAAS,uBAAuB;oBAC9D,4BAA4B,SAAS,yBAAyB;oBAC9D,IAAI,SAAS,GAAG;gBACpB;aACH;QACL;QACA,MAAM,IAAI,CAAC,wBAAwB,CAAC;YAChC,SAAS,GAAG;SACf;IACL;IACA,MAAM,YAAY,MAAM,EAAE;QACtB,MAAM,YAAY,MAAM,IAAI,CAAC,YAAY;QACzC,MAAM,EAAE,MAAM,SAAS,EAAE,GAAG,MAAM,CAAA,GAAA,+JAAA,CAAA,mCAAgC,AAAD,EAAE;YAC/D,OAAO;gBACH,YAAY;gBACZ,eAAe,IAAI,CAAC,MAAM,CAAC,IAAI;YACnC;YACA,cAAc;QAClB;QACA,IAAI,UAAU,MAAM,KAAK,GAAG;YACxB,sCAAsC;YACtC,IAAI,kBAAkB,QAAQ;YAC9B,IAAI,CAAC,iBAAiB;gBAClB,sDAAsD;gBACtD,MAAM,eAAe,CAAA,GAAA,sKAAA,CAAA,SAAM,AAAD,EAAE;gBAC5B,MAAM,iBAAiB,CAAA,GAAA,sKAAA,CAAA,SAAM,AAAD,EAAE;gBAC9B,IAAI,CAAC,gBAAgB,CAAC,gBAAgB;oBAClC,MAAM,IAAI,MAAM;gBACpB;gBACA,kBAAkB;oBACd,MAAM;oBACN,WAAW;wBACP,SAAS;wBACT,YAAY;oBAChB;gBACJ;YACJ;YACA,IAAI,kBAAkB,QAAQ;YAC9B,IAAI,CAAC,iBAAiB;gBAClB,kBAAkB;oBACd,MAAM;oBACN,YAAY;oBACZ,eAAe;gBACnB;YACJ;YACA,MAAM,EAAE,MAAM,QAAQ,EAAE,GAAG,MAAM,CAAA,GAAA,+JAAA,CAAA,kCAA+B,AAAD,EAAE;gBAC7D,OAAO;oBACH,YAAY;gBAChB;gBACA,MAAM;oBACF,MAAM,IAAI,CAAC,MAAM,CAAC,IAAI;oBACtB,kBAAkB;oBAClB,kBAAkB;gBACtB;gBACA,cAAc;YAClB;YACA,IAAI,QAAQ,SAAS;gBACjB,QAAQ,GAAG,CAAC,CAAC,iBAAiB,EAAE,SAAS,EAAE,CAAC,WAAW,EAAE,SAAS,IAAI,EAAE;YAC5E;QACJ;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1269, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/cloud/index.js"],"sourcesContent":["export { LLamaCloudFileService } from \"./LLamaCloudFileService.js\";\nexport { LlamaCloudIndex } from \"./LlamaCloudIndex.js\";\nexport { LlamaCloudRetriever } from \"./LlamaCloudRetriever.js\";\n"],"names":[],"mappings":";AAAA;AACA;AACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1293, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/engines/chat/CondenseQuestionChatEngine.js"],"sourcesContent":["function applyDecs2203RFactory() {\n    function createAddInitializerMethod(initializers, decoratorFinishedRef) {\n        return function addInitializer(initializer) {\n            assertNotFinished(decoratorFinishedRef, \"addInitializer\");\n            assertCallable(initializer, \"An initializer\");\n            initializers.push(initializer);\n        };\n    }\n    function memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value) {\n        var kindStr;\n        switch(kind){\n            case 1:\n                kindStr = \"accessor\";\n                break;\n            case 2:\n                kindStr = \"method\";\n                break;\n            case 3:\n                kindStr = \"getter\";\n                break;\n            case 4:\n                kindStr = \"setter\";\n                break;\n            default:\n                kindStr = \"field\";\n        }\n        var ctx = {\n            kind: kindStr,\n            name: isPrivate ? \"#\" + name : name,\n            static: isStatic,\n            private: isPrivate,\n            metadata: metadata\n        };\n        var decoratorFinishedRef = {\n            v: false\n        };\n        ctx.addInitializer = createAddInitializerMethod(initializers, decoratorFinishedRef);\n        var get, set;\n        if (kind === 0) {\n            if (isPrivate) {\n                get = desc.get;\n                set = desc.set;\n            } else {\n                get = function() {\n                    return this[name];\n                };\n                set = function(v) {\n                    this[name] = v;\n                };\n            }\n        } else if (kind === 2) {\n            get = function() {\n                return desc.value;\n            };\n        } else {\n            if (kind === 1 || kind === 3) {\n                get = function() {\n                    return desc.get.call(this);\n                };\n            }\n            if (kind === 1 || kind === 4) {\n                set = function(v) {\n                    desc.set.call(this, v);\n                };\n            }\n        }\n        ctx.access = get && set ? {\n            get: get,\n            set: set\n        } : get ? {\n            get: get\n        } : {\n            set: set\n        };\n        try {\n            return dec(value, ctx);\n        } finally{\n            decoratorFinishedRef.v = true;\n        }\n    }\n    function assertNotFinished(decoratorFinishedRef, fnName) {\n        if (decoratorFinishedRef.v) {\n            throw new Error(\"attempted to call \" + fnName + \" after decoration was finished\");\n        }\n    }\n    function assertCallable(fn, hint) {\n        if (typeof fn !== \"function\") {\n            throw new TypeError(hint + \" must be a function\");\n        }\n    }\n    function assertValidReturnValue(kind, value) {\n        var type = typeof value;\n        if (kind === 1) {\n            if (type !== \"object\" || value === null) {\n                throw new TypeError(\"accessor decorators must return an object with get, set, or init properties or void 0\");\n            }\n            if (value.get !== undefined) {\n                assertCallable(value.get, \"accessor.get\");\n            }\n            if (value.set !== undefined) {\n                assertCallable(value.set, \"accessor.set\");\n            }\n            if (value.init !== undefined) {\n                assertCallable(value.init, \"accessor.init\");\n            }\n        } else if (type !== \"function\") {\n            var hint;\n            if (kind === 0) {\n                hint = \"field\";\n            } else if (kind === 10) {\n                hint = \"class\";\n            } else {\n                hint = \"method\";\n            }\n            throw new TypeError(hint + \" decorators must return a function or void 0\");\n        }\n    }\n    function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata) {\n        var decs = decInfo[0];\n        var desc, init, value;\n        if (isPrivate) {\n            if (kind === 0 || kind === 1) {\n                desc = {\n                    get: decInfo[3],\n                    set: decInfo[4]\n                };\n            } else if (kind === 3) {\n                desc = {\n                    get: decInfo[3]\n                };\n            } else if (kind === 4) {\n                desc = {\n                    set: decInfo[3]\n                };\n            } else {\n                desc = {\n                    value: decInfo[3]\n                };\n            }\n        } else if (kind !== 0) {\n            desc = Object.getOwnPropertyDescriptor(base, name);\n        }\n        if (kind === 1) {\n            value = {\n                get: desc.get,\n                set: desc.set\n            };\n        } else if (kind === 2) {\n            value = desc.value;\n        } else if (kind === 3) {\n            value = desc.get;\n        } else if (kind === 4) {\n            value = desc.set;\n        }\n        var newValue, get, set;\n        if (typeof decs === \"function\") {\n            newValue = memberDec(decs, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);\n            if (newValue !== void 0) {\n                assertValidReturnValue(kind, newValue);\n                if (kind === 0) {\n                    init = newValue;\n                } else if (kind === 1) {\n                    init = newValue.init;\n                    get = newValue.get || value.get;\n                    set = newValue.set || value.set;\n                    value = {\n                        get: get,\n                        set: set\n                    };\n                } else {\n                    value = newValue;\n                }\n            }\n        } else {\n            for(var i = decs.length - 1; i >= 0; i--){\n                var dec = decs[i];\n                newValue = memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);\n                if (newValue !== void 0) {\n                    assertValidReturnValue(kind, newValue);\n                    var newInit;\n                    if (kind === 0) {\n                        newInit = newValue;\n                    } else if (kind === 1) {\n                        newInit = newValue.init;\n                        get = newValue.get || value.get;\n                        set = newValue.set || value.set;\n                        value = {\n                            get: get,\n                            set: set\n                        };\n                    } else {\n                        value = newValue;\n                    }\n                    if (newInit !== void 0) {\n                        if (init === void 0) {\n                            init = newInit;\n                        } else if (typeof init === \"function\") {\n                            init = [\n                                init,\n                                newInit\n                            ];\n                        } else {\n                            init.push(newInit);\n                        }\n                    }\n                }\n            }\n        }\n        if (kind === 0 || kind === 1) {\n            if (init === void 0) {\n                init = function(instance, init) {\n                    return init;\n                };\n            } else if (typeof init !== \"function\") {\n                var ownInitializers = init;\n                init = function(instance, init) {\n                    var value = init;\n                    for(var i = 0; i < ownInitializers.length; i++){\n                        value = ownInitializers[i].call(instance, value);\n                    }\n                    return value;\n                };\n            } else {\n                var originalInitializer = init;\n                init = function(instance, init) {\n                    return originalInitializer.call(instance, init);\n                };\n            }\n            ret.push(init);\n        }\n        if (kind !== 0) {\n            if (kind === 1) {\n                desc.get = value.get;\n                desc.set = value.set;\n            } else if (kind === 2) {\n                desc.value = value;\n            } else if (kind === 3) {\n                desc.get = value;\n            } else if (kind === 4) {\n                desc.set = value;\n            }\n            if (isPrivate) {\n                if (kind === 1) {\n                    ret.push(function(instance, args) {\n                        return value.get.call(instance, args);\n                    });\n                    ret.push(function(instance, args) {\n                        return value.set.call(instance, args);\n                    });\n                } else if (kind === 2) {\n                    ret.push(value);\n                } else {\n                    ret.push(function(instance, args) {\n                        return value.call(instance, args);\n                    });\n                }\n            } else {\n                Object.defineProperty(base, name, desc);\n            }\n        }\n    }\n    function applyMemberDecs(Class, decInfos, metadata) {\n        var ret = [];\n        var protoInitializers;\n        var staticInitializers;\n        var existingProtoNonFields = new Map();\n        var existingStaticNonFields = new Map();\n        for(var i = 0; i < decInfos.length; i++){\n            var decInfo = decInfos[i];\n            if (!Array.isArray(decInfo)) continue;\n            var kind = decInfo[1];\n            var name = decInfo[2];\n            var isPrivate = decInfo.length > 3;\n            var isStatic = kind >= 5;\n            var base;\n            var initializers;\n            if (isStatic) {\n                base = Class;\n                kind = kind - 5;\n                staticInitializers = staticInitializers || [];\n                initializers = staticInitializers;\n            } else {\n                base = Class.prototype;\n                protoInitializers = protoInitializers || [];\n                initializers = protoInitializers;\n            }\n            if (kind !== 0 && !isPrivate) {\n                var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields;\n                var existingKind = existingNonFields.get(name) || 0;\n                if (existingKind === true || existingKind === 3 && kind !== 4 || existingKind === 4 && kind !== 3) {\n                    throw new Error(\"Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: \" + name);\n                } else if (!existingKind && kind > 2) {\n                    existingNonFields.set(name, kind);\n                } else {\n                    existingNonFields.set(name, true);\n                }\n            }\n            applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata);\n        }\n        pushInitializers(ret, protoInitializers);\n        pushInitializers(ret, staticInitializers);\n        return ret;\n    }\n    function pushInitializers(ret, initializers) {\n        if (initializers) {\n            ret.push(function(instance) {\n                for(var i = 0; i < initializers.length; i++){\n                    initializers[i].call(instance);\n                }\n                return instance;\n            });\n        }\n    }\n    function applyClassDecs(targetClass, classDecs, metadata) {\n        if (classDecs.length > 0) {\n            var initializers = [];\n            var newClass = targetClass;\n            var name = targetClass.name;\n            for(var i = classDecs.length - 1; i >= 0; i--){\n                var decoratorFinishedRef = {\n                    v: false\n                };\n                try {\n                    var nextNewClass = classDecs[i](newClass, {\n                        kind: \"class\",\n                        name: name,\n                        addInitializer: createAddInitializerMethod(initializers, decoratorFinishedRef),\n                        metadata\n                    });\n                } finally{\n                    decoratorFinishedRef.v = true;\n                }\n                if (nextNewClass !== undefined) {\n                    assertValidReturnValue(10, nextNewClass);\n                    newClass = nextNewClass;\n                }\n            }\n            return [\n                defineMetadata(newClass, metadata),\n                function() {\n                    for(var i = 0; i < initializers.length; i++){\n                        initializers[i].call(newClass);\n                    }\n                }\n            ];\n        }\n    }\n    function defineMetadata(Class, metadata) {\n        return Object.defineProperty(Class, Symbol.metadata || Symbol.for(\"Symbol.metadata\"), {\n            configurable: true,\n            enumerable: true,\n            value: metadata\n        });\n    }\n    return function applyDecs2203R(targetClass, memberDecs, classDecs, parentClass) {\n        if (parentClass !== void 0) {\n            var parentMetadata = parentClass[Symbol.metadata || Symbol.for(\"Symbol.metadata\")];\n        }\n        var metadata = Object.create(parentMetadata === void 0 ? null : parentMetadata);\n        var e = applyMemberDecs(targetClass, memberDecs, metadata);\n        if (!classDecs.length) defineMetadata(targetClass, metadata);\n        return {\n            e: e,\n            get c () {\n                return applyClassDecs(targetClass, classDecs, metadata);\n            }\n        };\n    };\n}\nfunction _apply_decs_2203_r(targetClass, memberDecs, classDecs, parentClass) {\n    return (_apply_decs_2203_r = applyDecs2203RFactory())(targetClass, memberDecs, classDecs, parentClass);\n}\nvar _initProto;\nimport { BaseChatEngine } from \"@llamaindex/core/chat-engine\";\nimport { wrapEventCaller } from \"@llamaindex/core/decorator\";\nimport { BaseMemory, ChatMemoryBuffer } from \"@llamaindex/core/memory\";\nimport { defaultCondenseQuestionPrompt } from \"@llamaindex/core/prompts\";\nimport { extractText, messagesToHistory, streamReducer } from \"@llamaindex/core/utils\";\nimport { Settings } from \"../../Settings.js\";\n/**\n * CondenseQuestionChatEngine is used in conjunction with a Index (for example VectorStoreIndex).\n * It does two steps on taking a user's chat message: first, it condenses the chat message\n * with the previous chat history into a question with more context.\n * Then, it queries the underlying Index using the new question with context and returns\n * the response.\n * CondenseQuestionChatEngine performs well when the input is primarily questions about the\n * underlying data. It performs less well when the chat messages are not questions about the\n * data, or are very referential to previous context.\n */ export class CondenseQuestionChatEngine extends BaseChatEngine {\n    static{\n        ({ e: [_initProto] } = _apply_decs_2203_r(this, [\n            [\n                wrapEventCaller,\n                2,\n                \"chat\"\n            ]\n        ], []));\n    }\n    queryEngine;\n    memory;\n    llm;\n    condenseMessagePrompt;\n    get chatHistory() {\n        return this.memory.getMessages();\n    }\n    constructor(init){\n        super(), _initProto(this);\n        this.queryEngine = init.queryEngine;\n        this.memory = new ChatMemoryBuffer({\n            chatHistory: init?.chatHistory\n        });\n        this.llm = Settings.llm;\n        this.condenseMessagePrompt = init?.condenseMessagePrompt ?? defaultCondenseQuestionPrompt;\n    }\n    _getPromptModules() {\n        return {};\n    }\n    _getPrompts() {\n        return {\n            condenseMessagePrompt: this.condenseMessagePrompt\n        };\n    }\n    _updatePrompts(promptsDict) {\n        if (promptsDict.condenseMessagePrompt) {\n            this.condenseMessagePrompt = promptsDict.condenseMessagePrompt;\n        }\n    }\n    async condenseQuestion(chatHistory, question) {\n        const chatHistoryStr = messagesToHistory(await chatHistory.getMessages());\n        return this.llm.complete({\n            prompt: this.condenseMessagePrompt.format({\n                question: question,\n                chatHistory: chatHistoryStr\n            })\n        });\n    }\n    async chat(params) {\n        const { message, stream } = params;\n        const chatHistory = params.chatHistory ? new ChatMemoryBuffer({\n            chatHistory: params.chatHistory instanceof BaseMemory ? await params.chatHistory.getMessages() : params.chatHistory\n        }) : this.memory;\n        const condensedQuestion = (await this.condenseQuestion(chatHistory, extractText(message))).text;\n        chatHistory.put({\n            content: message,\n            role: \"user\"\n        });\n        if (stream) {\n            const stream = await this.queryEngine.query({\n                query: condensedQuestion,\n                stream: true\n            });\n            return streamReducer({\n                stream,\n                initialValue: \"\",\n                reducer: (accumulator, part)=>accumulator += extractText(part.message.content),\n                finished: (accumulator)=>{\n                    chatHistory.put({\n                        content: accumulator,\n                        role: \"assistant\"\n                    });\n                }\n            });\n        }\n        const response = await this.queryEngine.query({\n            query: condensedQuestion\n        });\n        chatHistory.put({\n            content: response.message.content,\n            role: \"assistant\"\n        });\n        return response;\n    }\n    reset() {\n        this.memory.reset();\n    }\n}\n"],"names":[],"mappings":";;;AAqXA;AACA;AACA;AACA;AACA;AACA;AA1XA,SAAS;IACL,SAAS,2BAA2B,YAAY,EAAE,oBAAoB;QAClE,OAAO,SAAS,eAAe,WAAW;YACtC,kBAAkB,sBAAsB;YACxC,eAAe,aAAa;YAC5B,aAAa,IAAI,CAAC;QACtB;IACJ;IACA,SAAS,UAAU,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,YAAY,EAAE,IAAI,EAAE,QAAQ,EAAE,SAAS,EAAE,QAAQ,EAAE,KAAK;QACxF,IAAI;QACJ,OAAO;YACH,KAAK;gBACD,UAAU;gBACV;YACJ,KAAK;gBACD,UAAU;gBACV;YACJ,KAAK;gBACD,UAAU;gBACV;YACJ,KAAK;gBACD,UAAU;gBACV;YACJ;gBACI,UAAU;QAClB;QACA,IAAI,MAAM;YACN,MAAM;YACN,MAAM,YAAY,MAAM,OAAO;YAC/B,QAAQ;YACR,SAAS;YACT,UAAU;QACd;QACA,IAAI,uBAAuB;YACvB,GAAG;QACP;QACA,IAAI,cAAc,GAAG,2BAA2B,cAAc;QAC9D,IAAI,KAAK;QACT,IAAI,SAAS,GAAG;YACZ,IAAI,WAAW;gBACX,MAAM,KAAK,GAAG;gBACd,MAAM,KAAK,GAAG;YAClB,OAAO;gBACH,MAAM;oBACF,OAAO,IAAI,CAAC,KAAK;gBACrB;gBACA,MAAM,SAAS,CAAC;oBACZ,IAAI,CAAC,KAAK,GAAG;gBACjB;YACJ;QACJ,OAAO,IAAI,SAAS,GAAG;YACnB,MAAM;gBACF,OAAO,KAAK,KAAK;YACrB;QACJ,OAAO;YACH,IAAI,SAAS,KAAK,SAAS,GAAG;gBAC1B,MAAM;oBACF,OAAO,KAAK,GAAG,CAAC,IAAI,CAAC,IAAI;gBAC7B;YACJ;YACA,IAAI,SAAS,KAAK,SAAS,GAAG;gBAC1B,MAAM,SAAS,CAAC;oBACZ,KAAK,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE;gBACxB;YACJ;QACJ;QACA,IAAI,MAAM,GAAG,OAAO,MAAM;YACtB,KAAK;YACL,KAAK;QACT,IAAI,MAAM;YACN,KAAK;QACT,IAAI;YACA,KAAK;QACT;QACA,IAAI;YACA,OAAO,IAAI,OAAO;QACtB,SAAS;YACL,qBAAqB,CAAC,GAAG;QAC7B;IACJ;IACA,SAAS,kBAAkB,oBAAoB,EAAE,MAAM;QACnD,IAAI,qBAAqB,CAAC,EAAE;YACxB,MAAM,IAAI,MAAM,uBAAuB,SAAS;QACpD;IACJ;IACA,SAAS,eAAe,EAAE,EAAE,IAAI;QAC5B,IAAI,OAAO,OAAO,YAAY;YAC1B,MAAM,IAAI,UAAU,OAAO;QAC/B;IACJ;IACA,SAAS,uBAAuB,IAAI,EAAE,KAAK;QACvC,IAAI,OAAO,OAAO;QAClB,IAAI,SAAS,GAAG;YACZ,IAAI,SAAS,YAAY,UAAU,MAAM;gBACrC,MAAM,IAAI,UAAU;YACxB;YACA,IAAI,MAAM,GAAG,KAAK,WAAW;gBACzB,eAAe,MAAM,GAAG,EAAE;YAC9B;YACA,IAAI,MAAM,GAAG,KAAK,WAAW;gBACzB,eAAe,MAAM,GAAG,EAAE;YAC9B;YACA,IAAI,MAAM,IAAI,KAAK,WAAW;gBAC1B,eAAe,MAAM,IAAI,EAAE;YAC/B;QACJ,OAAO,IAAI,SAAS,YAAY;YAC5B,IAAI;YACJ,IAAI,SAAS,GAAG;gBACZ,OAAO;YACX,OAAO,IAAI,SAAS,IAAI;gBACpB,OAAO;YACX,OAAO;gBACH,OAAO;YACX;YACA,MAAM,IAAI,UAAU,OAAO;QAC/B;IACJ;IACA,SAAS,eAAe,GAAG,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,QAAQ,EAAE,SAAS,EAAE,YAAY,EAAE,QAAQ;QAC/F,IAAI,OAAO,OAAO,CAAC,EAAE;QACrB,IAAI,MAAM,MAAM;QAChB,IAAI,WAAW;YACX,IAAI,SAAS,KAAK,SAAS,GAAG;gBAC1B,OAAO;oBACH,KAAK,OAAO,CAAC,EAAE;oBACf,KAAK,OAAO,CAAC,EAAE;gBACnB;YACJ,OAAO,IAAI,SAAS,GAAG;gBACnB,OAAO;oBACH,KAAK,OAAO,CAAC,EAAE;gBACnB;YACJ,OAAO,IAAI,SAAS,GAAG;gBACnB,OAAO;oBACH,KAAK,OAAO,CAAC,EAAE;gBACnB;YACJ,OAAO;gBACH,OAAO;oBACH,OAAO,OAAO,CAAC,EAAE;gBACrB;YACJ;QACJ,OAAO,IAAI,SAAS,GAAG;YACnB,OAAO,OAAO,wBAAwB,CAAC,MAAM;QACjD;QACA,IAAI,SAAS,GAAG;YACZ,QAAQ;gBACJ,KAAK,KAAK,GAAG;gBACb,KAAK,KAAK,GAAG;YACjB;QACJ,OAAO,IAAI,SAAS,GAAG;YACnB,QAAQ,KAAK,KAAK;QACtB,OAAO,IAAI,SAAS,GAAG;YACnB,QAAQ,KAAK,GAAG;QACpB,OAAO,IAAI,SAAS,GAAG;YACnB,QAAQ,KAAK,GAAG;QACpB;QACA,IAAI,UAAU,KAAK;QACnB,IAAI,OAAO,SAAS,YAAY;YAC5B,WAAW,UAAU,MAAM,MAAM,MAAM,cAAc,MAAM,UAAU,WAAW,UAAU;YAC1F,IAAI,aAAa,KAAK,GAAG;gBACrB,uBAAuB,MAAM;gBAC7B,IAAI,SAAS,GAAG;oBACZ,OAAO;gBACX,OAAO,IAAI,SAAS,GAAG;oBACnB,OAAO,SAAS,IAAI;oBACpB,MAAM,SAAS,GAAG,IAAI,MAAM,GAAG;oBAC/B,MAAM,SAAS,GAAG,IAAI,MAAM,GAAG;oBAC/B,QAAQ;wBACJ,KAAK;wBACL,KAAK;oBACT;gBACJ,OAAO;oBACH,QAAQ;gBACZ;YACJ;QACJ,OAAO;YACH,IAAI,IAAI,IAAI,KAAK,MAAM,GAAG,GAAG,KAAK,GAAG,IAAI;gBACrC,IAAI,MAAM,IAAI,CAAC,EAAE;gBACjB,WAAW,UAAU,KAAK,MAAM,MAAM,cAAc,MAAM,UAAU,WAAW,UAAU;gBACzF,IAAI,aAAa,KAAK,GAAG;oBACrB,uBAAuB,MAAM;oBAC7B,IAAI;oBACJ,IAAI,SAAS,GAAG;wBACZ,UAAU;oBACd,OAAO,IAAI,SAAS,GAAG;wBACnB,UAAU,SAAS,IAAI;wBACvB,MAAM,SAAS,GAAG,IAAI,MAAM,GAAG;wBAC/B,MAAM,SAAS,GAAG,IAAI,MAAM,GAAG;wBAC/B,QAAQ;4BACJ,KAAK;4BACL,KAAK;wBACT;oBACJ,OAAO;wBACH,QAAQ;oBACZ;oBACA,IAAI,YAAY,KAAK,GAAG;wBACpB,IAAI,SAAS,KAAK,GAAG;4BACjB,OAAO;wBACX,OAAO,IAAI,OAAO,SAAS,YAAY;4BACnC,OAAO;gCACH;gCACA;6BACH;wBACL,OAAO;4BACH,KAAK,IAAI,CAAC;wBACd;oBACJ;gBACJ;YACJ;QACJ;QACA,IAAI,SAAS,KAAK,SAAS,GAAG;YAC1B,IAAI,SAAS,KAAK,GAAG;gBACjB,OAAO,SAAS,QAAQ,EAAE,IAAI;oBAC1B,OAAO;gBACX;YACJ,OAAO,IAAI,OAAO,SAAS,YAAY;gBACnC,IAAI,kBAAkB;gBACtB,OAAO,SAAS,QAAQ,EAAE,IAAI;oBAC1B,IAAI,QAAQ;oBACZ,IAAI,IAAI,IAAI,GAAG,IAAI,gBAAgB,MAAM,EAAE,IAAI;wBAC3C,QAAQ,eAAe,CAAC,EAAE,CAAC,IAAI,CAAC,UAAU;oBAC9C;oBACA,OAAO;gBACX;YACJ,OAAO;gBACH,IAAI,sBAAsB;gBAC1B,OAAO,SAAS,QAAQ,EAAE,IAAI;oBAC1B,OAAO,oBAAoB,IAAI,CAAC,UAAU;gBAC9C;YACJ;YACA,IAAI,IAAI,CAAC;QACb;QACA,IAAI,SAAS,GAAG;YACZ,IAAI,SAAS,GAAG;gBACZ,KAAK,GAAG,GAAG,MAAM,GAAG;gBACpB,KAAK,GAAG,GAAG,MAAM,GAAG;YACxB,OAAO,IAAI,SAAS,GAAG;gBACnB,KAAK,KAAK,GAAG;YACjB,OAAO,IAAI,SAAS,GAAG;gBACnB,KAAK,GAAG,GAAG;YACf,OAAO,IAAI,SAAS,GAAG;gBACnB,KAAK,GAAG,GAAG;YACf;YACA,IAAI,WAAW;gBACX,IAAI,SAAS,GAAG;oBACZ,IAAI,IAAI,CAAC,SAAS,QAAQ,EAAE,IAAI;wBAC5B,OAAO,MAAM,GAAG,CAAC,IAAI,CAAC,UAAU;oBACpC;oBACA,IAAI,IAAI,CAAC,SAAS,QAAQ,EAAE,IAAI;wBAC5B,OAAO,MAAM,GAAG,CAAC,IAAI,CAAC,UAAU;oBACpC;gBACJ,OAAO,IAAI,SAAS,GAAG;oBACnB,IAAI,IAAI,CAAC;gBACb,OAAO;oBACH,IAAI,IAAI,CAAC,SAAS,QAAQ,EAAE,IAAI;wBAC5B,OAAO,MAAM,IAAI,CAAC,UAAU;oBAChC;gBACJ;YACJ,OAAO;gBACH,OAAO,cAAc,CAAC,MAAM,MAAM;YACtC;QACJ;IACJ;IACA,SAAS,gBAAgB,KAAK,EAAE,QAAQ,EAAE,QAAQ;QAC9C,IAAI,MAAM,EAAE;QACZ,IAAI;QACJ,IAAI;QACJ,IAAI,yBAAyB,IAAI;QACjC,IAAI,0BAA0B,IAAI;QAClC,IAAI,IAAI,IAAI,GAAG,IAAI,SAAS,MAAM,EAAE,IAAI;YACpC,IAAI,UAAU,QAAQ,CAAC,EAAE;YACzB,IAAI,CAAC,MAAM,OAAO,CAAC,UAAU;YAC7B,IAAI,OAAO,OAAO,CAAC,EAAE;YACrB,IAAI,OAAO,OAAO,CAAC,EAAE;YACrB,IAAI,YAAY,QAAQ,MAAM,GAAG;YACjC,IAAI,WAAW,QAAQ;YACvB,IAAI;YACJ,IAAI;YACJ,IAAI,UAAU;gBACV,OAAO;gBACP,OAAO,OAAO;gBACd,qBAAqB,sBAAsB,EAAE;gBAC7C,eAAe;YACnB,OAAO;gBACH,OAAO,MAAM,SAAS;gBACtB,oBAAoB,qBAAqB,EAAE;gBAC3C,eAAe;YACnB;YACA,IAAI,SAAS,KAAK,CAAC,WAAW;gBAC1B,IAAI,oBAAoB,WAAW,0BAA0B;gBAC7D,IAAI,eAAe,kBAAkB,GAAG,CAAC,SAAS;gBAClD,IAAI,iBAAiB,QAAQ,iBAAiB,KAAK,SAAS,KAAK,iBAAiB,KAAK,SAAS,GAAG;oBAC/F,MAAM,IAAI,MAAM,0MAA0M;gBAC9N,OAAO,IAAI,CAAC,gBAAgB,OAAO,GAAG;oBAClC,kBAAkB,GAAG,CAAC,MAAM;gBAChC,OAAO;oBACH,kBAAkB,GAAG,CAAC,MAAM;gBAChC;YACJ;YACA,eAAe,KAAK,MAAM,SAAS,MAAM,MAAM,UAAU,WAAW,cAAc;QACtF;QACA,iBAAiB,KAAK;QACtB,iBAAiB,KAAK;QACtB,OAAO;IACX;IACA,SAAS,iBAAiB,GAAG,EAAE,YAAY;QACvC,IAAI,cAAc;YACd,IAAI,IAAI,CAAC,SAAS,QAAQ;gBACtB,IAAI,IAAI,IAAI,GAAG,IAAI,aAAa,MAAM,EAAE,IAAI;oBACxC,YAAY,CAAC,EAAE,CAAC,IAAI,CAAC;gBACzB;gBACA,OAAO;YACX;QACJ;IACJ;IACA,SAAS,eAAe,WAAW,EAAE,SAAS,EAAE,QAAQ;QACpD,IAAI,UAAU,MAAM,GAAG,GAAG;YACtB,IAAI,eAAe,EAAE;YACrB,IAAI,WAAW;YACf,IAAI,OAAO,YAAY,IAAI;YAC3B,IAAI,IAAI,IAAI,UAAU,MAAM,GAAG,GAAG,KAAK,GAAG,IAAI;gBAC1C,IAAI,uBAAuB;oBACvB,GAAG;gBACP;gBACA,IAAI;oBACA,IAAI,eAAe,SAAS,CAAC,EAAE,CAAC,UAAU;wBACtC,MAAM;wBACN,MAAM;wBACN,gBAAgB,2BAA2B,cAAc;wBACzD;oBACJ;gBACJ,SAAS;oBACL,qBAAqB,CAAC,GAAG;gBAC7B;gBACA,IAAI,iBAAiB,WAAW;oBAC5B,uBAAuB,IAAI;oBAC3B,WAAW;gBACf;YACJ;YACA,OAAO;gBACH,eAAe,UAAU;gBACzB;oBACI,IAAI,IAAI,IAAI,GAAG,IAAI,aAAa,MAAM,EAAE,IAAI;wBACxC,YAAY,CAAC,EAAE,CAAC,IAAI,CAAC;oBACzB;gBACJ;aACH;QACL;IACJ;IACA,SAAS,eAAe,KAAK,EAAE,QAAQ;QACnC,OAAO,OAAO,cAAc,CAAC,OAAO,OAAO,QAAQ,IAAI,OAAO,GAAG,CAAC,oBAAoB;YAClF,cAAc;YACd,YAAY;YACZ,OAAO;QACX;IACJ;IACA,OAAO,SAAS,eAAe,WAAW,EAAE,UAAU,EAAE,SAAS,EAAE,WAAW;QAC1E,IAAI,gBAAgB,KAAK,GAAG;YACxB,IAAI,iBAAiB,WAAW,CAAC,OAAO,QAAQ,IAAI,OAAO,GAAG,CAAC,mBAAmB;QACtF;QACA,IAAI,WAAW,OAAO,MAAM,CAAC,mBAAmB,KAAK,IAAI,OAAO;QAChE,IAAI,IAAI,gBAAgB,aAAa,YAAY;QACjD,IAAI,CAAC,UAAU,MAAM,EAAE,eAAe,aAAa;QACnD,OAAO;YACH,GAAG;YACH,IAAI,KAAK;gBACL,OAAO,eAAe,aAAa,WAAW;YAClD;QACJ;IACJ;AACJ;AACA,SAAS,mBAAmB,WAAW,EAAE,UAAU,EAAE,SAAS,EAAE,WAAW;IACvE,OAAO,CAAC,qBAAqB,uBAAuB,EAAE,aAAa,YAAY,WAAW;AAC9F;AACA,IAAI;;;;;;;AAgBO,MAAM,mCAAmC,yKAAA,CAAA,iBAAc;IAC9D,MAAM;QACF,CAAC,EAAE,GAAG,CAAC,WAAW,EAAE,GAAG,mBAAmB,IAAI,EAAE;YAC5C;gBACI,oKAAA,CAAA,kBAAe;gBACf;gBACA;aACH;SACJ,EAAE,EAAE,CAAC;IACV,CAAC;IACD,YAAY;IACZ,OAAO;IACP,IAAI;IACJ,sBAAsB;IACtB,IAAI,cAAc;QACd,OAAO,IAAI,CAAC,MAAM,CAAC,WAAW;IAClC;IACA,YAAY,IAAI,CAAC;QACb,KAAK,IAAI,WAAW,IAAI;QACxB,IAAI,CAAC,WAAW,GAAG,KAAK,WAAW;QACnC,IAAI,CAAC,MAAM,GAAG,IAAI,iKAAA,CAAA,mBAAgB,CAAC;YAC/B,aAAa,MAAM;QACvB;QACA,IAAI,CAAC,GAAG,GAAG,gJAAA,CAAA,WAAQ,CAAC,GAAG;QACvB,IAAI,CAAC,qBAAqB,GAAG,MAAM,yBAAyB,kKAAA,CAAA,gCAA6B;IAC7F;IACA,oBAAoB;QAChB,OAAO,CAAC;IACZ;IACA,cAAc;QACV,OAAO;YACH,uBAAuB,IAAI,CAAC,qBAAqB;QACrD;IACJ;IACA,eAAe,WAAW,EAAE;QACxB,IAAI,YAAY,qBAAqB,EAAE;YACnC,IAAI,CAAC,qBAAqB,GAAG,YAAY,qBAAqB;QAClE;IACJ;IACA,MAAM,iBAAiB,WAAW,EAAE,QAAQ,EAAE;QAC1C,MAAM,iBAAiB,CAAA,GAAA,gKAAA,CAAA,oBAAiB,AAAD,EAAE,MAAM,YAAY,WAAW;QACtE,OAAO,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC;YACrB,QAAQ,IAAI,CAAC,qBAAqB,CAAC,MAAM,CAAC;gBACtC,UAAU;gBACV,aAAa;YACjB;QACJ;IACJ;IACA,MAAM,KAAK,MAAM,EAAE;QACf,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,GAAG;QAC5B,MAAM,cAAc,OAAO,WAAW,GAAG,IAAI,iKAAA,CAAA,mBAAgB,CAAC;YAC1D,aAAa,OAAO,WAAW,YAAY,iKAAA,CAAA,aAAU,GAAG,MAAM,OAAO,WAAW,CAAC,WAAW,KAAK,OAAO,WAAW;QACvH,KAAK,IAAI,CAAC,MAAM;QAChB,MAAM,oBAAoB,CAAC,MAAM,IAAI,CAAC,gBAAgB,CAAC,aAAa,CAAA,GAAA,gKAAA,CAAA,cAAW,AAAD,EAAE,SAAS,EAAE,IAAI;QAC/F,YAAY,GAAG,CAAC;YACZ,SAAS;YACT,MAAM;QACV;QACA,IAAI,QAAQ;YACR,MAAM,SAAS,MAAM,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC;gBACxC,OAAO;gBACP,QAAQ;YACZ;YACA,OAAO,CAAA,GAAA,gKAAA,CAAA,gBAAa,AAAD,EAAE;gBACjB;gBACA,cAAc;gBACd,SAAS,CAAC,aAAa,OAAO,eAAe,CAAA,GAAA,gKAAA,CAAA,cAAW,AAAD,EAAE,KAAK,OAAO,CAAC,OAAO;gBAC7E,UAAU,CAAC;oBACP,YAAY,GAAG,CAAC;wBACZ,SAAS;wBACT,MAAM;oBACV;gBACJ;YACJ;QACJ;QACA,MAAM,WAAW,MAAM,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC;YAC1C,OAAO;QACX;QACA,YAAY,GAAG,CAAC;YACZ,SAAS,SAAS,OAAO,CAAC,OAAO;YACjC,MAAM;QACV;QACA,OAAO;IACX;IACA,QAAQ;QACJ,IAAI,CAAC,MAAM,CAAC,KAAK;IACrB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1775, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/engines/chat/index.js"],"sourcesContent":["export * from \"@llamaindex/core/chat-engine\";\nexport { CondenseQuestionChatEngine } from \"./CondenseQuestionChatEngine.js\";\n"],"names":[],"mappings":";AAAA;AACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1796, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/selectors/base.js"],"sourcesContent":["import { PromptMixin } from \"@llamaindex/core/prompts\";\nfunction wrapChoice(choice) {\n    if (typeof choice === \"string\") {\n        return {\n            description: choice\n        };\n    } else {\n        return choice;\n    }\n}\nexport class BaseSelector extends PromptMixin {\n    async select(choices, query) {\n        const metadata = choices.map((choice)=>wrapChoice(choice));\n        return await this._select(metadata, query);\n    }\n}\n"],"names":[],"mappings":";;;AAAA;;AACA,SAAS,WAAW,MAAM;IACtB,IAAI,OAAO,WAAW,UAAU;QAC5B,OAAO;YACH,aAAa;QACjB;IACJ,OAAO;QACH,OAAO;IACX;AACJ;AACO,MAAM,qBAAqB,kKAAA,CAAA,cAAW;IACzC,MAAM,OAAO,OAAO,EAAE,KAAK,EAAE;QACzB,MAAM,WAAW,QAAQ,GAAG,CAAC,CAAC,SAAS,WAAW;QAClD,OAAO,MAAM,IAAI,CAAC,OAAO,CAAC,UAAU;IACxC;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1822, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/OutputParser.js"],"sourcesContent":["/**\n * Error class for output parsing. Due to the nature of LLMs, anytime we use LLM\n * to generate structured output, it's possible that it will hallucinate something\n * that doesn't match the expected output format. So make sure to catch these\n * errors in production.\n */ class OutputParserError extends Error {\n    cause;\n    output;\n    constructor(message, options = {}){\n        super(message, options); // https://github.com/tc39/proposal-error-cause\n        this.name = \"OutputParserError\";\n        if (!this.cause) {\n            // Need to check for those environments that have implemented the proposal\n            this.cause = options.cause;\n        }\n        this.output = options.output;\n        // This line is to maintain proper stack trace in V8\n        // (https://v8.dev/docs/stack-trace-api)\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, OutputParserError);\n        }\n    }\n}\n/**\n *\n * @param text A markdown block with JSON\n * @returns parsed JSON object\n */ export function parseJsonMarkdown(text) {\n    text = text.trim();\n    const left_square = text.indexOf(\"[\");\n    const left_brace = text.indexOf(\"{\");\n    let left;\n    let right;\n    if (left_square < left_brace && left_square != -1) {\n        left = left_square;\n        right = text.lastIndexOf(\"]\");\n    } else {\n        left = left_brace;\n        right = text.lastIndexOf(\"}\");\n    }\n    const jsonText = text.substring(left, right + 1);\n    try {\n        //Single JSON object case\n        if (left_square === -1) {\n            return [\n                JSON.parse(jsonText)\n            ];\n        }\n        //Multiple JSON object case.\n        return JSON.parse(jsonText);\n    } catch (e) {\n        throw new OutputParserError(\"Not a json markdown\", {\n            output: text\n        });\n    }\n}\n/**\n * SubQuestionOutputParser is used to parse the output of the SubQuestionGenerator.\n */ export class SubQuestionOutputParser {\n    parse(output) {\n        const parsed = parseJsonMarkdown(output);\n        return {\n            rawOutput: output,\n            parsedOutput: parsed\n        };\n    }\n    format(output) {\n        return output;\n    }\n}\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;AAAG,MAAM,0BAA0B;IAChC,MAAM;IACN,OAAO;IACP,YAAY,OAAO,EAAE,UAAU,CAAC,CAAC,CAAC;QAC9B,KAAK,CAAC,SAAS,UAAU,+CAA+C;QACxE,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;YACb,0EAA0E;YAC1E,IAAI,CAAC,KAAK,GAAG,QAAQ,KAAK;QAC9B;QACA,IAAI,CAAC,MAAM,GAAG,QAAQ,MAAM;QAC5B,oDAAoD;QACpD,wCAAwC;QACxC,IAAI,MAAM,iBAAiB,EAAE;YACzB,MAAM,iBAAiB,CAAC,IAAI,EAAE;QAClC;IACJ;AACJ;AAKW,SAAS,kBAAkB,IAAI;IACtC,OAAO,KAAK,IAAI;IAChB,MAAM,cAAc,KAAK,OAAO,CAAC;IACjC,MAAM,aAAa,KAAK,OAAO,CAAC;IAChC,IAAI;IACJ,IAAI;IACJ,IAAI,cAAc,cAAc,eAAe,CAAC,GAAG;QAC/C,OAAO;QACP,QAAQ,KAAK,WAAW,CAAC;IAC7B,OAAO;QACH,OAAO;QACP,QAAQ,KAAK,WAAW,CAAC;IAC7B;IACA,MAAM,WAAW,KAAK,SAAS,CAAC,MAAM,QAAQ;IAC9C,IAAI;QACA,yBAAyB;QACzB,IAAI,gBAAgB,CAAC,GAAG;YACpB,OAAO;gBACH,KAAK,KAAK,CAAC;aACd;QACL;QACA,4BAA4B;QAC5B,OAAO,KAAK,KAAK,CAAC;IACtB,EAAE,OAAO,GAAG;QACR,MAAM,IAAI,kBAAkB,uBAAuB;YAC/C,QAAQ;QACZ;IACJ;AACJ;AAGW,MAAM;IACb,MAAM,MAAM,EAAE;QACV,MAAM,SAAS,kBAAkB;QACjC,OAAO;YACH,WAAW;YACX,cAAc;QAClB;IACJ;IACA,OAAO,MAAM,EAAE;QACX,OAAO;IACX;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1896, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/outputParsers/selectors.js"],"sourcesContent":["import { parseJsonMarkdown } from \"../OutputParser.js\";\nconst formatStr = `The output should be ONLY JSON formatted as a JSON instance.\n\nHere is an example:\n[\n    {\n        \"choice\": 1,\n        \"reason\": \"<insert reason for choice>\"\n    },\n    ...\n]\n`;\n/*\n * An OutputParser is used to extract structured data from the raw output of the LLM.\n */ export class SelectionOutputParser {\n    /**\n   *\n   * @param output\n   */ parse(output) {\n        let parsed;\n        try {\n            parsed = parseJsonMarkdown(output);\n        } catch (e) {\n            try {\n                parsed = JSON.parse(output);\n            } catch (e) {\n                throw new Error(`Got invalid JSON object. Error: ${e}. Got JSON string: ${output}`);\n            }\n        }\n        return {\n            rawOutput: output,\n            parsedOutput: parsed\n        };\n    }\n    format(output) {\n        return output + \"\\n\\n\" + formatStr;\n    }\n}\n"],"names":[],"mappings":";;;AAAA;;AACA,MAAM,YAAY,CAAC;;;;;;;;;;AAUnB,CAAC;AAGU,MAAM;IACb;;;GAGD,GAAG,MAAM,MAAM,EAAE;QACZ,IAAI;QACJ,IAAI;YACA,SAAS,CAAA,GAAA,oJAAA,CAAA,oBAAiB,AAAD,EAAE;QAC/B,EAAE,OAAO,GAAG;YACR,IAAI;gBACA,SAAS,KAAK,KAAK,CAAC;YACxB,EAAE,OAAO,GAAG;gBACR,MAAM,IAAI,MAAM,CAAC,gCAAgC,EAAE,EAAE,mBAAmB,EAAE,QAAQ;YACtF;QACJ;QACA,OAAO;YACH,WAAW;YACX,cAAc;QAClB;IACJ;IACA,OAAO,MAAM,EAAE;QACX,OAAO,SAAS,SAAS;IAC7B;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1942, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/selectors/prompts.js"],"sourcesContent":["import { PromptTemplate } from \"@llamaindex/core/prompts\";\nexport const defaultSingleSelectPrompt = new PromptTemplate({\n    templateVars: [\n        \"context\",\n        \"query\",\n        \"numChoices\"\n    ],\n    template: `Some choices are given below. It is provided in a numbered list (1 to {numChoices}), where each item in the list corresponds to a summary.\n---------------------\n{context}\n---------------------\nUsing only the choices above and not prior knowledge, return the choice that is most relevant to the question: '{query}'\n`\n});\nexport const defaultMultiSelectPrompt = new PromptTemplate({\n    templateVars: [\n        \"contextList\",\n        \"query\",\n        \"maxOutputs\",\n        \"numChoices\"\n    ],\n    template: `Some choices are given below. It is provided in a numbered list (1 to {numChoices}), where each item in the list corresponds to a summary.\n---------------------\n{contextList}\n---------------------\nUsing only the choices above and not prior knowledge, return the top choices (no more than {maxOutputs}, but only select what is needed) that are most relevant to the question: '{query}'\n`\n});\n"],"names":[],"mappings":";;;;AAAA;;AACO,MAAM,4BAA4B,IAAI,kKAAA,CAAA,iBAAc,CAAC;IACxD,cAAc;QACV;QACA;QACA;KACH;IACD,UAAU,CAAC;;;;;AAKf,CAAC;AACD;AACO,MAAM,2BAA2B,IAAI,kKAAA,CAAA,iBAAc,CAAC;IACvD,cAAc;QACV;QACA;QACA;QACA;KACH;IACD,UAAU,CAAC;;;;;AAKf,CAAC;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1981, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/selectors/llmSelectors.js"],"sourcesContent":["import { extractText } from \"@llamaindex/core/utils\";\nimport { SelectionOutputParser } from \"../outputParsers/selectors.js\";\nimport { BaseSelector } from \"./base.js\";\nimport { defaultMultiSelectPrompt, defaultSingleSelectPrompt } from \"./prompts.js\";\nfunction buildChoicesText(choices) {\n    const texts = [];\n    for (const [ind, choice] of choices.entries()){\n        let text = choice.description.split(\"\\n\").join(\" \");\n        text = `(${ind + 1}) ${text}`; // to one indexing\n        texts.push(text);\n    }\n    return texts.join(\"\");\n}\nfunction structuredOutputToSelectorResult(output) {\n    const structuredOutput = output;\n    const answers = structuredOutput.parsedOutput;\n    // adjust for zero indexing\n    const selections = answers.map((answer)=>{\n        return {\n            index: answer.choice - 1,\n            reason: answer.reason\n        };\n    });\n    return {\n        selections\n    };\n}\n/**\n * A selector that uses the LLM to select a single or multiple choices from a list of choices.\n */ export class LLMMultiSelector extends BaseSelector {\n    llm;\n    prompt;\n    maxOutputs;\n    outputParser;\n    constructor(init){\n        super();\n        this.llm = init.llm;\n        this.prompt = init.prompt ?? defaultMultiSelectPrompt;\n        this.maxOutputs = init.maxOutputs ?? 10;\n        this.outputParser = init.outputParser ?? new SelectionOutputParser();\n    }\n    _getPrompts() {\n        return {\n            prompt: this.prompt\n        };\n    }\n    _updatePrompts(prompts) {\n        if (\"prompt\" in prompts) {\n            this.prompt = prompts.prompt;\n        }\n    }\n    _getPromptModules() {\n        throw new Error(\"Method not implemented.\");\n    }\n    /**\n   * Selects a single choice from a list of choices.\n   * @param choices\n   * @param query\n   */ async _select(choices, query) {\n        const choicesText = buildChoicesText(choices);\n        const prompt = this.prompt.format({\n            contextList: choicesText,\n            query: extractText(query.query),\n            maxOutputs: `${this.maxOutputs}`,\n            numChoices: `${choicesText.length}`\n        });\n        const formattedPrompt = this.outputParser?.format(prompt);\n        const prediction = await this.llm.complete({\n            prompt: formattedPrompt\n        });\n        const parsed = this.outputParser?.parse(prediction.text);\n        if (!parsed) {\n            throw new Error(\"Parsed output is undefined\");\n        }\n        return structuredOutputToSelectorResult(parsed);\n    }\n    asQueryComponent() {\n        throw new Error(\"Method not implemented.\");\n    }\n}\n/**\n * A selector that uses the LLM to select a single choice from a list of choices.\n */ export class LLMSingleSelector extends BaseSelector {\n    llm;\n    prompt;\n    outputParser;\n    constructor(init){\n        super();\n        this.llm = init.llm;\n        this.prompt = init.prompt ?? defaultSingleSelectPrompt;\n        this.outputParser = init.outputParser ?? new SelectionOutputParser();\n    }\n    _getPrompts() {\n        return {\n            prompt: this.prompt\n        };\n    }\n    _updatePrompts(prompts) {\n        if (\"prompt\" in prompts) {\n            this.prompt = prompts.prompt;\n        }\n    }\n    /**\n   * Selects a single choice from a list of choices.\n   * @param choices\n   * @param query\n   */ async _select(choices, query) {\n        const choicesText = buildChoicesText(choices);\n        const prompt = this.prompt.format({\n            numChoices: `${choicesText.length}`,\n            context: choicesText,\n            query: extractText(query)\n        });\n        const formattedPrompt = this.outputParser.format(prompt);\n        const prediction = await this.llm.complete({\n            prompt: formattedPrompt\n        });\n        const parsed = this.outputParser?.parse(prediction.text);\n        if (!parsed) {\n            throw new Error(\"Parsed output is undefined\");\n        }\n        return structuredOutputToSelectorResult(parsed);\n    }\n    asQueryComponent() {\n        throw new Error(\"Method not implemented.\");\n    }\n    _getPromptModules() {\n        return {};\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2121, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/selectors/utils.js"],"sourcesContent":["import { Settings } from \"../Settings.js\";\nimport { LLMMultiSelector, LLMSingleSelector } from \"./llmSelectors.js\";\nexport const getSelectorFromContext = (isMulti = false)=>{\n    let selector = null;\n    const llm = Settings.llm;\n    if (isMulti) {\n        selector = new LLMMultiSelector({\n            llm\n        });\n    } else {\n        selector = new LLMSingleSelector({\n            llm\n        });\n    }\n    if (selector === null) {\n        throw new Error(\"Selector is null\");\n    }\n    return selector;\n};\n"],"names":[],"mappings":";;;AAAA;AACA;;;AACO,MAAM,yBAAyB,CAAC,UAAU,KAAK;IAClD,IAAI,WAAW;IACf,MAAM,MAAM,gJAAA,CAAA,WAAQ,CAAC,GAAG;IACxB,IAAI,SAAS;QACT,WAAW,IAAI,iKAAA,CAAA,mBAAgB,CAAC;YAC5B;QACJ;IACJ,OAAO;QACH,WAAW,IAAI,iKAAA,CAAA,oBAAiB,CAAC;YAC7B;QACJ;IACJ;IACA,IAAI,aAAa,MAAM;QACnB,MAAM,IAAI,MAAM;IACpB;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2151, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/selectors/index.js"],"sourcesContent":["export * from \"./base.js\";\nexport * from \"./llmSelectors.js\";\nexport * from \"./utils.js\";\n"],"names":[],"mappings":";AAAA;AACA;AACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2175, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/engines/query/RouterQueryEngine.js"],"sourcesContent":["import { BaseQueryEngine } from \"@llamaindex/core/query-engine\";\nimport { getResponseSynthesizer } from \"@llamaindex/core/response-synthesizers\";\nimport { extractText } from \"@llamaindex/core/utils\";\nimport { LLMSingleSelector } from \"../../selectors/index.js\";\nimport { Settings } from \"../../Settings.js\";\nasync function combineResponses(summarizer, responses, queryBundle, verbose = false) {\n    if (verbose) {\n        console.log(\"Combining responses from multiple query engines.\");\n    }\n    const sourceNodes = [];\n    for (const response of responses){\n        if (response?.sourceNodes) {\n            sourceNodes.push(...response.sourceNodes);\n        }\n    }\n    return await summarizer.synthesize({\n        query: queryBundle,\n        nodes: sourceNodes\n    });\n}\n/**\n * A query engine that uses multiple query engines and selects the best one.\n */ export class RouterQueryEngine extends BaseQueryEngine {\n    selector;\n    queryEngines;\n    metadatas;\n    summarizer;\n    verbose;\n    constructor(init){\n        super();\n        this.selector = init.selector;\n        this.queryEngines = init.queryEngineTools.map((tool)=>tool.queryEngine);\n        this.metadatas = init.queryEngineTools.map((tool)=>({\n                description: tool.description\n            }));\n        this.summarizer = init.summarizer || getResponseSynthesizer(\"tree_summarize\");\n        this.verbose = init.verbose ?? false;\n    }\n    async _query(strOrQueryBundle, stream) {\n        const response = await this.queryRoute(typeof strOrQueryBundle === \"string\" ? {\n            query: strOrQueryBundle\n        } : strOrQueryBundle);\n        if (stream) {\n            throw new Error(\"Streaming is not supported yet.\");\n        }\n        return response;\n    }\n    _getPrompts() {\n        return {};\n    }\n    _updatePrompts() {}\n    _getPromptModules() {\n        return {\n            selector: this.selector,\n            summarizer: this.summarizer\n        };\n    }\n    static fromDefaults(init) {\n        return new RouterQueryEngine({\n            selector: init.selector ?? new LLMSingleSelector({\n                llm: Settings.llm\n            }),\n            queryEngineTools: init.queryEngineTools,\n            summarizer: init.summarizer,\n            verbose: init.verbose\n        });\n    }\n    async queryRoute(query) {\n        const result = await this.selector.select(this.metadatas, query);\n        if (result.selections.length > 1) {\n            const responses = [];\n            for(let i = 0; i < result.selections.length; i++){\n                const engineInd = result.selections[i];\n                const logStr = `Selecting query engine ${engineInd.index}: ${result.selections[i].index}.`;\n                if (this.verbose) {\n                    console.log(logStr + \"\\n\");\n                }\n                const selectedQueryEngine = this.queryEngines[engineInd.index];\n                responses.push(await selectedQueryEngine.query({\n                    query,\n                    stream: false\n                }));\n            }\n            if (responses.length > 1) {\n                const finalResponse = await combineResponses(this.summarizer, responses, query, this.verbose);\n                return finalResponse;\n            } else {\n                return responses[0];\n            }\n        } else {\n            let selectedQueryEngine;\n            try {\n                selectedQueryEngine = this.queryEngines[result.selections[0].index];\n                const logStr = `Selecting query engine ${result.selections[0].index}: ${result.selections[0].reason}`;\n                if (this.verbose) {\n                    console.log(logStr + \"\\n\");\n                }\n            } catch (e) {\n                throw new Error(\"Failed to select query engine\");\n            }\n            if (!selectedQueryEngine) {\n                throw new Error(\"Selected query engine is null\");\n            }\n            const finalResponse = await selectedQueryEngine.query({\n                query: extractText(query)\n            });\n            // add selected result\n            finalResponse.metadata = finalResponse.metadata || {};\n            finalResponse.metadata[\"selectorResult\"] = result;\n            return finalResponse;\n        }\n    }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AAAA;AACA;;;;;;AACA,eAAe,iBAAiB,UAAU,EAAE,SAAS,EAAE,WAAW,EAAE,UAAU,KAAK;IAC/E,IAAI,SAAS;QACT,QAAQ,GAAG,CAAC;IAChB;IACA,MAAM,cAAc,EAAE;IACtB,KAAK,MAAM,YAAY,UAAU;QAC7B,IAAI,UAAU,aAAa;YACvB,YAAY,IAAI,IAAI,SAAS,WAAW;QAC5C;IACJ;IACA,OAAO,MAAM,WAAW,UAAU,CAAC;QAC/B,OAAO;QACP,OAAO;IACX;AACJ;AAGW,MAAM,0BAA0B,0KAAA,CAAA,kBAAe;IACtD,SAAS;IACT,aAAa;IACb,UAAU;IACV,WAAW;IACX,QAAQ;IACR,YAAY,IAAI,CAAC;QACb,KAAK;QACL,IAAI,CAAC,QAAQ,GAAG,KAAK,QAAQ;QAC7B,IAAI,CAAC,YAAY,GAAG,KAAK,gBAAgB,CAAC,GAAG,CAAC,CAAC,OAAO,KAAK,WAAW;QACtE,IAAI,CAAC,SAAS,GAAG,KAAK,gBAAgB,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC;gBAC5C,aAAa,KAAK,WAAW;YACjC,CAAC;QACL,IAAI,CAAC,UAAU,GAAG,KAAK,UAAU,IAAI,CAAA,GAAA,mLAAA,CAAA,yBAAsB,AAAD,EAAE;QAC5D,IAAI,CAAC,OAAO,GAAG,KAAK,OAAO,IAAI;IACnC;IACA,MAAM,OAAO,gBAAgB,EAAE,MAAM,EAAE;QACnC,MAAM,WAAW,MAAM,IAAI,CAAC,UAAU,CAAC,OAAO,qBAAqB,WAAW;YAC1E,OAAO;QACX,IAAI;QACJ,IAAI,QAAQ;YACR,MAAM,IAAI,MAAM;QACpB;QACA,OAAO;IACX;IACA,cAAc;QACV,OAAO,CAAC;IACZ;IACA,iBAAiB,CAAC;IAClB,oBAAoB;QAChB,OAAO;YACH,UAAU,IAAI,CAAC,QAAQ;YACvB,YAAY,IAAI,CAAC,UAAU;QAC/B;IACJ;IACA,OAAO,aAAa,IAAI,EAAE;QACtB,OAAO,IAAI,kBAAkB;YACzB,UAAU,KAAK,QAAQ,IAAI,IAAI,iKAAA,CAAA,oBAAiB,CAAC;gBAC7C,KAAK,gJAAA,CAAA,WAAQ,CAAC,GAAG;YACrB;YACA,kBAAkB,KAAK,gBAAgB;YACvC,YAAY,KAAK,UAAU;YAC3B,SAAS,KAAK,OAAO;QACzB;IACJ;IACA,MAAM,WAAW,KAAK,EAAE;QACpB,MAAM,SAAS,MAAM,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,EAAE;QAC1D,IAAI,OAAO,UAAU,CAAC,MAAM,GAAG,GAAG;YAC9B,MAAM,YAAY,EAAE;YACpB,IAAI,IAAI,IAAI,GAAG,IAAI,OAAO,UAAU,CAAC,MAAM,EAAE,IAAI;gBAC7C,MAAM,YAAY,OAAO,UAAU,CAAC,EAAE;gBACtC,MAAM,SAAS,CAAC,uBAAuB,EAAE,UAAU,KAAK,CAAC,EAAE,EAAE,OAAO,UAAU,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC;gBAC1F,IAAI,IAAI,CAAC,OAAO,EAAE;oBACd,QAAQ,GAAG,CAAC,SAAS;gBACzB;gBACA,MAAM,sBAAsB,IAAI,CAAC,YAAY,CAAC,UAAU,KAAK,CAAC;gBAC9D,UAAU,IAAI,CAAC,MAAM,oBAAoB,KAAK,CAAC;oBAC3C;oBACA,QAAQ;gBACZ;YACJ;YACA,IAAI,UAAU,MAAM,GAAG,GAAG;gBACtB,MAAM,gBAAgB,MAAM,iBAAiB,IAAI,CAAC,UAAU,EAAE,WAAW,OAAO,IAAI,CAAC,OAAO;gBAC5F,OAAO;YACX,OAAO;gBACH,OAAO,SAAS,CAAC,EAAE;YACvB;QACJ,OAAO;YACH,IAAI;YACJ,IAAI;gBACA,sBAAsB,IAAI,CAAC,YAAY,CAAC,OAAO,UAAU,CAAC,EAAE,CAAC,KAAK,CAAC;gBACnE,MAAM,SAAS,CAAC,uBAAuB,EAAE,OAAO,UAAU,CAAC,EAAE,CAAC,KAAK,CAAC,EAAE,EAAE,OAAO,UAAU,CAAC,EAAE,CAAC,MAAM,EAAE;gBACrG,IAAI,IAAI,CAAC,OAAO,EAAE;oBACd,QAAQ,GAAG,CAAC,SAAS;gBACzB;YACJ,EAAE,OAAO,GAAG;gBACR,MAAM,IAAI,MAAM;YACpB;YACA,IAAI,CAAC,qBAAqB;gBACtB,MAAM,IAAI,MAAM;YACpB;YACA,MAAM,gBAAgB,MAAM,oBAAoB,KAAK,CAAC;gBAClD,OAAO,CAAA,GAAA,gKAAA,CAAA,cAAW,AAAD,EAAE;YACvB;YACA,sBAAsB;YACtB,cAAc,QAAQ,GAAG,cAAc,QAAQ,IAAI,CAAC;YACpD,cAAc,QAAQ,CAAC,iBAAiB,GAAG;YAC3C,OAAO;QACX;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2301, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/QuestionGenerator.js"],"sourcesContent":["import { defaultSubQuestionPrompt, PromptMixin } from \"@llamaindex/core/prompts\";\nimport { extractText, toToolDescriptions } from \"@llamaindex/core/utils\";\nimport { OpenAI } from \"@llamaindex/openai\";\nimport { SubQuestionOutputParser } from \"./OutputParser.js\";\n/**\n * LLMQuestionGenerator uses the LLM to generate new questions for the LLM using tools and a user query.\n */ export class LLMQuestionGenerator extends PromptMixin {\n    llm;\n    prompt;\n    outputParser;\n    constructor(init){\n        super();\n        this.llm = init?.llm ?? new OpenAI();\n        this.prompt = init?.prompt ?? defaultSubQuestionPrompt;\n        this.outputParser = init?.outputParser ?? new SubQuestionOutputParser();\n    }\n    _getPrompts() {\n        return {\n            subQuestion: this.prompt\n        };\n    }\n    _updatePrompts(promptsDict) {\n        if (\"subQuestion\" in promptsDict) {\n            this.prompt = promptsDict.subQuestion;\n        }\n    }\n    async generate(tools, query) {\n        const toolsStr = toToolDescriptions(tools);\n        const queryStr = extractText(query);\n        const prediction = (await this.llm.complete({\n            prompt: this.prompt.format({\n                toolsStr,\n                queryStr\n            })\n        })).text;\n        const structuredOutput = this.outputParser.parse(prediction);\n        return structuredOutput.parsedOutput;\n    }\n    _getPromptModules() {\n        return {};\n    }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;;;;;AAGW,MAAM,6BAA6B,kKAAA,CAAA,cAAW;IACrD,IAAI;IACJ,OAAO;IACP,aAAa;IACb,YAAY,IAAI,CAAC;QACb,KAAK;QACL,IAAI,CAAC,GAAG,GAAG,MAAM,OAAO,IAAI,yJAAA,CAAA,SAAM;QAClC,IAAI,CAAC,MAAM,GAAG,MAAM,UAAU,kKAAA,CAAA,2BAAwB;QACtD,IAAI,CAAC,YAAY,GAAG,MAAM,gBAAgB,IAAI,oJAAA,CAAA,0BAAuB;IACzE;IACA,cAAc;QACV,OAAO;YACH,aAAa,IAAI,CAAC,MAAM;QAC5B;IACJ;IACA,eAAe,WAAW,EAAE;QACxB,IAAI,iBAAiB,aAAa;YAC9B,IAAI,CAAC,MAAM,GAAG,YAAY,WAAW;QACzC;IACJ;IACA,MAAM,SAAS,KAAK,EAAE,KAAK,EAAE;QACzB,MAAM,WAAW,CAAA,GAAA,gKAAA,CAAA,qBAAkB,AAAD,EAAE;QACpC,MAAM,WAAW,CAAA,GAAA,gKAAA,CAAA,cAAW,AAAD,EAAE;QAC7B,MAAM,aAAa,CAAC,MAAM,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC;YACxC,QAAQ,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC;gBACvB;gBACA;YACJ;QACJ,EAAE,EAAE,IAAI;QACR,MAAM,mBAAmB,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC;QACjD,OAAO,iBAAiB,YAAY;IACxC;IACA,oBAAoB;QAChB,OAAO,CAAC;IACZ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2354, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/engines/query/SubQuestionQueryEngine.js"],"sourcesContent":["import { getResponseSynthesizer } from \"@llamaindex/core/response-synthesizers\";\nimport { TextNode } from \"@llamaindex/core/schema\";\nimport { LLMQuestionGenerator } from \"../../QuestionGenerator.js\";\nimport { BaseQueryEngine } from \"@llamaindex/core/query-engine\";\n/**\n * SubQuestionQueryEngine decomposes a question into subquestions and then\n */ export class SubQuestionQueryEngine extends BaseQueryEngine {\n    responseSynthesizer;\n    questionGen;\n    queryEngines;\n    metadatas;\n    constructor(init){\n        super();\n        this.questionGen = init.questionGen;\n        this.responseSynthesizer = init.responseSynthesizer ?? getResponseSynthesizer(\"compact\");\n        this.queryEngines = init.queryEngineTools;\n        this.metadatas = init.queryEngineTools.map((tool)=>tool.metadata);\n    }\n    async _query(strOrQueryBundle, stream) {\n        let query;\n        if (typeof strOrQueryBundle === \"string\") {\n            query = {\n                query: strOrQueryBundle\n            };\n        } else {\n            query = strOrQueryBundle;\n        }\n        const subQuestions = await this.questionGen.generate(this.metadatas, strOrQueryBundle);\n        const subQNodes = await Promise.all(subQuestions.map((subQ)=>this.querySubQ(subQ)));\n        const nodesWithScore = subQNodes.filter((node)=>node !== null);\n        if (stream) {\n            return this.responseSynthesizer.synthesize({\n                query,\n                nodes: nodesWithScore\n            }, true);\n        }\n        return this.responseSynthesizer.synthesize({\n            query,\n            nodes: nodesWithScore\n        }, false);\n    }\n    _getPrompts() {\n        return {};\n    }\n    _updatePrompts() {}\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _getPromptModules() {\n        return {\n            questionGen: this.questionGen,\n            responseSynthesizer: this.responseSynthesizer\n        };\n    }\n    static fromDefaults(init) {\n        const questionGen = init.questionGen ?? new LLMQuestionGenerator();\n        const responseSynthesizer = init.responseSynthesizer ?? getResponseSynthesizer(\"compact\");\n        return new SubQuestionQueryEngine({\n            questionGen,\n            responseSynthesizer,\n            queryEngineTools: init.queryEngineTools\n        });\n    }\n    async querySubQ(subQ) {\n        try {\n            const question = subQ.subQuestion;\n            const queryEngine = this.queryEngines.find((tool)=>tool.metadata.name === subQ.toolName);\n            if (!queryEngine) {\n                return null;\n            }\n            const responseValue = await queryEngine?.call?.({\n                query: question\n            });\n            if (responseValue == null) {\n                return null;\n            }\n            const nodeText = `Sub question: ${question}\\nResponse: ${typeof responseValue === \"string\" ? responseValue : JSON.stringify(responseValue)}`;\n            const node = new TextNode({\n                text: nodeText\n            });\n            return {\n                node,\n                score: 0\n            };\n        } catch (error) {\n            return null;\n        }\n    }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;;;;;AAGW,MAAM,+BAA+B,0KAAA,CAAA,kBAAe;IAC3D,oBAAoB;IACpB,YAAY;IACZ,aAAa;IACb,UAAU;IACV,YAAY,IAAI,CAAC;QACb,KAAK;QACL,IAAI,CAAC,WAAW,GAAG,KAAK,WAAW;QACnC,IAAI,CAAC,mBAAmB,GAAG,KAAK,mBAAmB,IAAI,CAAA,GAAA,mLAAA,CAAA,yBAAsB,AAAD,EAAE;QAC9E,IAAI,CAAC,YAAY,GAAG,KAAK,gBAAgB;QACzC,IAAI,CAAC,SAAS,GAAG,KAAK,gBAAgB,CAAC,GAAG,CAAC,CAAC,OAAO,KAAK,QAAQ;IACpE;IACA,MAAM,OAAO,gBAAgB,EAAE,MAAM,EAAE;QACnC,IAAI;QACJ,IAAI,OAAO,qBAAqB,UAAU;YACtC,QAAQ;gBACJ,OAAO;YACX;QACJ,OAAO;YACH,QAAQ;QACZ;QACA,MAAM,eAAe,MAAM,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,EAAE;QACrE,MAAM,YAAY,MAAM,QAAQ,GAAG,CAAC,aAAa,GAAG,CAAC,CAAC,OAAO,IAAI,CAAC,SAAS,CAAC;QAC5E,MAAM,iBAAiB,UAAU,MAAM,CAAC,CAAC,OAAO,SAAS;QACzD,IAAI,QAAQ;YACR,OAAO,IAAI,CAAC,mBAAmB,CAAC,UAAU,CAAC;gBACvC;gBACA,OAAO;YACX,GAAG;QACP;QACA,OAAO,IAAI,CAAC,mBAAmB,CAAC,UAAU,CAAC;YACvC;YACA,OAAO;QACX,GAAG;IACP;IACA,cAAc;QACV,OAAO,CAAC;IACZ;IACA,iBAAiB,CAAC;IAClB,8DAA8D;IAC9D,oBAAoB;QAChB,OAAO;YACH,aAAa,IAAI,CAAC,WAAW;YAC7B,qBAAqB,IAAI,CAAC,mBAAmB;QACjD;IACJ;IACA,OAAO,aAAa,IAAI,EAAE;QACtB,MAAM,cAAc,KAAK,WAAW,IAAI,IAAI,yJAAA,CAAA,uBAAoB;QAChE,MAAM,sBAAsB,KAAK,mBAAmB,IAAI,CAAA,GAAA,mLAAA,CAAA,yBAAsB,AAAD,EAAE;QAC/E,OAAO,IAAI,uBAAuB;YAC9B;YACA;YACA,kBAAkB,KAAK,gBAAgB;QAC3C;IACJ;IACA,MAAM,UAAU,IAAI,EAAE;QAClB,IAAI;YACA,MAAM,WAAW,KAAK,WAAW;YACjC,MAAM,cAAc,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,OAAO,KAAK,QAAQ,CAAC,IAAI,KAAK,KAAK,QAAQ;YACvF,IAAI,CAAC,aAAa;gBACd,OAAO;YACX;YACA,MAAM,gBAAgB,MAAM,aAAa,OAAO;gBAC5C,OAAO;YACX;YACA,IAAI,iBAAiB,MAAM;gBACvB,OAAO;YACX;YACA,MAAM,WAAW,CAAC,cAAc,EAAE,SAAS,YAAY,EAAE,OAAO,kBAAkB,WAAW,gBAAgB,KAAK,SAAS,CAAC,gBAAgB;YAC5I,MAAM,OAAO,IAAI,iKAAA,CAAA,WAAQ,CAAC;gBACtB,MAAM;YACV;YACA,OAAO;gBACH;gBACA,OAAO;YACX;QACJ,EAAE,OAAO,OAAO;YACZ,OAAO;QACX;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2452, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/engines/query/index.js"],"sourcesContent":["export * from \"./RetrieverQueryEngine.js\";\nexport * from \"./RouterQueryEngine.js\";\nexport * from \"./SubQuestionQueryEngine.js\";\n"],"names":[],"mappings":";AAAA;AACA;AACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2476, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/evaluation/prompts.js"],"sourcesContent":["import { PromptTemplate } from \"@llamaindex/core/prompts\";\nexport const defaultUserPrompt = new PromptTemplate({\n    templateVars: [\n        \"query\",\n        \"referenceAnswer\",\n        \"generatedAnswer\"\n    ],\n    template: `\n## User Query\n{query}\n\n## Reference Answer\n{referenceAnswer}\n\n## Generated Answer\n{generatedAnswer}\n`\n});\nexport const defaultCorrectnessSystemPrompt = new PromptTemplate({\n    template: `You are an expert evaluation system for a question answering chatbot.\n\nYou are given the following information:\n- a user query, and\n- a generated answer\n\nYou may also be given a reference answer to use for reference in your evaluation.\n\nYour job is to judge the relevance and correctness of the generated answer.\nOutput a single score that represents a holistic evaluation.\nYou must return your response in a line with only the score.\nDo not return answers in any other format.\nOn a separate line provide your reasoning for the score as well.\n\nFollow these guidelines for scoring:\n- Your score has to be between 1 and 5, where 1 is the worst and 5 is the best.\n- If the generated answer is not relevant to the user query,\nyou should give a score of 1.\n- If the generated answer is relevant but contains mistakes,\nyou should give a score between 2 and 3.\n- If the generated answer is relevant and fully correct,\nyou should give a score between 4 and 5.\n\nExample Response:\n4.0\nThe generated answer has the exact same metrics as the reference answer\nbut it is not as concise.\n`\n});\nexport const defaultFaithfulnessRefinePrompt = new PromptTemplate({\n    templateVars: [\n        \"query\",\n        \"existingAnswer\",\n        \"context\"\n    ],\n    template: `\nWe want to understand if the following information is present\nin the context information: {query}\nWe have provided an existing YES/NO answer: {existingAnswer}\nWe have the opportunity to refine the existing answer\n(only if needed) with some more context below.\n------------\n{context}\n------------\nIf the existing answer was already YES, still answer YES.\nIf the information is present in the new context, answer YES.\nOtherwise answer NO.\n`\n});\nexport const defaultFaithfulnessTextQaPrompt = new PromptTemplate({\n    templateVars: [\n        \"context\",\n        \"query\"\n    ],\n    template: `\nPlease tell if a given piece of information\nis supported by the context.\nYou need to answer with either YES or NO.\nAnswer YES if any of the context supports the information, even\nif most of the context is unrelated.\nSome examples are provided below.\n\nInformation: Apple pie is generally double-crusted.\nContext: An apple pie is a fruit pie in which the principal filling\ningredient is apples.\nApple pie is often served with whipped cream, ice cream\n('apple pie  la mode'), custard or cheddar cheese.\nIt is generally double-crusted, with pastry both above\nand below the filling; the upper crust may be solid or\nlatticed (woven of crosswise strips).\nAnswer: YES\nInformation: Apple pies tastes bad.\nContext: An apple pie is a fruit pie in which the principal filling\ningredient is apples.\nApple pie is often served with whipped cream, ice cream\n('apple pie  la mode'), custard or cheddar cheese.\nIt is generally double-crusted, with pastry both above\nand below the filling; the upper crust may be solid or\nlatticed (woven of crosswise strips).\nAnswer: NO\nInformation: {query}\nContext: {context}\nAnswer:\n`\n});\nexport const defaultRelevancyEvalPrompt = new PromptTemplate({\n    templateVars: [\n        \"context\",\n        \"query\"\n    ],\n    template: `Your task is to evaluate if the response for the query is in line with the context information provided.\nYou have two options to answer. Either YES/ NO.\nAnswer - YES, if the response for the query is in line with context information otherwise NO.\nQuery and Response: {query}\nContext: {context}\nAnswer: `\n});\nexport const defaultRelevancyRefinePrompt = new PromptTemplate({\n    templateVars: [\n        \"query\",\n        \"existingAnswer\",\n        \"contextMsg\"\n    ],\n    template: `We want to understand if the following query and response is\nin line with the context information: \n{query}\nWe have provided an existing YES/NO answer: \n{existingAnswer}\nWe have the opportunity to refine the existing answer\n(only if needed) with some more context below.\n------------\n{contextMsg}\n------------\nIf the existing answer was already YES, still answer YES.\nIf the information is present in the new context, answer YES.\nOtherwise answer NO.\n`\n});\n"],"names":[],"mappings":";;;;;;;;AAAA;;AACO,MAAM,oBAAoB,IAAI,kKAAA,CAAA,iBAAc,CAAC;IAChD,cAAc;QACV;QACA;QACA;KACH;IACD,UAAU,CAAC;;;;;;;;;AASf,CAAC;AACD;AACO,MAAM,iCAAiC,IAAI,kKAAA,CAAA,iBAAc,CAAC;IAC7D,UAAU,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2Bf,CAAC;AACD;AACO,MAAM,kCAAkC,IAAI,kKAAA,CAAA,iBAAc,CAAC;IAC9D,cAAc;QACV;QACA;QACA;KACH;IACD,UAAU,CAAC;;;;;;;;;;;;AAYf,CAAC;AACD;AACO,MAAM,kCAAkC,IAAI,kKAAA,CAAA,iBAAc,CAAC;IAC9D,cAAc;QACV;QACA;KACH;IACD,UAAU,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6Bf,CAAC;AACD;AACO,MAAM,6BAA6B,IAAI,kKAAA,CAAA,iBAAc,CAAC;IACzD,cAAc;QACV;QACA;KACH;IACD,UAAU,CAAC;;;;;QAKP,CAAC;AACT;AACO,MAAM,+BAA+B,IAAI,kKAAA,CAAA,iBAAc,CAAC;IAC3D,cAAc;QACV;QACA;QACA;KACH;IACD,UAAU,CAAC;;;;;;;;;;;;;AAaf,CAAC;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2628, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/evaluation/utils.js"],"sourcesContent":["export const defaultEvaluationParser = (evalResponse)=>{\n    const [scoreStr, reasoningStr] = evalResponse.split(\"\\n\");\n    const score = parseFloat(scoreStr);\n    const reasoning = reasoningStr.trim();\n    return [\n        score,\n        reasoning\n    ];\n};\n"],"names":[],"mappings":";;;AAAO,MAAM,0BAA0B,CAAC;IACpC,MAAM,CAAC,UAAU,aAAa,GAAG,aAAa,KAAK,CAAC;IACpD,MAAM,QAAQ,WAAW;IACzB,MAAM,YAAY,aAAa,IAAI;IACnC,OAAO;QACH;QACA;KACH;AACL","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2646, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/evaluation/Correctness.js"],"sourcesContent":["import { PromptMixin } from \"@llamaindex/core/prompts\";\nimport { MetadataMode } from \"@llamaindex/core/schema\";\nimport { extractText } from \"@llamaindex/core/utils\";\nimport { Settings } from \"../Settings.js\";\nimport { defaultCorrectnessSystemPrompt, defaultUserPrompt } from \"./prompts.js\";\nimport { defaultEvaluationParser } from \"./utils.js\";\n/** Correctness Evaluator */ export class CorrectnessEvaluator extends PromptMixin {\n    scoreThreshold;\n    parserFunction;\n    llm;\n    correctnessPrompt = defaultCorrectnessSystemPrompt;\n    constructor(params){\n        super();\n        this.llm = Settings.llm;\n        this.correctnessPrompt = defaultCorrectnessSystemPrompt;\n        this.scoreThreshold = params?.scoreThreshold ?? 4.0;\n        this.parserFunction = params?.parserFunction ?? defaultEvaluationParser;\n    }\n    _getPrompts() {\n        return {\n            correctnessPrompt: this.correctnessPrompt\n        };\n    }\n    _getPromptModules() {\n        return {};\n    }\n    _updatePrompts(prompts) {\n        if (\"correctnessPrompt\" in prompts) {\n            this.correctnessPrompt = prompts[\"correctnessPrompt\"];\n        }\n    }\n    /**\n   *\n   * @param query Query to evaluate\n   * @param response  Response to evaluate\n   * @param contexts Array of contexts\n   * @param reference  Reference response\n   */ async evaluate({ query, response, contexts, reference }) {\n        if (query === null || response === null) {\n            throw new Error(\"query, and response must be provided\");\n        }\n        const messages = [\n            {\n                role: \"system\",\n                content: this.correctnessPrompt.format()\n            },\n            {\n                role: \"user\",\n                content: defaultUserPrompt.format({\n                    query: extractText(query),\n                    generatedAnswer: response,\n                    referenceAnswer: reference || \"(NO REFERENCE ANSWER SUPPLIED)\"\n                })\n            }\n        ];\n        const evalResponse = await this.llm.chat({\n            messages\n        });\n        const [score, reasoning] = this.parserFunction(extractText(evalResponse.message.content));\n        return {\n            query: query,\n            response: response,\n            passing: score >= this.scoreThreshold || score === null,\n            score: score,\n            feedback: reasoning\n        };\n    }\n    /**\n   * @param query Query to evaluate\n   * @param response  Response to evaluate\n   */ async evaluateResponse({ query, response }) {\n        const responseStr = extractText(response?.message.content);\n        const contexts = [];\n        if (response) {\n            for (const node of response.sourceNodes || []){\n                contexts.push(node.node.getContent(MetadataMode.ALL));\n            }\n        }\n        return this.evaluate({\n            query,\n            response: responseStr,\n            contexts\n        });\n    }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AACoC,MAAM,6BAA6B,kKAAA,CAAA,cAAW;IAC9E,eAAe;IACf,eAAe;IACf,IAAI;IACJ,oBAAoB,6JAAA,CAAA,iCAA8B,CAAC;IACnD,YAAY,MAAM,CAAC;QACf,KAAK;QACL,IAAI,CAAC,GAAG,GAAG,gJAAA,CAAA,WAAQ,CAAC,GAAG;QACvB,IAAI,CAAC,iBAAiB,GAAG,6JAAA,CAAA,iCAA8B;QACvD,IAAI,CAAC,cAAc,GAAG,QAAQ,kBAAkB;QAChD,IAAI,CAAC,cAAc,GAAG,QAAQ,kBAAkB,2JAAA,CAAA,0BAAuB;IAC3E;IACA,cAAc;QACV,OAAO;YACH,mBAAmB,IAAI,CAAC,iBAAiB;QAC7C;IACJ;IACA,oBAAoB;QAChB,OAAO,CAAC;IACZ;IACA,eAAe,OAAO,EAAE;QACpB,IAAI,uBAAuB,SAAS;YAChC,IAAI,CAAC,iBAAiB,GAAG,OAAO,CAAC,oBAAoB;QACzD;IACJ;IACA;;;;;;GAMD,GAAG,MAAM,SAAS,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,SAAS,EAAE,EAAE;QACvD,IAAI,UAAU,QAAQ,aAAa,MAAM;YACrC,MAAM,IAAI,MAAM;QACpB;QACA,MAAM,WAAW;YACb;gBACI,MAAM;gBACN,SAAS,IAAI,CAAC,iBAAiB,CAAC,MAAM;YAC1C;YACA;gBACI,MAAM;gBACN,SAAS,6JAAA,CAAA,oBAAiB,CAAC,MAAM,CAAC;oBAC9B,OAAO,CAAA,GAAA,gKAAA,CAAA,cAAW,AAAD,EAAE;oBACnB,iBAAiB;oBACjB,iBAAiB,aAAa;gBAClC;YACJ;SACH;QACD,MAAM,eAAe,MAAM,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC;YACrC;QACJ;QACA,MAAM,CAAC,OAAO,UAAU,GAAG,IAAI,CAAC,cAAc,CAAC,CAAA,GAAA,gKAAA,CAAA,cAAW,AAAD,EAAE,aAAa,OAAO,CAAC,OAAO;QACvF,OAAO;YACH,OAAO;YACP,UAAU;YACV,SAAS,SAAS,IAAI,CAAC,cAAc,IAAI,UAAU;YACnD,OAAO;YACP,UAAU;QACd;IACJ;IACA;;;GAGD,GAAG,MAAM,iBAAiB,EAAE,KAAK,EAAE,QAAQ,EAAE,EAAE;QAC1C,MAAM,cAAc,CAAA,GAAA,gKAAA,CAAA,cAAW,AAAD,EAAE,UAAU,QAAQ;QAClD,MAAM,WAAW,EAAE;QACnB,IAAI,UAAU;YACV,KAAK,MAAM,QAAQ,SAAS,WAAW,IAAI,EAAE,CAAC;gBAC1C,SAAS,IAAI,CAAC,KAAK,IAAI,CAAC,UAAU,CAAC,iKAAA,CAAA,eAAY,CAAC,GAAG;YACvD;QACJ;QACA,OAAO,IAAI,CAAC,QAAQ,CAAC;YACjB;YACA,UAAU;YACV;QACJ;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2746, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/storage/FileSystem.js"],"sourcesContent":["// FS utility helpers\nimport { fs } from \"@llamaindex/env\";\n/**\n * Checks if a file exists.\n * Analogous to the os.path.exists function from Python.\n * @param path The path to the file to check.\n * @returns A promise that resolves to true if the file exists, false otherwise.\n */ export async function exists(path) {\n    try {\n        await fs.access(path);\n        return true;\n    } catch  {\n        return false;\n    }\n}\n/**\n * Recursively traverses a directory and yields all the paths to the files in it.\n * @param dirPath The path to the directory to traverse.\n */ export async function* walk(dirPath) {\n    const entries = await fs.readdir(dirPath);\n    for (const entry of entries){\n        const fullPath = `${dirPath}/${entry}`;\n        const stats = await fs.stat(fullPath);\n        if (stats.isDirectory()) {\n            yield* walk(fullPath);\n        } else {\n            yield fullPath;\n        }\n    }\n}\n"],"names":[],"mappings":"AAAA,qBAAqB;;;;;AACrB;AAAA;;AAMW,eAAe,OAAO,IAAI;IACjC,IAAI;QACA,MAAM,sKAAA,CAAA,KAAE,CAAC,MAAM,CAAC;QAChB,OAAO;IACX,EAAE,OAAO;QACL,OAAO;IACX;AACJ;AAIW,gBAAgB,KAAK,OAAO;IACnC,MAAM,UAAU,MAAM,sKAAA,CAAA,KAAE,CAAC,OAAO,CAAC;IACjC,KAAK,MAAM,SAAS,QAAQ;QACxB,MAAM,WAAW,GAAG,QAAQ,CAAC,EAAE,OAAO;QACtC,MAAM,QAAQ,MAAM,sKAAA,CAAA,KAAE,CAAC,IAAI,CAAC;QAC5B,IAAI,MAAM,WAAW,IAAI;YACrB,OAAO,KAAK;QAChB,OAAO;YACH,MAAM;QACV;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2780, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/vector-store/SimpleVectorStore.js"],"sourcesContent":["import { getTopKEmbeddings, getTopKMMREmbeddings } from \"@llamaindex/core/embeddings\";\nimport { DEFAULT_PERSIST_DIR } from \"@llamaindex/core/global\";\nimport { BaseVectorStore, FilterOperator, nodeToMetadata, parseArrayValue, parsePrimitiveValue, VectorStoreQueryMode } from \"@llamaindex/core/vector-store\";\nimport { fs, path } from \"@llamaindex/env\";\nimport { exists } from \"../storage/FileSystem.js\";\nconst LEARNER_MODES = new Set([\n    VectorStoreQueryMode.SVM,\n    VectorStoreQueryMode.LINEAR_REGRESSION,\n    VectorStoreQueryMode.LOGISTIC_REGRESSION\n]);\nconst MMR_MODE = VectorStoreQueryMode.MMR;\n// Mapping of filter operators to metadata filter functions\nconst OPERATOR_TO_FILTER = {\n    [FilterOperator.EQ]: ({ key, value }, metadata)=>{\n        return metadata[key] === parsePrimitiveValue(value);\n    },\n    [FilterOperator.NE]: ({ key, value }, metadata)=>{\n        return metadata[key] !== parsePrimitiveValue(value);\n    },\n    [FilterOperator.IN]: ({ key, value }, metadata)=>{\n        return !!parseArrayValue(value).find((v)=>metadata[key] === v);\n    },\n    [FilterOperator.NIN]: ({ key, value }, metadata)=>{\n        return !parseArrayValue(value).find((v)=>metadata[key] === v);\n    },\n    [FilterOperator.ANY]: ({ key, value }, metadata)=>{\n        if (!Array.isArray(metadata[key])) return false;\n        return parseArrayValue(value).some((v)=>metadata[key].includes(v));\n    },\n    [FilterOperator.ALL]: ({ key, value }, metadata)=>{\n        if (!Array.isArray(metadata[key])) return false;\n        return parseArrayValue(value).every((v)=>metadata[key].includes(v));\n    },\n    [FilterOperator.TEXT_MATCH]: ({ key, value }, metadata)=>{\n        return metadata[key].includes(parsePrimitiveValue(value));\n    },\n    [FilterOperator.CONTAINS]: ({ key, value }, metadata)=>{\n        if (!Array.isArray(metadata[key])) return false;\n        return !!parseArrayValue(metadata[key]).find((v)=>v === value);\n    },\n    [FilterOperator.GT]: ({ key, value }, metadata)=>{\n        return metadata[key] > parsePrimitiveValue(value);\n    },\n    [FilterOperator.LT]: ({ key, value }, metadata)=>{\n        return metadata[key] < parsePrimitiveValue(value);\n    },\n    [FilterOperator.GTE]: ({ key, value }, metadata)=>{\n        return metadata[key] >= parsePrimitiveValue(value);\n    },\n    [FilterOperator.LTE]: ({ key, value }, metadata)=>{\n        return metadata[key] <= parsePrimitiveValue(value);\n    }\n};\n// Build a filter function based on the metadata and the preFilters\nconst buildFilterFn = (metadata, preFilters)=>{\n    if (!preFilters) return true;\n    if (!metadata) return false;\n    const { filters, condition } = preFilters;\n    const queryCondition = condition || \"and\"; // default to and\n    const itemFilterFn = (filter)=>{\n        if (filter.operator === FilterOperator.IS_EMPTY) {\n            // for `is_empty` operator, return true if the metadata key is not present or the value is empty\n            const value = metadata[filter.key];\n            return value === undefined || value === null || value === \"\" || Array.isArray(value) && value.length === 0;\n        }\n        if (metadata[filter.key] === undefined) {\n            // for other operators, always return false if the metadata key is not present\n            return false;\n        }\n        const metadataLookupFn = OPERATOR_TO_FILTER[filter.operator];\n        if (!metadataLookupFn) throw new Error(`Unsupported operator: ${filter.operator}`);\n        return metadataLookupFn(filter, metadata);\n    };\n    if (queryCondition === \"and\") return filters.every(itemFilterFn);\n    return filters.some(itemFilterFn);\n};\nclass SimpleVectorStoreData {\n    embeddingDict = {};\n    textIdToRefDocId = {};\n    metadataDict = {};\n}\nexport class SimpleVectorStore extends BaseVectorStore {\n    storesText = false;\n    data;\n    persistPath;\n    constructor(init){\n        super(init);\n        this.data = init?.data || new SimpleVectorStoreData();\n    }\n    static async fromPersistDir(persistDir = DEFAULT_PERSIST_DIR, embedModel) {\n        const persistPath = path.join(persistDir, \"vector_store.json\");\n        return await SimpleVectorStore.fromPersistPath(persistPath, embedModel);\n    }\n    client() {\n        return null;\n    }\n    async get(textId) {\n        return this.data.embeddingDict[textId];\n    }\n    async add(embeddingResults) {\n        for (const node of embeddingResults){\n            this.data.embeddingDict[node.id_] = node.getEmbedding();\n            if (!node.sourceNode) {\n                continue;\n            }\n            this.data.textIdToRefDocId[node.id_] = node.sourceNode?.nodeId;\n            // Add metadata to the metadataDict\n            const metadata = nodeToMetadata(node, true, undefined, false);\n            delete metadata[\"_node_content\"];\n            this.data.metadataDict[node.id_] = metadata;\n        }\n        if (this.persistPath) {\n            await this.persist(this.persistPath);\n        }\n        return embeddingResults.map((result)=>result.id_);\n    }\n    async delete(refDocId) {\n        const textIdsToDelete = Object.keys(this.data.textIdToRefDocId).filter((textId)=>this.data.textIdToRefDocId[textId] === refDocId);\n        for (const textId of textIdsToDelete){\n            delete this.data.embeddingDict[textId];\n            delete this.data.textIdToRefDocId[textId];\n            if (this.data.metadataDict) delete this.data.metadataDict[textId];\n        }\n        if (this.persistPath) {\n            await this.persist(this.persistPath);\n        }\n        return Promise.resolve();\n    }\n    async filterNodes(query) {\n        const items = Object.entries(this.data.embeddingDict);\n        const queryFilterFn = (nodeId)=>{\n            const metadata = this.data.metadataDict[nodeId];\n            return buildFilterFn(metadata, query.filters);\n        };\n        const nodeFilterFn = (nodeId)=>{\n            if (!query.docIds) return true;\n            const availableIds = new Set(query.docIds);\n            return availableIds.has(nodeId);\n        };\n        const queriedItems = items.filter((item)=>nodeFilterFn(item[0]) && queryFilterFn(item[0]));\n        const nodeIds = queriedItems.map((item)=>item[0]);\n        const embeddings = queriedItems.map((item)=>item[1]);\n        return {\n            nodeIds,\n            embeddings\n        };\n    }\n    async query(query) {\n        const { nodeIds, embeddings } = await this.filterNodes(query);\n        const queryEmbedding = query.queryEmbedding;\n        let topSimilarities, topIds;\n        if (LEARNER_MODES.has(query.mode)) {\n            // fixme: unfinished\n            throw new Error(\"Learner modes not implemented for SimpleVectorStore yet.\");\n        } else if (query.mode === MMR_MODE) {\n            const mmrThreshold = query.mmrThreshold;\n            [topSimilarities, topIds] = getTopKMMREmbeddings(queryEmbedding, embeddings, null, query.similarityTopK, nodeIds, mmrThreshold);\n        } else if (query.mode === VectorStoreQueryMode.DEFAULT) {\n            [topSimilarities, topIds] = getTopKEmbeddings(queryEmbedding, embeddings, query.similarityTopK, nodeIds);\n        } else {\n            throw new Error(`Invalid query mode: ${query.mode}`);\n        }\n        return Promise.resolve({\n            similarities: topSimilarities,\n            ids: topIds\n        });\n    }\n    async persist(persistPath = path.join(DEFAULT_PERSIST_DIR, \"vector_store.json\")) {\n        await SimpleVectorStore.persistData(persistPath, this.data);\n    }\n    static async persistData(persistPath, data) {\n        const dirPath = path.dirname(persistPath);\n        if (!await exists(dirPath)) {\n            await fs.mkdir(dirPath);\n        }\n        await fs.writeFile(persistPath, JSON.stringify(data));\n    }\n    static async fromPersistPath(persistPath, embeddingModel) {\n        const dirPath = path.dirname(persistPath);\n        if (!await exists(dirPath)) {\n            await fs.mkdir(dirPath, {\n                recursive: true\n            });\n        }\n        let dataDict = {};\n        try {\n            const fileData = await fs.readFile(persistPath);\n            dataDict = JSON.parse(fileData.toString());\n        } catch (e) {\n            console.error(`No valid data found at path: ${persistPath} starting new store.`);\n            // persist empty data, to ignore this error in the future\n            await SimpleVectorStore.persistData(persistPath, new SimpleVectorStoreData());\n        }\n        const data = new SimpleVectorStoreData();\n        // @ts-expect-error TS2322\n        data.embeddingDict = dataDict.embeddingDict ?? {};\n        // @ts-expect-error TS2322\n        data.textIdToRefDocId = dataDict.textIdToRefDocId ?? {};\n        // @ts-expect-error TS2322\n        data.metadataDict = dataDict.metadataDict ?? {};\n        const store = new SimpleVectorStore({\n            data,\n            embeddingModel\n        });\n        store.persistPath = persistPath;\n        return store;\n    }\n    static fromDict(saveDict, embeddingModel) {\n        const data = new SimpleVectorStoreData();\n        data.embeddingDict = saveDict.embeddingDict;\n        data.textIdToRefDocId = saveDict.textIdToRefDocId;\n        data.metadataDict = saveDict.metadataDict;\n        return new SimpleVectorStore({\n            data,\n            embeddingModel\n        });\n    }\n    toDict() {\n        return {\n            embeddingDict: this.data.embeddingDict,\n            textIdToRefDocId: this.data.textIdToRefDocId,\n            metadataDict: this.data.metadataDict\n        };\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3021, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/storage/docStore/SimpleDocumentStore.js"],"sourcesContent":["import { DEFAULT_DOC_STORE_PERSIST_FILENAME, DEFAULT_NAMESPACE, DEFAULT_PERSIST_DIR } from \"@llamaindex/core/global\";\nimport { KVDocumentStore } from \"@llamaindex/core/storage/doc-store\";\nimport { BaseInMemoryKVStore, SimpleKVStore } from \"@llamaindex/core/storage/kv-store\";\nimport { path } from \"@llamaindex/env\";\nimport _ from \"lodash\";\nexport class SimpleDocumentStore extends KVDocumentStore {\n    kvStore;\n    constructor(kvStore, namespace){\n        kvStore = kvStore || new SimpleKVStore();\n        namespace = namespace || DEFAULT_NAMESPACE;\n        super(kvStore, namespace);\n        this.kvStore = kvStore;\n    }\n    static async fromPersistDir(persistDir = DEFAULT_PERSIST_DIR, namespace) {\n        const persistPath = path.join(persistDir, DEFAULT_DOC_STORE_PERSIST_FILENAME);\n        return await SimpleDocumentStore.fromPersistPath(persistPath, namespace);\n    }\n    static async fromPersistPath(persistPath, namespace) {\n        const simpleKVStore = await SimpleKVStore.fromPersistPath(persistPath);\n        return new SimpleDocumentStore(simpleKVStore, namespace);\n    }\n    async persist(persistPath = path.join(DEFAULT_PERSIST_DIR, DEFAULT_DOC_STORE_PERSIST_FILENAME)) {\n        if (_.isObject(this.kvStore) && this.kvStore instanceof BaseInMemoryKVStore) {\n            await this.kvStore.persist(persistPath);\n        }\n    }\n    static fromDict(saveDict, namespace) {\n        const simpleKVStore = SimpleKVStore.fromDict(saveDict);\n        return new SimpleDocumentStore(simpleKVStore, namespace);\n    }\n    toDict() {\n        if (_.isObject(this.kvStore) && this.kvStore instanceof SimpleKVStore) {\n            return this.kvStore.toDict();\n        }\n        // If the kvstore is not a SimpleKVStore, you might want to throw an error or return a default value.\n        throw new Error(\"KVStore is not a SimpleKVStore\");\n    }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AAAA;AACA;;;;;;AACO,MAAM,4BAA4B,kLAAA,CAAA,kBAAe;IACpD,QAAQ;IACR,YAAY,OAAO,EAAE,SAAS,CAAC;QAC3B,UAAU,WAAW,IAAI,iLAAA,CAAA,gBAAa;QACtC,YAAY,aAAa,iKAAA,CAAA,oBAAiB;QAC1C,KAAK,CAAC,SAAS;QACf,IAAI,CAAC,OAAO,GAAG;IACnB;IACA,aAAa,eAAe,aAAa,iKAAA,CAAA,sBAAmB,EAAE,SAAS,EAAE;QACrE,MAAM,cAAc,oJAAA,CAAA,OAAI,CAAC,IAAI,CAAC,YAAY,iKAAA,CAAA,qCAAkC;QAC5E,OAAO,MAAM,oBAAoB,eAAe,CAAC,aAAa;IAClE;IACA,aAAa,gBAAgB,WAAW,EAAE,SAAS,EAAE;QACjD,MAAM,gBAAgB,MAAM,iLAAA,CAAA,gBAAa,CAAC,eAAe,CAAC;QAC1D,OAAO,IAAI,oBAAoB,eAAe;IAClD;IACA,MAAM,QAAQ,cAAc,oJAAA,CAAA,OAAI,CAAC,IAAI,CAAC,iKAAA,CAAA,sBAAmB,EAAE,iKAAA,CAAA,qCAAkC,CAAC,EAAE;QAC5F,IAAI,kIAAA,CAAA,UAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,KAAK,IAAI,CAAC,OAAO,YAAY,iLAAA,CAAA,sBAAmB,EAAE;YACzE,MAAM,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC;QAC/B;IACJ;IACA,OAAO,SAAS,QAAQ,EAAE,SAAS,EAAE;QACjC,MAAM,gBAAgB,iLAAA,CAAA,gBAAa,CAAC,QAAQ,CAAC;QAC7C,OAAO,IAAI,oBAAoB,eAAe;IAClD;IACA,SAAS;QACL,IAAI,kIAAA,CAAA,UAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,KAAK,IAAI,CAAC,OAAO,YAAY,iLAAA,CAAA,gBAAa,EAAE;YACnE,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM;QAC9B;QACA,qGAAqG;QACrG,MAAM,IAAI,MAAM;IACpB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3074, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/storage/StorageContext.js"],"sourcesContent":["import { DEFAULT_NAMESPACE } from \"@llamaindex/core/global\";\nimport { ModalityType, ObjectType } from \"@llamaindex/core/schema\";\nimport { SimpleIndexStore } from \"@llamaindex/core/storage/index-store\";\nimport { Settings } from \"../Settings.js\";\nimport { SimpleVectorStore } from \"../vector-store/SimpleVectorStore.js\";\nimport { SimpleDocumentStore } from \"./docStore/SimpleDocumentStore.js\";\nexport async function storageContextFromDefaults({ docStore, indexStore, vectorStore, vectorStores, persistDir }) {\n    vectorStores = vectorStores ?? {};\n    if (!persistDir) {\n        docStore = docStore ?? new SimpleDocumentStore();\n        indexStore = indexStore ?? new SimpleIndexStore();\n        if (!(ModalityType.TEXT in vectorStores)) {\n            vectorStores[ModalityType.TEXT] = vectorStore ?? new SimpleVectorStore();\n        }\n    } else {\n        const embedModel = Settings.embedModel;\n        docStore = docStore || await SimpleDocumentStore.fromPersistDir(persistDir, DEFAULT_NAMESPACE);\n        indexStore = indexStore || await SimpleIndexStore.fromPersistDir(persistDir);\n        if (!(ObjectType.TEXT in vectorStores)) {\n            vectorStores[ModalityType.TEXT] = vectorStore ?? await SimpleVectorStore.fromPersistDir(persistDir, embedModel);\n        }\n    }\n    return {\n        docStore,\n        indexStore,\n        vectorStores\n    };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AACO,eAAe,2BAA2B,EAAE,QAAQ,EAAE,UAAU,EAAE,WAAW,EAAE,YAAY,EAAE,UAAU,EAAE;IAC5G,eAAe,gBAAgB,CAAC;IAChC,IAAI,CAAC,YAAY;QACb,WAAW,YAAY,IAAI,kLAAA,CAAA,sBAAmB;QAC9C,aAAa,cAAc,IAAI,oLAAA,CAAA,mBAAgB;QAC/C,IAAI,CAAC,CAAC,iKAAA,CAAA,eAAY,CAAC,IAAI,IAAI,YAAY,GAAG;YACtC,YAAY,CAAC,iKAAA,CAAA,eAAY,CAAC,IAAI,CAAC,GAAG,eAAe,IAAI,4KAAA,CAAA,oBAAiB;QAC1E;IACJ,OAAO;QACH,MAAM,aAAa,gJAAA,CAAA,WAAQ,CAAC,UAAU;QACtC,WAAW,YAAY,MAAM,kLAAA,CAAA,sBAAmB,CAAC,cAAc,CAAC,YAAY,iKAAA,CAAA,oBAAiB;QAC7F,aAAa,cAAc,MAAM,oLAAA,CAAA,mBAAgB,CAAC,cAAc,CAAC;QACjE,IAAI,CAAC,CAAC,iKAAA,CAAA,aAAU,CAAC,IAAI,IAAI,YAAY,GAAG;YACpC,YAAY,CAAC,iKAAA,CAAA,eAAY,CAAC,IAAI,CAAC,GAAG,eAAe,MAAM,4KAAA,CAAA,oBAAiB,CAAC,cAAc,CAAC,YAAY;QACxG;IACJ;IACA,OAAO;QACH;QACA;QACA;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3117, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/ingestion/IngestionCache.js"],"sourcesContent":["import { MetadataMode } from \"@llamaindex/core/schema\";\nimport { docToJson, jsonSerializer, jsonToDoc } from \"@llamaindex/core/storage/doc-store\";\nimport { SimpleKVStore } from \"@llamaindex/core/storage/kv-store\";\nimport { createSHA256 } from \"@llamaindex/env\";\nconst transformToJSON = (obj)=>{\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const seen = [];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const replacer = (key, value)=>{\n        if (value != null && typeof value == \"object\") {\n            if (seen.indexOf(value) >= 0) {\n                return;\n            }\n            seen.push(value);\n        }\n        return value;\n    };\n    // this is a custom replacer function that will allow us to handle circular references\n    const jsonStr = JSON.stringify(obj, replacer);\n    return jsonStr;\n};\nexport function getTransformationHash(nodes, transform) {\n    const nodesStr = nodes.map((node)=>node.getContent(MetadataMode.ALL)).join(\"\");\n    const transformString = transformToJSON(transform);\n    const hash = createSHA256();\n    hash.update(nodesStr + transformString + transform.id);\n    return hash.digest();\n}\nexport class IngestionCache {\n    collection = \"llama_cache\";\n    cache;\n    nodesKey = \"nodes\";\n    constructor(collection){\n        if (collection) {\n            this.collection = collection;\n        }\n        this.cache = new SimpleKVStore();\n    }\n    async put(hash, nodes) {\n        const val = {\n            [this.nodesKey]: nodes.map((node)=>docToJson(node, jsonSerializer))\n        };\n        await this.cache.put(hash, val, this.collection);\n    }\n    async get(hash) {\n        const json = await this.cache.get(hash, this.collection);\n        if (!json || !json[this.nodesKey] || !Array.isArray(json[this.nodesKey])) {\n            return undefined;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return json[this.nodesKey].map((doc)=>jsonToDoc(doc, jsonSerializer));\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AAAA;;;;;AACA,MAAM,kBAAkB,CAAC;IACrB,8DAA8D;IAC9D,MAAM,OAAO,EAAE;IACf,8DAA8D;IAC9D,MAAM,WAAW,CAAC,KAAK;QACnB,IAAI,SAAS,QAAQ,OAAO,SAAS,UAAU;YAC3C,IAAI,KAAK,OAAO,CAAC,UAAU,GAAG;gBAC1B;YACJ;YACA,KAAK,IAAI,CAAC;QACd;QACA,OAAO;IACX;IACA,sFAAsF;IACtF,MAAM,UAAU,KAAK,SAAS,CAAC,KAAK;IACpC,OAAO;AACX;AACO,SAAS,sBAAsB,KAAK,EAAE,SAAS;IAClD,MAAM,WAAW,MAAM,GAAG,CAAC,CAAC,OAAO,KAAK,UAAU,CAAC,iKAAA,CAAA,eAAY,CAAC,GAAG,GAAG,IAAI,CAAC;IAC3E,MAAM,kBAAkB,gBAAgB;IACxC,MAAM,OAAO,CAAA,GAAA,sKAAA,CAAA,eAAY,AAAD;IACxB,KAAK,MAAM,CAAC,WAAW,kBAAkB,UAAU,EAAE;IACrD,OAAO,KAAK,MAAM;AACtB;AACO,MAAM;IACT,aAAa,cAAc;IAC3B,MAAM;IACN,WAAW,QAAQ;IACnB,YAAY,UAAU,CAAC;QACnB,IAAI,YAAY;YACZ,IAAI,CAAC,UAAU,GAAG;QACtB;QACA,IAAI,CAAC,KAAK,GAAG,IAAI,iLAAA,CAAA,gBAAa;IAClC;IACA,MAAM,IAAI,IAAI,EAAE,KAAK,EAAE;QACnB,MAAM,MAAM;YACR,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,MAAM,GAAG,CAAC,CAAC,OAAO,CAAA,GAAA,kLAAA,CAAA,YAAS,AAAD,EAAE,MAAM,kLAAA,CAAA,iBAAc;QACrE;QACA,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,KAAK,IAAI,CAAC,UAAU;IACnD;IACA,MAAM,IAAI,IAAI,EAAE;QACZ,MAAM,OAAO,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,IAAI,CAAC,UAAU;QACvD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG;YACtE,OAAO;QACX;QACA,8DAA8D;QAC9D,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,MAAM,CAAA,GAAA,kLAAA,CAAA,YAAS,AAAD,EAAE,KAAK,kLAAA,CAAA,iBAAc;IACvE;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3185, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/ingestion/strategies/classify.js"],"sourcesContent":["export async function classify(docStore, nodes) {\n    const existingDocIds = Object.values(await docStore.getAllDocumentHashes());\n    const docIdsFromNodes = new Set();\n    const dedupedNodes = [];\n    const unusedDocs = [];\n    for (const node of nodes){\n        const refDocId = node.sourceNode?.nodeId || node.id_;\n        docIdsFromNodes.add(refDocId);\n        const existingHash = await docStore.getDocumentHash(refDocId);\n        if (!existingHash) {\n            // document doesn't exist, so add it\n            dedupedNodes.push(node);\n        } else if (existingHash && existingHash !== node.hash) {\n            // document exists but hash is different, so mark doc as unused and add node as deduped\n            unusedDocs.push(refDocId);\n            dedupedNodes.push(node);\n        }\n    // otherwise, document exists and hash is the same, so do nothing\n    }\n    const missingDocs = existingDocIds.filter((id)=>!docIdsFromNodes.has(id));\n    return {\n        dedupedNodes,\n        missingDocs,\n        unusedDocs\n    };\n}\n"],"names":[],"mappings":";;;AAAO,eAAe,SAAS,QAAQ,EAAE,KAAK;IAC1C,MAAM,iBAAiB,OAAO,MAAM,CAAC,MAAM,SAAS,oBAAoB;IACxE,MAAM,kBAAkB,IAAI;IAC5B,MAAM,eAAe,EAAE;IACvB,MAAM,aAAa,EAAE;IACrB,KAAK,MAAM,QAAQ,MAAM;QACrB,MAAM,WAAW,KAAK,UAAU,EAAE,UAAU,KAAK,GAAG;QACpD,gBAAgB,GAAG,CAAC;QACpB,MAAM,eAAe,MAAM,SAAS,eAAe,CAAC;QACpD,IAAI,CAAC,cAAc;YACf,oCAAoC;YACpC,aAAa,IAAI,CAAC;QACtB,OAAO,IAAI,gBAAgB,iBAAiB,KAAK,IAAI,EAAE;YACnD,uFAAuF;YACvF,WAAW,IAAI,CAAC;YAChB,aAAa,IAAI,CAAC;QACtB;IACJ,iEAAiE;IACjE;IACA,MAAM,cAAc,eAAe,MAAM,CAAC,CAAC,KAAK,CAAC,gBAAgB,GAAG,CAAC;IACrE,OAAO;QACH;QACA;QACA;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3220, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/ingestion/strategies/rollback.js"],"sourcesContent":["import { TransformComponent } from \"@llamaindex/core/schema\";\nimport { classify } from \"./classify.js\";\nexport class RollbackableTransformComponent extends TransformComponent {\n    // Remove unused docs from the doc store. It is useful in case\n    // generating embeddings fails and we want to remove the unused docs\n    // TODO: override this in UpsertsStrategy if we want to revert removed docs also\n    async rollback(docStore, nodes) {\n        const { unusedDocs } = await classify(docStore, nodes);\n        for (const docId of unusedDocs){\n            await docStore.deleteDocument(docId, false);\n        }\n        docStore.persist();\n    }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AACO,MAAM,uCAAuC,iKAAA,CAAA,qBAAkB;IAClE,8DAA8D;IAC9D,oEAAoE;IACpE,gFAAgF;IAChF,MAAM,SAAS,QAAQ,EAAE,KAAK,EAAE;QAC5B,MAAM,EAAE,UAAU,EAAE,GAAG,MAAM,CAAA,GAAA,2KAAA,CAAA,WAAQ,AAAD,EAAE,UAAU;QAChD,KAAK,MAAM,SAAS,WAAW;YAC3B,MAAM,SAAS,cAAc,CAAC,OAAO;QACzC;QACA,SAAS,OAAO;IACpB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3245, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/ingestion/strategies/DuplicatesStrategy.js"],"sourcesContent":["import { RollbackableTransformComponent } from \"./rollback.js\";\n/**\n * Handle doc store duplicates by checking all hashes.\n */ export class DuplicatesStrategy extends RollbackableTransformComponent {\n    docStore;\n    constructor(docStore){\n        super(async (nodes)=>{\n            const hashes = await this.docStore.getAllDocumentHashes();\n            const currentHashes = new Set();\n            const nodesToRun = [];\n            for (const node of nodes){\n                if (!(node.hash in hashes) && !currentHashes.has(node.hash)) {\n                    await this.docStore.setDocumentHash(node.id_, node.hash);\n                    nodesToRun.push(node);\n                    currentHashes.add(node.hash);\n                }\n            }\n            await this.docStore.addDocuments(nodesToRun, true);\n            return nodesToRun;\n        });\n        this.docStore = docStore;\n    }\n}\n"],"names":[],"mappings":";;;AAAA;;AAGW,MAAM,2BAA2B,2KAAA,CAAA,iCAA8B;IACtE,SAAS;IACT,YAAY,QAAQ,CAAC;QACjB,KAAK,CAAC,OAAO;YACT,MAAM,SAAS,MAAM,IAAI,CAAC,QAAQ,CAAC,oBAAoB;YACvD,MAAM,gBAAgB,IAAI;YAC1B,MAAM,aAAa,EAAE;YACrB,KAAK,MAAM,QAAQ,MAAM;gBACrB,IAAI,CAAC,CAAC,KAAK,IAAI,IAAI,MAAM,KAAK,CAAC,cAAc,GAAG,CAAC,KAAK,IAAI,GAAG;oBACzD,MAAM,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,KAAK,GAAG,EAAE,KAAK,IAAI;oBACvD,WAAW,IAAI,CAAC;oBAChB,cAAc,GAAG,CAAC,KAAK,IAAI;gBAC/B;YACJ;YACA,MAAM,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,YAAY;YAC7C,OAAO;QACX;QACA,IAAI,CAAC,QAAQ,GAAG;IACpB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3276, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/ingestion/strategies/UpsertsAndDeleteStrategy.js"],"sourcesContent":["import { classify } from \"./classify.js\";\nimport { RollbackableTransformComponent } from \"./rollback.js\";\n/**\n * Handle docstore upserts by checking hashes and ids.\n * Identify missing docs and delete them from docstore and vector store\n */ export class UpsertsAndDeleteStrategy extends RollbackableTransformComponent {\n    docStore;\n    vectorStores;\n    constructor(docStore, vectorStores){\n        super(async (nodes)=>{\n            const { dedupedNodes, missingDocs, unusedDocs } = await classify(this.docStore, nodes);\n            // remove unused docs\n            for (const refDocId of unusedDocs){\n                await this.docStore.deleteRefDoc(refDocId, false);\n                if (this.vectorStores) {\n                    for (const vectorStore of this.vectorStores){\n                        await vectorStore.delete(refDocId);\n                    }\n                }\n            }\n            // remove missing docs\n            for (const docId of missingDocs){\n                await this.docStore.deleteDocument(docId, true);\n                if (this.vectorStores) {\n                    for (const vectorStore of this.vectorStores){\n                        await vectorStore.delete(docId);\n                    }\n                }\n            }\n            await this.docStore.addDocuments(dedupedNodes, true);\n            return dedupedNodes;\n        });\n        this.docStore = docStore;\n        this.vectorStores = vectorStores;\n    }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAIW,MAAM,iCAAiC,2KAAA,CAAA,iCAA8B;IAC5E,SAAS;IACT,aAAa;IACb,YAAY,QAAQ,EAAE,YAAY,CAAC;QAC/B,KAAK,CAAC,OAAO;YACT,MAAM,EAAE,YAAY,EAAE,WAAW,EAAE,UAAU,EAAE,GAAG,MAAM,CAAA,GAAA,2KAAA,CAAA,WAAQ,AAAD,EAAE,IAAI,CAAC,QAAQ,EAAE;YAChF,qBAAqB;YACrB,KAAK,MAAM,YAAY,WAAW;gBAC9B,MAAM,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,UAAU;gBAC3C,IAAI,IAAI,CAAC,YAAY,EAAE;oBACnB,KAAK,MAAM,eAAe,IAAI,CAAC,YAAY,CAAC;wBACxC,MAAM,YAAY,MAAM,CAAC;oBAC7B;gBACJ;YACJ;YACA,sBAAsB;YACtB,KAAK,MAAM,SAAS,YAAY;gBAC5B,MAAM,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,OAAO;gBAC1C,IAAI,IAAI,CAAC,YAAY,EAAE;oBACnB,KAAK,MAAM,eAAe,IAAI,CAAC,YAAY,CAAC;wBACxC,MAAM,YAAY,MAAM,CAAC;oBAC7B;gBACJ;YACJ;YACA,MAAM,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,cAAc;YAC/C,OAAO;QACX;QACA,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,YAAY,GAAG;IACxB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3320, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/ingestion/strategies/UpsertsStrategy.js"],"sourcesContent":["import { classify } from \"./classify.js\";\nimport { RollbackableTransformComponent } from \"./rollback.js\";\n/**\n * Handles doc store upserts by checking hashes and ids.\n */ export class UpsertsStrategy extends RollbackableTransformComponent {\n    docStore;\n    vectorStores;\n    constructor(docStore, vectorStores){\n        super(async (nodes)=>{\n            const { dedupedNodes, unusedDocs } = await classify(this.docStore, nodes);\n            // remove unused docs\n            for (const refDocId of unusedDocs){\n                await this.docStore.deleteRefDoc(refDocId, false);\n                if (this.vectorStores) {\n                    for (const vectorStore of this.vectorStores){\n                        await vectorStore.delete(refDocId);\n                    }\n                }\n            }\n            // add non-duplicate docs\n            await this.docStore.addDocuments(dedupedNodes, true);\n            return dedupedNodes;\n        });\n        this.docStore = docStore;\n        this.vectorStores = vectorStores;\n    }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAGW,MAAM,wBAAwB,2KAAA,CAAA,iCAA8B;IACnE,SAAS;IACT,aAAa;IACb,YAAY,QAAQ,EAAE,YAAY,CAAC;QAC/B,KAAK,CAAC,OAAO;YACT,MAAM,EAAE,YAAY,EAAE,UAAU,EAAE,GAAG,MAAM,CAAA,GAAA,2KAAA,CAAA,WAAQ,AAAD,EAAE,IAAI,CAAC,QAAQ,EAAE;YACnE,qBAAqB;YACrB,KAAK,MAAM,YAAY,WAAW;gBAC9B,MAAM,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,UAAU;gBAC3C,IAAI,IAAI,CAAC,YAAY,EAAE;oBACnB,KAAK,MAAM,eAAe,IAAI,CAAC,YAAY,CAAC;wBACxC,MAAM,YAAY,MAAM,CAAC;oBAC7B;gBACJ;YACJ;YACA,yBAAyB;YACzB,MAAM,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,cAAc;YAC/C,OAAO;QACX;QACA,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,YAAY,GAAG;IACxB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3356, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/ingestion/strategies/index.js"],"sourcesContent":["import { DuplicatesStrategy } from \"./DuplicatesStrategy.js\";\nimport { UpsertsAndDeleteStrategy } from \"./UpsertsAndDeleteStrategy.js\";\nimport { UpsertsStrategy } from \"./UpsertsStrategy.js\";\nimport { RollbackableTransformComponent } from \"./rollback.js\";\n/**\n * Document de-deduplication strategies work by comparing the hashes or ids stored in the document store.\n * They require a document store to be set which must be persisted across pipeline runs.\n */ export var DocStoreStrategy = /*#__PURE__*/ function(DocStoreStrategy) {\n    // Use upserts to handle duplicates. Checks if the a document is already in the doc store based on its id. If it is not, or if the hash of the document is updated, it will update the document in the doc store and run the transformations.\n    DocStoreStrategy[\"UPSERTS\"] = \"upserts\";\n    // Only handle duplicates. Checks if the hash of a document is already in the doc store. Only then it will add the document to the doc store and run the transformations\n    DocStoreStrategy[\"DUPLICATES_ONLY\"] = \"duplicates_only\";\n    // Use upserts and delete to handle duplicates. Like the upsert strategy but it will also delete non-existing documents from the doc store\n    DocStoreStrategy[\"UPSERTS_AND_DELETE\"] = \"upserts_and_delete\";\n    DocStoreStrategy[\"NONE\"] = \"none\";\n    return DocStoreStrategy;\n}({});\nclass NoOpStrategy extends RollbackableTransformComponent {\n    constructor(){\n        super(async (nodes)=>nodes);\n    }\n}\nexport function createDocStoreStrategy(docStoreStrategy, docStore, vectorStores = []) {\n    if (docStoreStrategy === \"none\") {\n        return new NoOpStrategy();\n    }\n    if (!docStore) {\n        throw new Error(\"docStore is required to create a doc store strategy.\");\n    }\n    if (vectorStores.length > 0) {\n        if (docStoreStrategy === \"upserts\") {\n            return new UpsertsStrategy(docStore, vectorStores);\n        } else if (docStoreStrategy === \"upserts_and_delete\") {\n            return new UpsertsAndDeleteStrategy(docStore, vectorStores);\n        } else if (docStoreStrategy === \"duplicates_only\") {\n            return new DuplicatesStrategy(docStore);\n        } else {\n            throw new Error(`Invalid docstore strategy: ${docStoreStrategy}`);\n        }\n    } else {\n        if (docStoreStrategy === \"upserts\") {\n            console.warn(\"Docstore strategy set to upserts, but no vector store. Switching to duplicates_only strategy.\");\n        } else if (docStoreStrategy === \"upserts_and_delete\") {\n            console.warn(\"Docstore strategy set to upserts and delete, but no vector store. Switching to duplicates_only strategy.\");\n        }\n        return new DuplicatesStrategy(docStore);\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAIW,IAAI,mBAAmB,WAAW,GAAG,SAAS,gBAAgB;IACrE,6OAA6O;IAC7O,gBAAgB,CAAC,UAAU,GAAG;IAC9B,wKAAwK;IACxK,gBAAgB,CAAC,kBAAkB,GAAG;IACtC,0IAA0I;IAC1I,gBAAgB,CAAC,qBAAqB,GAAG;IACzC,gBAAgB,CAAC,OAAO,GAAG;IAC3B,OAAO;AACX,EAAE,CAAC;AACH,MAAM,qBAAqB,2KAAA,CAAA,iCAA8B;IACrD,aAAa;QACT,KAAK,CAAC,OAAO,QAAQ;IACzB;AACJ;AACO,SAAS,uBAAuB,gBAAgB,EAAE,QAAQ,EAAE,eAAe,EAAE;IAChF,IAAI,qBAAqB,QAAQ;QAC7B,OAAO,IAAI;IACf;IACA,IAAI,CAAC,UAAU;QACX,MAAM,IAAI,MAAM;IACpB;IACA,IAAI,aAAa,MAAM,GAAG,GAAG;QACzB,IAAI,qBAAqB,WAAW;YAChC,OAAO,IAAI,kLAAA,CAAA,kBAAe,CAAC,UAAU;QACzC,OAAO,IAAI,qBAAqB,sBAAsB;YAClD,OAAO,IAAI,2LAAA,CAAA,2BAAwB,CAAC,UAAU;QAClD,OAAO,IAAI,qBAAqB,mBAAmB;YAC/C,OAAO,IAAI,qLAAA,CAAA,qBAAkB,CAAC;QAClC,OAAO;YACH,MAAM,IAAI,MAAM,CAAC,2BAA2B,EAAE,kBAAkB;QACpE;IACJ,OAAO;QACH,IAAI,qBAAqB,WAAW;YAChC,QAAQ,IAAI,CAAC;QACjB,OAAO,IAAI,qBAAqB,sBAAsB;YAClD,QAAQ,IAAI,CAAC;QACjB;QACA,OAAO,IAAI,qLAAA,CAAA,qBAAkB,CAAC;IAClC;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3415, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/ingestion/IngestionPipeline.js"],"sourcesContent":["import { ModalityType, splitNodesByType } from \"@llamaindex/core/schema\";\nimport { IngestionCache, getTransformationHash } from \"./IngestionCache.js\";\nimport { DocStoreStrategy, createDocStoreStrategy } from \"./strategies/index.js\";\nexport async function runTransformations(nodesToRun, transformations, // eslint-disable-next-line @typescript-eslint/no-explicit-any\ntransformOptions = {}, { inPlace = true, cache, docStoreStrategy } = {}) {\n    let nodes = nodesToRun;\n    if (!inPlace) {\n        nodes = [\n            ...nodesToRun\n        ];\n    }\n    if (docStoreStrategy) {\n        nodes = await docStoreStrategy(nodes);\n    }\n    for (const transform of transformations){\n        if (cache) {\n            const hash = getTransformationHash(nodes, transform);\n            const cachedNodes = await cache.get(hash);\n            if (cachedNodes) {\n                nodes = cachedNodes;\n            } else {\n                nodes = await transform(nodes, transformOptions);\n                await cache.put(hash, nodes);\n            }\n        } else {\n            nodes = await transform(nodes, transformOptions);\n        }\n    }\n    return nodes;\n}\nexport class IngestionPipeline {\n    transformations = [];\n    documents;\n    reader;\n    vectorStore;\n    vectorStores;\n    docStore;\n    docStoreStrategy = DocStoreStrategy.UPSERTS;\n    cache;\n    disableCache = false;\n    _docStoreStrategy;\n    constructor(init){\n        Object.assign(this, init);\n        if (!this.docStore) {\n            this.docStoreStrategy = DocStoreStrategy.NONE;\n        }\n        this.vectorStores = this.vectorStores ?? (this.vectorStore ? {\n            [ModalityType.TEXT]: this.vectorStore\n        } : undefined);\n        this._docStoreStrategy = createDocStoreStrategy(this.docStoreStrategy, this.docStore, this.vectorStores ? Object.values(this.vectorStores) : undefined);\n        if (!this.disableCache) {\n            this.cache = new IngestionCache();\n        }\n    }\n    async prepareInput(documents, nodes) {\n        const inputNodes = [];\n        if (documents) {\n            inputNodes.push(documents);\n        }\n        if (nodes) {\n            inputNodes.push(nodes);\n        }\n        if (this.documents) {\n            inputNodes.push(this.documents);\n        }\n        if (this.reader) {\n            // fixme: empty parameter might cause error\n            inputNodes.push(await this.reader.loadData());\n        }\n        return inputNodes.flat();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async run(args = {}, transformOptions) {\n        args.cache = args.cache ?? this.cache;\n        args.docStoreStrategy = args.docStoreStrategy ?? this._docStoreStrategy;\n        const inputNodes = await this.prepareInput(args.documents, args.nodes);\n        const nodes = await runTransformations(inputNodes, this.transformations, transformOptions, args);\n        if (this.vectorStores) {\n            const nodesToAdd = nodes.filter((node)=>node.embedding);\n            await addNodesToVectorStores(nodesToAdd, this.vectorStores);\n        }\n        return nodes;\n    }\n}\nexport async function addNodesToVectorStores(nodes, vectorStores, nodesAdded) {\n    const nodeMap = splitNodesByType(nodes);\n    for(const type in nodeMap){\n        const nodes = nodeMap[type];\n        if (nodes) {\n            const vectorStore = vectorStores[type];\n            if (!vectorStore) {\n                throw new Error(`Cannot insert nodes of type ${type} without assigned vector store`);\n            }\n            const newIds = await vectorStore.add(nodes);\n            if (nodesAdded) {\n                await nodesAdded(newIds, nodes, vectorStore);\n            }\n        }\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3528, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/tools/QueryEngineTool.js"],"sourcesContent":["const DEFAULT_NAME = \"query_engine_tool\";\nconst DEFAULT_DESCRIPTION = \"Useful for running a natural language query against a knowledge base and get back a natural language response.\";\nconst DEFAULT_PARAMETERS = {\n    type: \"object\",\n    properties: {\n        query: {\n            type: \"string\",\n            description: \"The query to search for\"\n        }\n    },\n    required: [\n        \"query\"\n    ]\n};\nexport class QueryEngineTool {\n    queryEngine;\n    metadata;\n    constructor({ queryEngine, metadata }){\n        this.queryEngine = queryEngine;\n        this.metadata = {\n            name: metadata?.name ?? DEFAULT_NAME,\n            description: metadata?.description ?? DEFAULT_DESCRIPTION,\n            parameters: metadata?.parameters ?? DEFAULT_PARAMETERS\n        };\n    }\n    async call({ query }) {\n        const response = await this.queryEngine.query({\n            query\n        });\n        return response.message.content;\n    }\n}\n"],"names":[],"mappings":";;;AAAA,MAAM,eAAe;AACrB,MAAM,sBAAsB;AAC5B,MAAM,qBAAqB;IACvB,MAAM;IACN,YAAY;QACR,OAAO;YACH,MAAM;YACN,aAAa;QACjB;IACJ;IACA,UAAU;QACN;KACH;AACL;AACO,MAAM;IACT,YAAY;IACZ,SAAS;IACT,YAAY,EAAE,WAAW,EAAE,QAAQ,EAAE,CAAC;QAClC,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,QAAQ,GAAG;YACZ,MAAM,UAAU,QAAQ;YACxB,aAAa,UAAU,eAAe;YACtC,YAAY,UAAU,cAAc;QACxC;IACJ;IACA,MAAM,KAAK,EAAE,KAAK,EAAE,EAAE;QAClB,MAAM,WAAW,MAAM,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC;YAC1C;QACJ;QACA,OAAO,SAAS,OAAO,CAAC,OAAO;IACnC;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3569, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/indices/BaseIndex.js"],"sourcesContent":["import { runTransformations } from \"../ingestion/IngestionPipeline.js\";\nimport { Settings } from \"../Settings.js\";\nimport { QueryEngineTool } from \"../tools/QueryEngineTool.js\";\n/**\n * Indexes are the data structure that we store our nodes and embeddings in so\n * they can be retrieved for our queries.\n */ export class BaseIndex {\n    storageContext;\n    docStore;\n    indexStore;\n    indexStruct;\n    constructor(init){\n        this.storageContext = init.storageContext;\n        this.docStore = init.docStore;\n        this.indexStore = init.indexStore;\n        this.indexStruct = init.indexStruct;\n    }\n    /**\n   * Returns a query tool by calling asQueryEngine.\n   * Either options or retriever can be passed, but not both.\n   * If options are provided, they are passed to generate a retriever.\n   */ asQueryTool(params) {\n        if (params.options) {\n            params.retriever = this.asRetriever(params.options);\n        }\n        return new QueryEngineTool({\n            queryEngine: this.asQueryEngine(params),\n            metadata: params?.metadata\n        });\n    }\n    /**\n   * Insert a document into the index.\n   * @param document\n   */ async insert(document) {\n        const nodes = await runTransformations([\n            document\n        ], [\n            Settings.nodeParser\n        ]);\n        await this.insertNodes(nodes);\n        await this.docStore.setDocumentHash(document.id_, document.hash);\n    }\n    /**\n   * Alias for asRetriever\n   * @param options\n   */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    retriever(options) {\n        return this.asRetriever(options);\n    }\n    /**\n   * Alias for asQueryEngine\n   * @param options you can supply your own custom Retriever and ResponseSynthesizer\n   */ queryEngine(options) {\n        return this.asQueryEngine(options);\n    }\n    /**\n   * Alias for asQueryTool\n   * Either options or retriever can be passed, but not both.\n   * If options are provided, they are passed to generate a retriever.\n   */ queryTool(params) {\n        return this.asQueryTool(params);\n    }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AAIW,MAAM;IACb,eAAe;IACf,SAAS;IACT,WAAW;IACX,YAAY;IACZ,YAAY,IAAI,CAAC;QACb,IAAI,CAAC,cAAc,GAAG,KAAK,cAAc;QACzC,IAAI,CAAC,QAAQ,GAAG,KAAK,QAAQ;QAC7B,IAAI,CAAC,UAAU,GAAG,KAAK,UAAU;QACjC,IAAI,CAAC,WAAW,GAAG,KAAK,WAAW;IACvC;IACA;;;;GAID,GAAG,YAAY,MAAM,EAAE;QAClB,IAAI,OAAO,OAAO,EAAE;YAChB,OAAO,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,OAAO,OAAO;QACtD;QACA,OAAO,IAAI,gKAAA,CAAA,kBAAe,CAAC;YACvB,aAAa,IAAI,CAAC,aAAa,CAAC;YAChC,UAAU,QAAQ;QACtB;IACJ;IACA;;;GAGD,GAAG,MAAM,OAAO,QAAQ,EAAE;QACrB,MAAM,QAAQ,MAAM,CAAA,GAAA,sKAAA,CAAA,qBAAkB,AAAD,EAAE;YACnC;SACH,EAAE;YACC,gJAAA,CAAA,WAAQ,CAAC,UAAU;SACtB;QACD,MAAM,IAAI,CAAC,WAAW,CAAC;QACvB,MAAM,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,SAAS,GAAG,EAAE,SAAS,IAAI;IACnE;IACA;;;GAGD,GAAG,8DAA8D;IAChE,UAAU,OAAO,EAAE;QACf,OAAO,IAAI,CAAC,WAAW,CAAC;IAC5B;IACA;;;GAGD,GAAG,YAAY,OAAO,EAAE;QACnB,OAAO,IAAI,CAAC,aAAa,CAAC;IAC9B;IACA;;;;GAID,GAAG,UAAU,MAAM,EAAE;QAChB,OAAO,IAAI,CAAC,WAAW,CAAC;IAC5B;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3641, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/indices/summary/utils.js"],"sourcesContent":["import { MetadataMode } from \"@llamaindex/core/schema\";\nimport _ from \"lodash\";\nexport const defaultFormatNodeBatchFn = (summaryNodes)=>{\n    return summaryNodes.map((node, idx)=>{\n        return `\nDocument ${idx + 1}:\n${node.getContent(MetadataMode.LLM)}\n        `.trim();\n    }).join(\"\\n\\n\");\n};\nexport const defaultParseChoiceSelectAnswerFn = (answer, numChoices, raiseErr = false)=>{\n    // split the line into the answer number and relevance score portions\n    const lineTokens = answer.split(\"\\n\").map((line)=>{\n        const lineTokens = line.split(\",\");\n        if (lineTokens.length !== 2) {\n            if (raiseErr) {\n                throw new Error(`Invalid answer line: ${line}. Answer line must be of the form: answer_num: <int>, answer_relevance: <float>`);\n            } else {\n                return null;\n            }\n        }\n        return lineTokens;\n    }).filter((lineTokens)=>!_.isNil(lineTokens));\n    // parse the answer number and relevance score\n    return lineTokens.reduce((parseResult, lineToken)=>{\n        try {\n            const docNum = parseInt(lineToken[0].split(\":\")[1].trim());\n            const answerRelevance = parseFloat(lineToken[1].split(\":\")[1].trim());\n            if (docNum < 1 || docNum > numChoices) {\n                if (raiseErr) {\n                    throw new Error(`Invalid answer number: ${docNum}. Answer number must be between 1 and ${numChoices}`);\n                }\n            } else {\n                parseResult[docNum] = answerRelevance;\n            }\n        } catch (e) {\n            if (raiseErr) {\n                throw e;\n            }\n        }\n        return parseResult;\n    }, {});\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AACO,MAAM,2BAA2B,CAAC;IACrC,OAAO,aAAa,GAAG,CAAC,CAAC,MAAM;QAC3B,OAAO,CAAC;SACP,EAAE,MAAM,EAAE;AACnB,EAAE,KAAK,UAAU,CAAC,iKAAA,CAAA,eAAY,CAAC,GAAG,EAAE;QAC5B,CAAC,CAAC,IAAI;IACV,GAAG,IAAI,CAAC;AACZ;AACO,MAAM,mCAAmC,CAAC,QAAQ,YAAY,WAAW,KAAK;IACjF,qEAAqE;IACrE,MAAM,aAAa,OAAO,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;QACvC,MAAM,aAAa,KAAK,KAAK,CAAC;QAC9B,IAAI,WAAW,MAAM,KAAK,GAAG;YACzB,IAAI,UAAU;gBACV,MAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,KAAK,+EAA+E,CAAC;YACjI,OAAO;gBACH,OAAO;YACX;QACJ;QACA,OAAO;IACX,GAAG,MAAM,CAAC,CAAC,aAAa,CAAC,kIAAA,CAAA,UAAC,CAAC,KAAK,CAAC;IACjC,8CAA8C;IAC9C,OAAO,WAAW,MAAM,CAAC,CAAC,aAAa;QACnC,IAAI;YACA,MAAM,SAAS,SAAS,SAAS,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI;YACvD,MAAM,kBAAkB,WAAW,SAAS,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI;YAClE,IAAI,SAAS,KAAK,SAAS,YAAY;gBACnC,IAAI,UAAU;oBACV,MAAM,IAAI,MAAM,CAAC,uBAAuB,EAAE,OAAO,sCAAsC,EAAE,YAAY;gBACzG;YACJ,OAAO;gBACH,WAAW,CAAC,OAAO,GAAG;YAC1B;QACJ,EAAE,OAAO,GAAG;YACR,IAAI,UAAU;gBACV,MAAM;YACV;QACJ;QACA,OAAO;IACX,GAAG,CAAC;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3696, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/indices/summary/index.js"],"sourcesContent":["import { IndexList, IndexStructType } from \"@llamaindex/core/data-structs\";\nimport { defaultChoiceSelectPrompt } from \"@llamaindex/core/prompts\";\nimport { getResponseSynthesizer } from \"@llamaindex/core/response-synthesizers\";\nimport { BaseRetriever } from \"@llamaindex/core/retriever\";\nimport { extractText } from \"@llamaindex/core/utils\";\nimport _ from \"lodash\";\nimport { Settings } from \"../../Settings.js\";\nimport { ContextChatEngine } from \"../../engines/chat/index.js\";\nimport { RetrieverQueryEngine } from \"../../engines/query/index.js\";\nimport { storageContextFromDefaults } from \"../../storage/StorageContext.js\";\nimport { BaseIndex } from \"../BaseIndex.js\";\nimport { defaultFormatNodeBatchFn, defaultParseChoiceSelectAnswerFn } from \"./utils.js\";\nexport var SummaryRetrieverMode = /*#__PURE__*/ function(SummaryRetrieverMode) {\n    SummaryRetrieverMode[\"DEFAULT\"] = \"default\";\n    // EMBEDDING = \"embedding\",\n    SummaryRetrieverMode[\"LLM\"] = \"llm\";\n    return SummaryRetrieverMode;\n}({});\n/**\n * A SummaryIndex keeps nodes in a sequential order for use with summarization.\n */ export class SummaryIndex extends BaseIndex {\n    constructor(init){\n        super(init);\n    }\n    static async init(options) {\n        const storageContext = options.storageContext ?? await storageContextFromDefaults({});\n        const { docStore, indexStore } = storageContext;\n        // Setup IndexStruct from storage\n        const indexStructs = await indexStore.getIndexStructs();\n        let indexStruct;\n        if (options.indexStruct && indexStructs.length > 0) {\n            throw new Error(\"Cannot initialize index with both indexStruct and indexStore\");\n        }\n        if (options.indexStruct) {\n            indexStruct = options.indexStruct;\n        } else if (indexStructs.length == 1) {\n            indexStruct = indexStructs[0].type === IndexStructType.LIST ? indexStructs[0] : null;\n        } else if (indexStructs.length > 1 && options.indexId) {\n            indexStruct = await indexStore.getIndexStruct(options.indexId);\n        } else {\n            indexStruct = null;\n        }\n        // check indexStruct type\n        if (indexStruct && indexStruct.type !== IndexStructType.LIST) {\n            throw new Error(\"Attempting to initialize SummaryIndex with non-list indexStruct\");\n        }\n        if (indexStruct) {\n            if (options.nodes) {\n                throw new Error(\"Cannot initialize SummaryIndex with both nodes and indexStruct\");\n            }\n        } else {\n            if (!options.nodes) {\n                throw new Error(\"Cannot initialize SummaryIndex without nodes or indexStruct\");\n            }\n            indexStruct = await SummaryIndex.buildIndexFromNodes(options.nodes, storageContext.docStore);\n            await indexStore.addIndexStruct(indexStruct);\n        }\n        return new SummaryIndex({\n            storageContext,\n            docStore,\n            indexStore,\n            indexStruct\n        });\n    }\n    static async fromDocuments(documents, args = {}) {\n        let { storageContext } = args;\n        storageContext = storageContext ?? await storageContextFromDefaults({});\n        const docStore = storageContext.docStore;\n        await docStore.addDocuments(documents, true);\n        for (const doc of documents){\n            await docStore.setDocumentHash(doc.id_, doc.hash);\n        }\n        const nodes = await Settings.nodeParser.getNodesFromDocuments(documents);\n        const index = await SummaryIndex.init({\n            nodes,\n            storageContext\n        });\n        return index;\n    }\n    asRetriever(options) {\n        const { mode = \"default\" } = options ?? {};\n        switch(mode){\n            case \"default\":\n                return new SummaryIndexRetriever(this);\n            case \"llm\":\n                return new SummaryIndexLLMRetriever(this);\n            default:\n                throw new Error(`Unknown retriever mode: ${mode}`);\n        }\n    }\n    asQueryEngine(options) {\n        let { retriever, responseSynthesizer } = options ?? {};\n        if (!retriever) {\n            retriever = this.asRetriever();\n        }\n        if (!responseSynthesizer) {\n            responseSynthesizer = getResponseSynthesizer(\"compact\");\n        }\n        return new RetrieverQueryEngine(retriever, responseSynthesizer, options?.nodePostprocessors);\n    }\n    asChatEngine(options) {\n        const { retriever, mode, ...contextChatEngineOptions } = options ?? {};\n        return new ContextChatEngine({\n            retriever: retriever ?? this.asRetriever({\n                mode: mode ?? \"default\"\n            }),\n            ...contextChatEngineOptions\n        });\n    }\n    static async buildIndexFromNodes(nodes, docStore, indexStruct) {\n        indexStruct = indexStruct || new IndexList();\n        await docStore.addDocuments(nodes, true);\n        for (const node of nodes){\n            indexStruct.addNode(node);\n        }\n        return indexStruct;\n    }\n    async insertNodes(nodes) {\n        for (const node of nodes){\n            this.indexStruct.addNode(node);\n        }\n    }\n    async deleteRefDoc(refDocId, deleteFromDocStore) {\n        const refDocInfo = await this.docStore.getRefDocInfo(refDocId);\n        if (!refDocInfo) {\n            return;\n        }\n        await this.deleteNodes(refDocInfo.nodeIds, false);\n        if (deleteFromDocStore) {\n            await this.docStore.deleteRefDoc(refDocId, false);\n        }\n        return;\n    }\n    async deleteNodes(nodeIds, deleteFromDocStore) {\n        this.indexStruct.nodes = this.indexStruct.nodes.filter((existingNodeId)=>!nodeIds.includes(existingNodeId));\n        if (deleteFromDocStore) {\n            for (const nodeId of nodeIds){\n                await this.docStore.deleteDocument(nodeId, false);\n            }\n        }\n        await this.storageContext.indexStore.addIndexStruct(this.indexStruct);\n    }\n    async getRefDocInfo() {\n        const nodeDocIds = this.indexStruct.nodes;\n        const nodes = await this.docStore.getNodes(nodeDocIds);\n        const refDocInfoMap = {};\n        for (const node of nodes){\n            const refNode = node.sourceNode;\n            if (_.isNil(refNode)) {\n                continue;\n            }\n            const refDocInfo = await this.docStore.getRefDocInfo(refNode.nodeId);\n            if (_.isNil(refDocInfo)) {\n                continue;\n            }\n            refDocInfoMap[refNode.nodeId] = refDocInfo;\n        }\n        return refDocInfoMap;\n    }\n}\n/**\n * Simple retriever for SummaryIndex that returns all nodes\n */ export class SummaryIndexRetriever extends BaseRetriever {\n    index;\n    constructor(index){\n        super();\n        this.index = index;\n    }\n    async _retrieve(queryBundle) {\n        const nodeIds = this.index.indexStruct.nodes;\n        const nodes = await this.index.docStore.getNodes(nodeIds);\n        return nodes.map((node)=>({\n                node: node,\n                score: 1\n            }));\n    }\n}\n/**\n * LLM retriever for SummaryIndex which lets you select the most relevant chunks.\n */ export class SummaryIndexLLMRetriever extends BaseRetriever {\n    index;\n    choiceSelectPrompt;\n    choiceBatchSize;\n    formatNodeBatchFn;\n    parseChoiceSelectAnswerFn;\n    constructor(index, choiceSelectPrompt, choiceBatchSize = 10, formatNodeBatchFn, parseChoiceSelectAnswerFn){\n        super();\n        this.index = index;\n        this.choiceSelectPrompt = choiceSelectPrompt || defaultChoiceSelectPrompt;\n        this.choiceBatchSize = choiceBatchSize;\n        this.formatNodeBatchFn = formatNodeBatchFn || defaultFormatNodeBatchFn;\n        this.parseChoiceSelectAnswerFn = parseChoiceSelectAnswerFn || defaultParseChoiceSelectAnswerFn;\n    }\n    async _retrieve(query) {\n        const nodeIds = this.index.indexStruct.nodes;\n        const results = [];\n        for(let idx = 0; idx < nodeIds.length; idx += this.choiceBatchSize){\n            const nodeIdsBatch = nodeIds.slice(idx, idx + this.choiceBatchSize);\n            const nodesBatch = await this.index.docStore.getNodes(nodeIdsBatch);\n            const fmtBatchStr = this.formatNodeBatchFn(nodesBatch);\n            const input = {\n                context: fmtBatchStr,\n                query: extractText(query)\n            };\n            const llm = Settings.llm;\n            const rawResponse = (await llm.complete({\n                prompt: this.choiceSelectPrompt.format(input)\n            })).text;\n            // parseResult is a map from doc number to relevance score\n            const parseResult = this.parseChoiceSelectAnswerFn(rawResponse, nodesBatch.length);\n            const choiceNodeIds = nodeIdsBatch.filter((nodeId, idx)=>{\n                return `${idx}` in parseResult;\n            });\n            const choiceNodes = await this.index.docStore.getNodes(choiceNodeIds);\n            const nodeWithScores = choiceNodes.map((node, i)=>({\n                    node: node,\n                    score: _.get(parseResult, `${i + 1}`, 1)\n                }));\n            results.push(...nodeWithScores);\n        }\n        return results;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3939, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/evaluation/Faithfulness.js"],"sourcesContent":["import { PromptMixin } from \"@llamaindex/core/prompts\";\nimport { Document, MetadataMode } from \"@llamaindex/core/schema\";\nimport { extractText } from \"@llamaindex/core/utils\";\nimport { SummaryIndex } from \"../indices/summary/index.js\";\nimport { defaultFaithfulnessRefinePrompt, defaultFaithfulnessTextQaPrompt } from \"./prompts.js\";\nexport class FaithfulnessEvaluator extends PromptMixin {\n    raiseError;\n    evalTemplate;\n    refineTemplate;\n    constructor(params){\n        super();\n        this.raiseError = params?.raiseError ?? false;\n        this.evalTemplate = params?.faithfulnessSystemPrompt ?? defaultFaithfulnessTextQaPrompt;\n        this.refineTemplate = params?.faithFulnessRefinePrompt ?? defaultFaithfulnessRefinePrompt;\n    }\n    _getPromptModules() {\n        return {};\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _getPrompts() {\n        return {\n            faithfulnessSystemPrompt: this.evalTemplate,\n            faithFulnessRefinePrompt: this.refineTemplate\n        };\n    }\n    _updatePrompts(promptsDict) {\n        if (promptsDict.faithfulnessSystemPrompt) {\n            this.evalTemplate = promptsDict.faithfulnessSystemPrompt;\n        }\n        if (promptsDict.faithFulnessRefinePrompt) {\n            this.refineTemplate = promptsDict.faithFulnessRefinePrompt;\n        }\n    }\n    /**\n   * @param query Query to evaluate\n   * @param response  Response to evaluate\n   * @param contexts Array of contexts\n   * @param reference  Reference response\n   * @param sleepTimeInSeconds  Sleep time in seconds\n   */ async evaluate({ query, response, contexts = [], reference, sleepTimeInSeconds = 0 }) {\n        if (query === null || response === null) {\n            throw new Error(\"query, and response must be provided\");\n        }\n        await new Promise((resolve)=>setTimeout(resolve, sleepTimeInSeconds * 1000));\n        const docs = contexts?.map((context)=>new Document({\n                text: context\n            }));\n        const index = await SummaryIndex.fromDocuments(docs, {});\n        const queryEngine = index.asQueryEngine();\n        queryEngine.updatePrompts({\n            \"responseSynthesizer:textQATemplate\": this.evalTemplate,\n            \"responseSynthesizer:refineTemplate\": this.refineTemplate\n        });\n        const responseObj = await queryEngine.query({\n            query: {\n                query: response\n            },\n            stream: false\n        });\n        const rawResponseTxt = responseObj.toString();\n        let passing;\n        if (rawResponseTxt.toLowerCase().includes(\"yes\")) {\n            passing = true;\n        } else {\n            passing = false;\n            if (this.raiseError) {\n                throw new Error(\"The response is invalid\");\n            }\n        }\n        return {\n            query,\n            contexts,\n            response,\n            passing,\n            score: passing ? 1.0 : 0.0,\n            feedback: rawResponseTxt\n        };\n    }\n    /**\n   * @param query Query to evaluate\n   * @param response  Response to evaluate\n   */ async evaluateResponse({ query, response }) {\n        const responseStr = extractText(response?.message.content);\n        const contexts = [];\n        if (response) {\n            for (const node of response.sourceNodes || []){\n                contexts.push(node.node.getContent(MetadataMode.ALL));\n            }\n        }\n        return this.evaluate({\n            query,\n            response: responseStr,\n            contexts\n        });\n    }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;;;;;;AACO,MAAM,8BAA8B,kKAAA,CAAA,cAAW;IAClD,WAAW;IACX,aAAa;IACb,eAAe;IACf,YAAY,MAAM,CAAC;QACf,KAAK;QACL,IAAI,CAAC,UAAU,GAAG,QAAQ,cAAc;QACxC,IAAI,CAAC,YAAY,GAAG,QAAQ,4BAA4B,6JAAA,CAAA,kCAA+B;QACvF,IAAI,CAAC,cAAc,GAAG,QAAQ,4BAA4B,6JAAA,CAAA,kCAA+B;IAC7F;IACA,oBAAoB;QAChB,OAAO,CAAC;IACZ;IACA,8DAA8D;IAC9D,cAAc;QACV,OAAO;YACH,0BAA0B,IAAI,CAAC,YAAY;YAC3C,0BAA0B,IAAI,CAAC,cAAc;QACjD;IACJ;IACA,eAAe,WAAW,EAAE;QACxB,IAAI,YAAY,wBAAwB,EAAE;YACtC,IAAI,CAAC,YAAY,GAAG,YAAY,wBAAwB;QAC5D;QACA,IAAI,YAAY,wBAAwB,EAAE;YACtC,IAAI,CAAC,cAAc,GAAG,YAAY,wBAAwB;QAC9D;IACJ;IACA;;;;;;GAMD,GAAG,MAAM,SAAS,EAAE,KAAK,EAAE,QAAQ,EAAE,WAAW,EAAE,EAAE,SAAS,EAAE,qBAAqB,CAAC,EAAE,EAAE;QACpF,IAAI,UAAU,QAAQ,aAAa,MAAM;YACrC,MAAM,IAAI,MAAM;QACpB;QACA,MAAM,IAAI,QAAQ,CAAC,UAAU,WAAW,SAAS,qBAAqB;QACtE,MAAM,OAAO,UAAU,IAAI,CAAC,UAAU,IAAI,iKAAA,CAAA,WAAQ,CAAC;gBAC3C,MAAM;YACV;QACJ,MAAM,QAAQ,MAAM,mKAAA,CAAA,eAAY,CAAC,aAAa,CAAC,MAAM,CAAC;QACtD,MAAM,cAAc,MAAM,aAAa;QACvC,YAAY,aAAa,CAAC;YACtB,sCAAsC,IAAI,CAAC,YAAY;YACvD,sCAAsC,IAAI,CAAC,cAAc;QAC7D;QACA,MAAM,cAAc,MAAM,YAAY,KAAK,CAAC;YACxC,OAAO;gBACH,OAAO;YACX;YACA,QAAQ;QACZ;QACA,MAAM,iBAAiB,YAAY,QAAQ;QAC3C,IAAI;QACJ,IAAI,eAAe,WAAW,GAAG,QAAQ,CAAC,QAAQ;YAC9C,UAAU;QACd,OAAO;YACH,UAAU;YACV,IAAI,IAAI,CAAC,UAAU,EAAE;gBACjB,MAAM,IAAI,MAAM;YACpB;QACJ;QACA,OAAO;YACH;YACA;YACA;YACA;YACA,OAAO,UAAU,MAAM;YACvB,UAAU;QACd;IACJ;IACA;;;GAGD,GAAG,MAAM,iBAAiB,EAAE,KAAK,EAAE,QAAQ,EAAE,EAAE;QAC1C,MAAM,cAAc,CAAA,GAAA,gKAAA,CAAA,cAAW,AAAD,EAAE,UAAU,QAAQ;QAClD,MAAM,WAAW,EAAE;QACnB,IAAI,UAAU;YACV,KAAK,MAAM,QAAQ,SAAS,WAAW,IAAI,EAAE,CAAC;gBAC1C,SAAS,IAAI,CAAC,KAAK,IAAI,CAAC,UAAU,CAAC,iKAAA,CAAA,eAAY,CAAC,GAAG;YACvD;QACJ;QACA,OAAO,IAAI,CAAC,QAAQ,CAAC;YACjB;YACA,UAAU;YACV;QACJ;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4049, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/evaluation/Relevancy.js"],"sourcesContent":["import { PromptMixin } from \"@llamaindex/core/prompts\";\nimport { Document, MetadataMode } from \"@llamaindex/core/schema\";\nimport { extractText } from \"@llamaindex/core/utils\";\nimport { SummaryIndex } from \"../indices/summary/index.js\";\nimport { defaultRelevancyEvalPrompt, defaultRelevancyRefinePrompt } from \"./prompts.js\";\nexport class RelevancyEvaluator extends PromptMixin {\n    raiseError;\n    evalTemplate;\n    refineTemplate;\n    constructor(params){\n        super();\n        this.raiseError = params?.raiseError ?? false;\n        this.evalTemplate = params?.evalTemplate ?? defaultRelevancyEvalPrompt;\n        this.refineTemplate = params?.refineTemplate ?? defaultRelevancyRefinePrompt;\n    }\n    _getPromptModules() {\n        return {};\n    }\n    _getPrompts() {\n        return {\n            evalTemplate: this.evalTemplate,\n            refineTemplate: this.refineTemplate\n        };\n    }\n    _updatePrompts(prompts) {\n        if (\"evalTemplate\" in prompts) {\n            this.evalTemplate = prompts[\"evalTemplate\"];\n        }\n        if (\"refineTemplate\" in prompts) {\n            this.refineTemplate = prompts[\"refineTemplate\"];\n        }\n    }\n    async evaluate({ query, response, contexts = [], sleepTimeInSeconds = 0 }) {\n        if (query === null || response === null) {\n            throw new Error(\"query, contexts, and response must be provided\");\n        }\n        await new Promise((resolve)=>setTimeout(resolve, sleepTimeInSeconds * 1000));\n        const docs = contexts?.map((context)=>new Document({\n                text: context\n            }));\n        const index = await SummaryIndex.fromDocuments(docs, {});\n        const queryResponse = `Question: ${extractText(query)}\\nResponse: ${response}`;\n        const queryEngine = index.asQueryEngine();\n        queryEngine.updatePrompts({\n            \"responseSynthesizer:textQATemplate\": this.evalTemplate,\n            \"responseSynthesizer:refineTemplate\": this.refineTemplate\n        });\n        const responseObj = await queryEngine.query({\n            query: queryResponse\n        });\n        const rawResponseTxt = responseObj.toString();\n        let passing;\n        if (rawResponseTxt.toLowerCase().includes(\"yes\")) {\n            passing = true;\n        } else {\n            passing = false;\n            if (this.raiseError) {\n                throw new Error(\"The response is invalid\");\n            }\n        }\n        return {\n            query,\n            contexts,\n            response,\n            passing,\n            score: passing ? 1.0 : 0.0,\n            feedback: rawResponseTxt\n        };\n    }\n    /**\n   * @param query Query to evaluate\n   * @param response  Response to evaluate\n   */ async evaluateResponse({ query, response }) {\n        const responseStr = extractText(response?.message.content);\n        const contexts = [];\n        if (response) {\n            for (const node of response.sourceNodes || []){\n                contexts.push(node.node.getContent(MetadataMode.ALL));\n            }\n        }\n        return this.evaluate({\n            query,\n            response: responseStr,\n            contexts\n        });\n    }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;;;;;;AACO,MAAM,2BAA2B,kKAAA,CAAA,cAAW;IAC/C,WAAW;IACX,aAAa;IACb,eAAe;IACf,YAAY,MAAM,CAAC;QACf,KAAK;QACL,IAAI,CAAC,UAAU,GAAG,QAAQ,cAAc;QACxC,IAAI,CAAC,YAAY,GAAG,QAAQ,gBAAgB,6JAAA,CAAA,6BAA0B;QACtE,IAAI,CAAC,cAAc,GAAG,QAAQ,kBAAkB,6JAAA,CAAA,+BAA4B;IAChF;IACA,oBAAoB;QAChB,OAAO,CAAC;IACZ;IACA,cAAc;QACV,OAAO;YACH,cAAc,IAAI,CAAC,YAAY;YAC/B,gBAAgB,IAAI,CAAC,cAAc;QACvC;IACJ;IACA,eAAe,OAAO,EAAE;QACpB,IAAI,kBAAkB,SAAS;YAC3B,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC,eAAe;QAC/C;QACA,IAAI,oBAAoB,SAAS;YAC7B,IAAI,CAAC,cAAc,GAAG,OAAO,CAAC,iBAAiB;QACnD;IACJ;IACA,MAAM,SAAS,EAAE,KAAK,EAAE,QAAQ,EAAE,WAAW,EAAE,EAAE,qBAAqB,CAAC,EAAE,EAAE;QACvE,IAAI,UAAU,QAAQ,aAAa,MAAM;YACrC,MAAM,IAAI,MAAM;QACpB;QACA,MAAM,IAAI,QAAQ,CAAC,UAAU,WAAW,SAAS,qBAAqB;QACtE,MAAM,OAAO,UAAU,IAAI,CAAC,UAAU,IAAI,iKAAA,CAAA,WAAQ,CAAC;gBAC3C,MAAM;YACV;QACJ,MAAM,QAAQ,MAAM,mKAAA,CAAA,eAAY,CAAC,aAAa,CAAC,MAAM,CAAC;QACtD,MAAM,gBAAgB,CAAC,UAAU,EAAE,CAAA,GAAA,gKAAA,CAAA,cAAW,AAAD,EAAE,OAAO,YAAY,EAAE,UAAU;QAC9E,MAAM,cAAc,MAAM,aAAa;QACvC,YAAY,aAAa,CAAC;YACtB,sCAAsC,IAAI,CAAC,YAAY;YACvD,sCAAsC,IAAI,CAAC,cAAc;QAC7D;QACA,MAAM,cAAc,MAAM,YAAY,KAAK,CAAC;YACxC,OAAO;QACX;QACA,MAAM,iBAAiB,YAAY,QAAQ;QAC3C,IAAI;QACJ,IAAI,eAAe,WAAW,GAAG,QAAQ,CAAC,QAAQ;YAC9C,UAAU;QACd,OAAO;YACH,UAAU;YACV,IAAI,IAAI,CAAC,UAAU,EAAE;gBACjB,MAAM,IAAI,MAAM;YACpB;QACJ;QACA,OAAO;YACH;YACA;YACA;YACA;YACA,OAAO,UAAU,MAAM;YACvB,UAAU;QACd;IACJ;IACA;;;GAGD,GAAG,MAAM,iBAAiB,EAAE,KAAK,EAAE,QAAQ,EAAE,EAAE;QAC1C,MAAM,cAAc,CAAA,GAAA,gKAAA,CAAA,cAAW,AAAD,EAAE,UAAU,QAAQ;QAClD,MAAM,WAAW,EAAE;QACnB,IAAI,UAAU;YACV,KAAK,MAAM,QAAQ,SAAS,WAAW,IAAI,EAAE,CAAC;gBAC1C,SAAS,IAAI,CAAC,KAAK,IAAI,CAAC,UAAU,CAAC,iKAAA,CAAA,eAAY,CAAC,GAAG;YACvD;QACJ;QACA,OAAO,IAAI,CAAC,QAAQ,CAAC;YACjB;YACA,UAAU;YACV;QACJ;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4150, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/evaluation/index.js"],"sourcesContent":["export * from \"./Correctness.js\";\nexport * from \"./Faithfulness.js\";\nexport * from \"./prompts.js\";\nexport * from \"./Relevancy.js\";\nexport * from \"./utils.js\";\n"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4180, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/extractors/types.js"],"sourcesContent":["import { defaultNodeTextTemplate } from \"@llamaindex/core/prompts\";\nimport { MetadataMode, TextNode, TransformComponent } from \"@llamaindex/core/schema\";\n/*\n * Abstract class for all extractors.\n */ export class BaseExtractor extends TransformComponent {\n    isTextNodeOnly = true;\n    showProgress = true;\n    metadataMode = MetadataMode.ALL;\n    disableTemplateRewrite = false;\n    inPlace = true;\n    numWorkers = 4;\n    constructor(){\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        super(async (nodes, options)=>{\n            return this.processNodes(nodes, options?.excludedEmbedMetadataKeys, options?.excludedLlmMetadataKeys);\n        });\n    }\n    /**\n   *\n   * @param nodes Nodes to extract metadata from.\n   * @param excludedEmbedMetadataKeys Metadata keys to exclude from the embedding.\n   * @param excludedLlmMetadataKeys Metadata keys to exclude from the LLM.\n   * @returns Metadata extracted from the nodes.\n   */ async processNodes(nodes, excludedEmbedMetadataKeys = undefined, excludedLlmMetadataKeys = undefined) {\n        let newNodes;\n        if (this.inPlace) {\n            newNodes = nodes;\n        } else {\n            newNodes = nodes.slice();\n        }\n        const curMetadataList = await this.extract(newNodes);\n        for(const idx in newNodes){\n            newNodes[idx].metadata = {\n                ...newNodes[idx].metadata,\n                ...curMetadataList[idx]\n            };\n        }\n        for(const idx in newNodes){\n            if (excludedEmbedMetadataKeys) {\n                newNodes[idx].excludedEmbedMetadataKeys.concat(excludedEmbedMetadataKeys);\n            }\n            if (excludedLlmMetadataKeys) {\n                newNodes[idx].excludedLlmMetadataKeys.concat(excludedLlmMetadataKeys);\n            }\n            if (!this.disableTemplateRewrite) {\n                if (newNodes[idx] instanceof TextNode) {\n                    newNodes[idx] = new TextNode({\n                        ...newNodes[idx],\n                        textTemplate: defaultNodeTextTemplate.format()\n                    });\n                }\n            }\n        }\n        return newNodes;\n    }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAGW,MAAM,sBAAsB,iKAAA,CAAA,qBAAkB;IACrD,iBAAiB,KAAK;IACtB,eAAe,KAAK;IACpB,eAAe,iKAAA,CAAA,eAAY,CAAC,GAAG,CAAC;IAChC,yBAAyB,MAAM;IAC/B,UAAU,KAAK;IACf,aAAa,EAAE;IACf,aAAa;QACT,8DAA8D;QAC9D,KAAK,CAAC,OAAO,OAAO;YAChB,OAAO,IAAI,CAAC,YAAY,CAAC,OAAO,SAAS,2BAA2B,SAAS;QACjF;IACJ;IACA;;;;;;GAMD,GAAG,MAAM,aAAa,KAAK,EAAE,4BAA4B,SAAS,EAAE,0BAA0B,SAAS,EAAE;QACpG,IAAI;QACJ,IAAI,IAAI,CAAC,OAAO,EAAE;YACd,WAAW;QACf,OAAO;YACH,WAAW,MAAM,KAAK;QAC1B;QACA,MAAM,kBAAkB,MAAM,IAAI,CAAC,OAAO,CAAC;QAC3C,IAAI,MAAM,OAAO,SAAS;YACtB,QAAQ,CAAC,IAAI,CAAC,QAAQ,GAAG;gBACrB,GAAG,QAAQ,CAAC,IAAI,CAAC,QAAQ;gBACzB,GAAG,eAAe,CAAC,IAAI;YAC3B;QACJ;QACA,IAAI,MAAM,OAAO,SAAS;YACtB,IAAI,2BAA2B;gBAC3B,QAAQ,CAAC,IAAI,CAAC,yBAAyB,CAAC,MAAM,CAAC;YACnD;YACA,IAAI,yBAAyB;gBACzB,QAAQ,CAAC,IAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC;YACjD;YACA,IAAI,CAAC,IAAI,CAAC,sBAAsB,EAAE;gBAC9B,IAAI,QAAQ,CAAC,IAAI,YAAY,iKAAA,CAAA,WAAQ,EAAE;oBACnC,QAAQ,CAAC,IAAI,GAAG,IAAI,iKAAA,CAAA,WAAQ,CAAC;wBACzB,GAAG,QAAQ,CAAC,IAAI;wBAChB,cAAc,kKAAA,CAAA,0BAAuB,CAAC,MAAM;oBAChD;gBACJ;YACJ;QACJ;QACA,OAAO;IACX;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4245, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/extractors/MetadataExtractors.js"],"sourcesContent":["import { PromptTemplate, defaultKeywordExtractPrompt, defaultQuestionExtractPrompt, defaultSummaryPrompt, defaultTitleCombinePromptTemplate, defaultTitleExtractorPromptTemplate } from \"@llamaindex/core/prompts\";\nimport { MetadataMode, TextNode } from \"@llamaindex/core/schema\";\nimport { OpenAI } from \"@llamaindex/openai\";\nimport { BaseExtractor } from \"./types.js\";\nconst STRIP_REGEX = /(\\r\\n|\\n|\\r)/gm;\n/**\n * Extract keywords from a list of nodes.\n */ export class KeywordExtractor extends BaseExtractor {\n    /**\n   * LLM instance.\n   * @type {LLM}\n   */ llm;\n    /**\n   * Number of keywords to extract.\n   * @type {number}\n   * @default 5\n   */ keywords = 5;\n    /**\n   * The prompt template to use for the question extractor.\n   * @type {string}\n   */ promptTemplate;\n    /**\n   * Constructor for the KeywordExtractor class.\n   * @param {LLM} llm LLM instance.\n   * @param {number} keywords Number of keywords to extract.\n   * @throws {Error} If keywords is less than 1.\n   */ constructor(options){\n        if (options?.keywords && options.keywords < 1) throw new Error(\"Keywords must be greater than 0\");\n        super();\n        this.llm = options?.llm ?? new OpenAI();\n        this.keywords = options?.keywords ?? 5;\n        this.promptTemplate = options?.promptTemplate ? new PromptTemplate({\n            templateVars: [\n                \"context\",\n                \"maxKeywords\"\n            ],\n            template: options.promptTemplate\n        }) : defaultKeywordExtractPrompt;\n    }\n    /**\n   *\n   * @param node Node to extract keywords from.\n   * @returns Keywords extracted from the node.\n   */ async extractKeywordsFromNodes(node) {\n        if (this.isTextNodeOnly && !(node instanceof TextNode)) {\n            return {};\n        }\n        const completion = await this.llm.complete({\n            prompt: this.promptTemplate.format({\n                context: node.getContent(MetadataMode.ALL),\n                maxKeywords: this.keywords.toString()\n            })\n        });\n        return {\n            excerptKeywords: completion.text\n        };\n    }\n    /**\n   *\n   * @param nodes Nodes to extract keywords from.\n   * @returns Keywords extracted from the nodes.\n   */ async extract(nodes) {\n        const results = await Promise.all(nodes.map((node)=>this.extractKeywordsFromNodes(node)));\n        return results;\n    }\n}\n/**\n * Extract title from a list of nodes.\n */ export class TitleExtractor extends BaseExtractor {\n    /**\n   * LLM instance.\n   * @type {LLM}\n   */ llm;\n    /**\n   * Can work for mixture of text and non-text nodes\n   * @type {boolean}\n   * @default false\n   */ isTextNodeOnly = false;\n    /**\n   * Number of nodes to extrct titles from.\n   * @type {number}\n   * @default 5\n   */ nodes = 5;\n    /**\n   * The prompt template to use for the title extractor.\n   * @type {string}\n   */ nodeTemplate;\n    /**\n   * The prompt template to merge title with..\n   * @type {string}\n   */ combineTemplate;\n    /**\n   * Constructor for the TitleExtractor class.\n   * @param {LLM} llm LLM instance.\n   * @param {number} nodes Number of nodes to extract titles from.\n   * @param {TitleExtractorPrompt} nodeTemplate The prompt template to use for the title extractor.\n   * @param {string} combineTemplate The prompt template to merge title with..\n   */ constructor(options){\n        super();\n        this.llm = options?.llm ?? new OpenAI();\n        this.nodes = options?.nodes ?? 5;\n        this.nodeTemplate = options?.nodeTemplate ? new PromptTemplate({\n            templateVars: [\n                \"context\"\n            ],\n            template: options.nodeTemplate\n        }) : defaultTitleExtractorPromptTemplate;\n        this.combineTemplate = options?.combineTemplate ? new PromptTemplate({\n            templateVars: [\n                \"context\"\n            ],\n            template: options.combineTemplate\n        }) : defaultTitleCombinePromptTemplate;\n    }\n    /**\n   * Extract titles from a list of nodes.\n   * @param {BaseNode[]} nodes Nodes to extract titles from.\n   * @returns {Promise<BaseNode<ExtractTitle>[]>} Titles extracted from the nodes.\n   */ async extract(nodes) {\n        const nodesToExtractTitle = this.filterNodes(nodes);\n        if (!nodesToExtractTitle.length) {\n            return [];\n        }\n        const nodesByDocument = this.separateNodesByDocument(nodesToExtractTitle);\n        const titlesByDocument = await this.extractTitles(nodesByDocument);\n        return nodesToExtractTitle.map((node)=>{\n            return {\n                documentTitle: titlesByDocument[node.sourceNode?.nodeId ?? \"\"]\n            };\n        });\n    }\n    filterNodes(nodes) {\n        return nodes.filter((node)=>{\n            if (this.isTextNodeOnly && !(node instanceof TextNode)) {\n                return false;\n            }\n            return true;\n        });\n    }\n    separateNodesByDocument(nodes) {\n        const nodesByDocument = {};\n        for (const node of nodes){\n            const parentNode = node.sourceNode?.nodeId;\n            if (!parentNode) {\n                continue;\n            }\n            if (!nodesByDocument[parentNode]) {\n                nodesByDocument[parentNode] = [];\n            }\n            nodesByDocument[parentNode].push(node);\n        }\n        return nodesByDocument;\n    }\n    async extractTitles(nodesByDocument) {\n        const titlesByDocument = {};\n        for (const [key, nodes] of Object.entries(nodesByDocument)){\n            const titleCandidates = await this.getTitlesCandidates(nodes);\n            const combinedTitles = titleCandidates.join(\", \");\n            const completion = await this.llm.complete({\n                prompt: this.combineTemplate.format({\n                    context: combinedTitles\n                })\n            });\n            titlesByDocument[key] = completion.text;\n        }\n        return titlesByDocument;\n    }\n    async getTitlesCandidates(nodes) {\n        const titleJobs = nodes.map(async (node)=>{\n            const completion = await this.llm.complete({\n                prompt: this.nodeTemplate.format({\n                    context: node.getContent(MetadataMode.ALL)\n                })\n            });\n            return completion.text;\n        });\n        return await Promise.all(titleJobs);\n    }\n}\n/**\n * Extract questions from a list of nodes.\n */ export class QuestionsAnsweredExtractor extends BaseExtractor {\n    /**\n   * LLM instance.\n   * @type {LLM}\n   */ llm;\n    /**\n   * Number of questions to generate.\n   * @type {number}\n   * @default 5\n   */ questions = 5;\n    /**\n   * The prompt template to use for the question extractor.\n   * @type {string}\n   */ promptTemplate;\n    /**\n   * Wheter to use metadata for embeddings only\n   * @type {boolean}\n   * @default false\n   */ embeddingOnly = false;\n    /**\n   * Constructor for the QuestionsAnsweredExtractor class.\n   * @param {LLM} llm LLM instance.\n   * @param {number} questions Number of questions to generate.\n   * @param {TextQAPrompt} promptTemplate The prompt template to use for the question extractor.\n   * @param {boolean} embeddingOnly Wheter to use metadata for embeddings only.\n   */ constructor(options){\n        if (options?.questions && options.questions < 1) throw new Error(\"Questions must be greater than 0\");\n        super();\n        this.llm = options?.llm ?? new OpenAI();\n        this.questions = options?.questions ?? 5;\n        this.promptTemplate = options?.promptTemplate ? new PromptTemplate({\n            templateVars: [\n                \"numQuestions\",\n                \"context\"\n            ],\n            template: options.promptTemplate\n        }).partialFormat({\n            numQuestions: \"5\"\n        }) : defaultQuestionExtractPrompt;\n        this.embeddingOnly = options?.embeddingOnly ?? false;\n    }\n    /**\n   * Extract answered questions from a node.\n   * @param {BaseNode} node Node to extract questions from.\n   * @returns {Promise<Array<ExtractQuestion> | Array<{}>>} Questions extracted from the node.\n   */ async extractQuestionsFromNode(node) {\n        if (this.isTextNodeOnly && !(node instanceof TextNode)) {\n            return {};\n        }\n        const contextStr = node.getContent(this.metadataMode);\n        const prompt = this.promptTemplate.format({\n            context: contextStr,\n            numQuestions: this.questions.toString()\n        });\n        const questions = await this.llm.complete({\n            prompt\n        });\n        return {\n            questionsThisExcerptCanAnswer: questions.text.replace(STRIP_REGEX, \"\")\n        };\n    }\n    /**\n   * Extract answered questions from a list of nodes.\n   * @param {BaseNode[]} nodes Nodes to extract questions from.\n   * @returns {Promise<Array<ExtractQuestion> | Array<{}>>} Questions extracted from the nodes.\n   */ async extract(nodes) {\n        const results = await Promise.all(nodes.map((node)=>this.extractQuestionsFromNode(node)));\n        return results;\n    }\n}\n/**\n * Extract summary from a list of nodes.\n */ export class SummaryExtractor extends BaseExtractor {\n    /**\n   * LLM instance.\n   * @type {LLM}\n   */ llm;\n    /**\n   * List of summaries to extract: 'self', 'prev', 'next'\n   * @type {string[]}\n   */ summaries;\n    /**\n   * The prompt template to use for the summary extractor.\n   * @type {string}\n   */ promptTemplate;\n    selfSummary;\n    prevSummary;\n    nextSummary;\n    constructor(options){\n        const summaries = options?.summaries ?? [\n            \"self\"\n        ];\n        if (summaries && !summaries.some((s)=>[\n                \"self\",\n                \"prev\",\n                \"next\"\n            ].includes(s))) throw new Error(\"Summaries must be one of 'self', 'prev', 'next'\");\n        super();\n        this.llm = options?.llm ?? new OpenAI();\n        this.summaries = summaries;\n        this.promptTemplate = options?.promptTemplate ? new PromptTemplate({\n            templateVars: [\n                \"context\"\n            ],\n            template: options.promptTemplate\n        }) : defaultSummaryPrompt;\n        this.selfSummary = summaries?.includes(\"self\") ?? false;\n        this.prevSummary = summaries?.includes(\"prev\") ?? false;\n        this.nextSummary = summaries?.includes(\"next\") ?? false;\n    }\n    /**\n   * Extract summary from a node.\n   * @param {BaseNode} node Node to extract summary from.\n   * @returns {Promise<string>} Summary extracted from the node.\n   */ async generateNodeSummary(node) {\n        if (this.isTextNodeOnly && !(node instanceof TextNode)) {\n            return \"\";\n        }\n        const context = node.getContent(this.metadataMode);\n        const prompt = this.promptTemplate.format({\n            context\n        });\n        const summary = await this.llm.complete({\n            prompt\n        });\n        return summary.text.replace(STRIP_REGEX, \"\");\n    }\n    /**\n   * Extract summaries from a list of nodes.\n   * @param {BaseNode[]} nodes Nodes to extract summaries from.\n   * @returns {Promise<Array<ExtractSummary> | Arry<{}>>} Summaries extracted from the nodes.\n   */ async extract(nodes) {\n        if (!nodes.every((n)=>n instanceof TextNode)) throw new Error(\"Only `TextNode` is allowed for `Summary` extractor\");\n        const nodeSummaries = await Promise.all(nodes.map((node)=>this.generateNodeSummary(node)));\n        const metadataList = nodes.map(()=>({}));\n        for(let i = 0; i < nodes.length; i++){\n            if (i > 0 && this.prevSummary && nodeSummaries[i - 1]) {\n                metadataList[i][\"prevSectionSummary\"] = nodeSummaries[i - 1];\n            }\n            if (i < nodes.length - 1 && this.nextSummary && nodeSummaries[i + 1]) {\n                metadataList[i][\"nextSectionSummary\"] = nodeSummaries[i + 1];\n            }\n            if (this.selfSummary && nodeSummaries[i]) {\n                metadataList[i][\"sectionSummary\"] = nodeSummaries[i];\n            }\n        }\n        return metadataList;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4583, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/extractors/index.js"],"sourcesContent":["export { KeywordExtractor, QuestionsAnsweredExtractor, SummaryExtractor, TitleExtractor } from \"./MetadataExtractors.js\";\nexport { BaseExtractor } from \"./types.js\";\n"],"names":[],"mappings":";AAAA;AACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4604, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/internal/deps/rake-modified.js"],"sourcesContent":["// generate from \"tsup ./src/index.js --format esm\"\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __commonJS = (cb, mod)=>function __require() {\n        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {\n            exports: {}\n        }).exports, mod), mod.exports;\n    };\n// src/stopwords.js\nvar require_stopwords = __commonJS({\n    \"src/stopwords.js\" (exports, module) {\n        \"use strict\";\n        module.exports = {\n            stopwords: [\n                \"a\",\n                \"about\",\n                \"above\",\n                \"across\",\n                \"after\",\n                \"again\",\n                \"against\",\n                \"all\",\n                \"almost\",\n                \"alone\",\n                \"along\",\n                \"already\",\n                \"also\",\n                \"although\",\n                \"always\",\n                \"among\",\n                \"an\",\n                \"and\",\n                \"another\",\n                \"any\",\n                \"anybody\",\n                \"anyone\",\n                \"anything\",\n                \"anywhere\",\n                \"are\",\n                \"area\",\n                \"areas\",\n                \"around\",\n                \"as\",\n                \"ask\",\n                \"asked\",\n                \"asking\",\n                \"asks\",\n                \"at\",\n                \"away\",\n                \"b\",\n                \"back\",\n                \"backed\",\n                \"backing\",\n                \"backs\",\n                \"be\",\n                \"because\",\n                \"become\",\n                \"becomes\",\n                \"became\",\n                \"been\",\n                \"before\",\n                \"began\",\n                \"behind\",\n                \"being\",\n                \"beings\",\n                \"best\",\n                \"better\",\n                \"between\",\n                \"big\",\n                \"both\",\n                \"but\",\n                \"by\",\n                \"c\",\n                \"came\",\n                \"can\",\n                \"cannot\",\n                \"case\",\n                \"cases\",\n                \"certain\",\n                \"certainly\",\n                \"clear\",\n                \"clearly\",\n                \"come\",\n                \"contains\",\n                \"could\",\n                \"d\",\n                \"did\",\n                \"differ\",\n                \"different\",\n                \"differently\",\n                \"do\",\n                \"does\",\n                \"done\",\n                \"down\",\n                \"downed\",\n                \"downing\",\n                \"downs\",\n                \"during\",\n                \"e\",\n                \"each\",\n                \"early\",\n                \"either\",\n                \"end\",\n                \"ended\",\n                \"ending\",\n                \"ends\",\n                \"enough\",\n                \"even\",\n                \"evenly\",\n                \"ever\",\n                \"every\",\n                \"everybody\",\n                \"everyone\",\n                \"everything\",\n                \"everywhere\",\n                \"f\",\n                \"face\",\n                \"faces\",\n                \"fact\",\n                \"facts\",\n                \"far\",\n                \"felt\",\n                \"few\",\n                \"find\",\n                \"finds\",\n                \"first\",\n                \"for\",\n                \"four\",\n                \"from\",\n                \"full\",\n                \"fully\",\n                \"further\",\n                \"furthered\",\n                \"furthering\",\n                \"furthers\",\n                \"g\",\n                \"gave\",\n                \"general\",\n                \"generally\",\n                \"get\",\n                \"gets\",\n                \"give\",\n                \"given\",\n                \"gives\",\n                \"go\",\n                \"going\",\n                \"good\",\n                \"goods\",\n                \"got\",\n                \"great\",\n                \"greater\",\n                \"greatest\",\n                \"group\",\n                \"grouped\",\n                \"grouping\",\n                \"groups\",\n                \"h\",\n                \"had\",\n                \"has\",\n                \"have\",\n                \"having\",\n                \"he\",\n                \"her\",\n                \"herself\",\n                \"here\",\n                \"high\",\n                \"higher\",\n                \"highest\",\n                \"him\",\n                \"himself\",\n                \"his\",\n                \"how\",\n                \"however\",\n                \"i\",\n                \"if\",\n                \"important\",\n                \"in\",\n                \"interest\",\n                \"interested\",\n                \"interesting\",\n                \"interests\",\n                \"into\",\n                \"is\",\n                \"it\",\n                \"its\",\n                \"itself\",\n                \"j\",\n                \"just\",\n                \"k\",\n                \"keep\",\n                \"keeps\",\n                \"kind\",\n                \"knew\",\n                \"know\",\n                \"known\",\n                \"knows\",\n                \"l\",\n                \"large\",\n                \"largely\",\n                \"last\",\n                \"later\",\n                \"latest\",\n                \"least\",\n                \"less\",\n                \"let\",\n                \"lets\",\n                \"like\",\n                \"likely\",\n                \"long\",\n                \"longer\",\n                \"longest\",\n                \"m\",\n                \"made\",\n                \"make\",\n                \"making\",\n                \"man\",\n                \"many\",\n                \"may\",\n                \"me\",\n                \"member\",\n                \"members\",\n                \"men\",\n                \"might\",\n                \"more\",\n                \"most\",\n                \"mostly\",\n                \"mr\",\n                \"mrs\",\n                \"much\",\n                \"must\",\n                \"my\",\n                \"myself\",\n                \"n\",\n                \"necessary\",\n                \"need\",\n                \"needed\",\n                \"needing\",\n                \"needs\",\n                \"never\",\n                \"new\",\n                \"newer\",\n                \"newest\",\n                \"next\",\n                \"no\",\n                \"non\",\n                \"not\",\n                \"nobody\",\n                \"noone\",\n                \"nothing\",\n                \"now\",\n                \"nowhere\",\n                \"number\",\n                \"numbers\",\n                \"o\",\n                \"of\",\n                \"off\",\n                \"often\",\n                \"old\",\n                \"older\",\n                \"oldest\",\n                \"on\",\n                \"once\",\n                \"one\",\n                \"only\",\n                \"open\",\n                \"opened\",\n                \"opening\",\n                \"opens\",\n                \"or\",\n                \"order\",\n                \"ordered\",\n                \"ordering\",\n                \"orders\",\n                \"other\",\n                \"others\",\n                \"our\",\n                \"out\",\n                \"over\",\n                \"p\",\n                \"part\",\n                \"parted\",\n                \"parting\",\n                \"parts\",\n                \"per\",\n                \"perhaps\",\n                \"place\",\n                \"places\",\n                \"point\",\n                \"pointed\",\n                \"pointing\",\n                \"points\",\n                \"possible\",\n                \"present\",\n                \"presented\",\n                \"presenting\",\n                \"presents\",\n                \"problem\",\n                \"problems\",\n                \"put\",\n                \"puts\",\n                \"q\",\n                \"quite\",\n                \"r\",\n                \"rather\",\n                \"really\",\n                \"right\",\n                \"room\",\n                \"rooms\",\n                \"s\",\n                \"said\",\n                \"same\",\n                \"saw\",\n                \"say\",\n                \"says\",\n                \"second\",\n                \"seconds\",\n                \"see\",\n                \"sees\",\n                \"seem\",\n                \"seemed\",\n                \"seeming\",\n                \"seems\",\n                \"several\",\n                \"shall\",\n                \"she\",\n                \"should\",\n                \"show\",\n                \"showed\",\n                \"showing\",\n                \"shows\",\n                \"side\",\n                \"sides\",\n                \"since\",\n                \"small\",\n                \"smaller\",\n                \"smallest\",\n                \"so\",\n                \"some\",\n                \"somebody\",\n                \"someone\",\n                \"something\",\n                \"somewhere\",\n                \"state\",\n                \"states\",\n                \"still\",\n                \"such\",\n                \"sure\",\n                \"t\",\n                \"take\",\n                \"taken\",\n                \"than\",\n                \"that\",\n                \"the\",\n                \"their\",\n                \"them\",\n                \"then\",\n                \"there\",\n                \"therefore\",\n                \"these\",\n                \"they\",\n                \"thing\",\n                \"things\",\n                \"think\",\n                \"thinks\",\n                \"this\",\n                \"those\",\n                \"though\",\n                \"thought\",\n                \"thoughts\",\n                \"three\",\n                \"through\",\n                \"thus\",\n                \"to\",\n                \"today\",\n                \"together\",\n                \"too\",\n                \"took\",\n                \"toward\",\n                \"turn\",\n                \"turned\",\n                \"turning\",\n                \"turns\",\n                \"two\",\n                \"u\",\n                \"under\",\n                \"until\",\n                \"up\",\n                \"upon\",\n                \"us\",\n                \"use\",\n                \"uses\",\n                \"used\",\n                \"v\",\n                \"very\",\n                \"w\",\n                \"want\",\n                \"wanted\",\n                \"wanting\",\n                \"wants\",\n                \"was\",\n                \"way\",\n                \"ways\",\n                \"we\",\n                \"well\",\n                \"wells\",\n                \"went\",\n                \"were\",\n                \"what\",\n                \"when\",\n                \"where\",\n                \"whether\",\n                \"which\",\n                \"while\",\n                \"who\",\n                \"whole\",\n                \"whose\",\n                \"why\",\n                \"will\",\n                \"with\",\n                \"within\",\n                \"without\",\n                \"work\",\n                \"worked\",\n                \"working\",\n                \"works\",\n                \"would\",\n                \"y\",\n                \"year\",\n                \"years\",\n                \"yet\",\n                \"you\",\n                \"young\",\n                \"younger\",\n                \"youngest\",\n                \"your\",\n                \"yours\",\n                \"eoc\",\n                \"mu\",\n                \"sigma\",\n                \"mu sigma\",\n                \"musigma\",\n                \"client\",\n                \"clients\",\n                \"capabilities\",\n                \"capability\",\n                \"firm\",\n                \"firms\",\n                \"biggest\",\n                \"-\"\n            ]\n        };\n    }\n});\n// src/index.js\nimport _ from \"lodash\";\nconst { fromPairs, sortBy, toPairs } = _;\nvar stopwords = require_stopwords();\nfunction isNumber(str) {\n    return /\\d/.test(str);\n}\nfunction isAcceptable(phrase, minCharLength, maxWordsLength) {\n    if (phrase < minCharLength) {\n        return false;\n    }\n    let words = phrase.split(\" \");\n    if (words.length > maxWordsLength) {\n        return false;\n    }\n    let digits = 0;\n    let alpha = 0;\n    for(let i = 0; i < phrase.length; i++){\n        if (/\\d/.test(phrase[i])) digits += 1;\n        if (/[a-zA-Z]/.test(phrase[i])) alpha += 1;\n    }\n    if (alpha == 0) {\n        return false;\n    }\n    if (digits > alpha) {\n        return false;\n    }\n    return true;\n}\nfunction countOccurances(haystack, needle) {\n    return haystack.reduce((n, value)=>{\n        return n + (value === needle);\n    }, 0);\n}\nfunction generateCandidateKeywordScores(phraseList, wordScore, minKeywordFrequency = 1) {\n    let keywordCandidates = {};\n    phraseList.forEach((phrase)=>{\n        if (minKeywordFrequency > 1) {\n            if (countOccurances(phraseList, phrase) < minKeywordFrequency) {\n                return;\n            }\n        }\n        phrase in keywordCandidates || (keywordCandidates[phrase] = 0);\n        let wordList = separateWords(phrase, 0);\n        let candidateScore = 0;\n        wordList.forEach((word)=>{\n            candidateScore += wordScore[word];\n            keywordCandidates[phrase] = candidateScore;\n        });\n    });\n    return keywordCandidates;\n}\nfunction separateWords(text, minWordReturnSize) {\n    let wordDelimiters = /[^a-zA-Z0-9_\\+\\-/]/;\n    let words = [];\n    text.split(wordDelimiters).forEach((singleWord)=>{\n        let currentWord = singleWord.trim().toLowerCase();\n        if (currentWord.length > minWordReturnSize && currentWord != \"\" && !isNumber(currentWord)) {\n            words.push(currentWord);\n        }\n    });\n    return words;\n}\nfunction calculateWordScores(phraseList) {\n    let wordFrequency = {};\n    let wordDegree = {};\n    phraseList.forEach((phrase)=>{\n        let wordList = separateWords(phrase, 0);\n        let wordListLength = wordList.length;\n        let wordListDegree = wordListLength - 1;\n        wordList.forEach((word)=>{\n            word in wordFrequency || (wordFrequency[word] = 0);\n            wordFrequency[word] += 1;\n            word in wordDegree || (wordDegree[word] = 0);\n            wordDegree[word] += wordListDegree;\n        });\n    });\n    Object.keys(wordFrequency).forEach((item)=>{\n        wordDegree[item] = wordDegree[item] + wordFrequency[item];\n    });\n    let wordScore = {};\n    Object.keys(wordFrequency).forEach((item)=>{\n        item in wordScore || (wordScore[item] = 0);\n        wordScore[item] = wordDegree[item] / (wordFrequency[item] * 1);\n    });\n    return wordScore;\n}\nfunction generateCandidateKeywords(sentenceList, stopWordPattern, minCharLength = 1, maxWordsLength = 5) {\n    let phraseList = [];\n    sentenceList.forEach((sentence)=>{\n        let tmp = stopWordPattern[Symbol.replace](sentence, \"|\");\n        let phrases = tmp.split(\"|\");\n        phrases.forEach((ph)=>{\n            let phrase = ph.trim().toLowerCase();\n            if (phrase != \"\" && isAcceptable(phrase, minCharLength, maxWordsLength)) {\n                phraseList.push(phrase);\n            } else {}\n        });\n    });\n    return phraseList;\n}\nfunction buildStopWordRegex(path) {\n    let stopWordList = loadStopWords(path);\n    let stopWordRegexList = [];\n    stopWordList.forEach((word)=>{\n        if (/\\w+/.test(word)) {\n            let wordRegex = `\\\\b${word}\\\\b`;\n            stopWordRegexList.push(wordRegex);\n        }\n    });\n    let stopWordPattern = new RegExp(stopWordRegexList.join(\"|\"), \"ig\");\n    return stopWordPattern;\n}\nfunction splitSentences(text) {\n    let sentenceDelimiters = /[\\[\\]\\n.!?,;:\\t\\\\-\\\\\"\\\\(\\\\)\\\\\\'\\u2019\\u2013]/;\n    return text.split(sentenceDelimiters);\n}\nfunction loadStopWords(path) {\n    let contents = stopwords.stopwords;\n    return contents;\n}\nfunction rake(text, stopWordsPath, minCharLength = 3, maxWordsLength = 5, minKeywordFrequency = 1) {\n    let stopWordPattern = buildStopWordRegex(stopWordsPath);\n    let sentenceList = splitSentences(text);\n    let phraseList = generateCandidateKeywords(sentenceList, stopWordPattern, minCharLength, maxWordsLength);\n    let wordScores = calculateWordScores(phraseList);\n    let keywordCandidates = generateCandidateKeywordScores(phraseList, wordScores, minKeywordFrequency);\n    let sortedKeywords = fromPairs(sortBy(toPairs(keywordCandidates), (pair)=>pair[1]).reverse());\n    return sortedKeywords;\n}\nexport { buildStopWordRegex, calculateWordScores, countOccurances, rake as default, generateCandidateKeywordScores, generateCandidateKeywords, isAcceptable, loadStopWords, separateWords, splitSentences };\n"],"names":[],"mappings":"AAAA,mDAAmD;;;;;;;;;;;;;AAocnD,eAAe;AACf;AApcA,IAAI,oBAAoB,OAAO,mBAAmB;AAClD,IAAI,aAAa,CAAC,IAAI,MAAM,SAAS;QAC7B,OAAO,OAAO,CAAC,GAAG,EAAE,CAAC,kBAAkB,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,MAAM;YACnD,SAAS,CAAC;QACd,CAAC,EAAE,OAAO,EAAE,MAAM,IAAI,OAAO;IACjC;AACJ,mBAAmB;AACnB,IAAI,oBAAoB,WAAW;IAC/B,oBAAoB,OAAO,EAAE,MAAM;QAC/B;QACA,OAAO,OAAO,GAAG;YACb,WAAW;gBACP;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;aACH;QACL;IACJ;AACJ;;AAGA,MAAM,EAAE,SAAS,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,kIAAA,CAAA,UAAC;AACxC,IAAI,YAAY;AAChB,SAAS,SAAS,GAAG;IACjB,OAAO,KAAK,IAAI,CAAC;AACrB;AACA,SAAS,aAAa,MAAM,EAAE,aAAa,EAAE,cAAc;IACvD,IAAI,SAAS,eAAe;QACxB,OAAO;IACX;IACA,IAAI,QAAQ,OAAO,KAAK,CAAC;IACzB,IAAI,MAAM,MAAM,GAAG,gBAAgB;QAC/B,OAAO;IACX;IACA,IAAI,SAAS;IACb,IAAI,QAAQ;IACZ,IAAI,IAAI,IAAI,GAAG,IAAI,OAAO,MAAM,EAAE,IAAI;QAClC,IAAI,KAAK,IAAI,CAAC,MAAM,CAAC,EAAE,GAAG,UAAU;QACpC,IAAI,WAAW,IAAI,CAAC,MAAM,CAAC,EAAE,GAAG,SAAS;IAC7C;IACA,IAAI,SAAS,GAAG;QACZ,OAAO;IACX;IACA,IAAI,SAAS,OAAO;QAChB,OAAO;IACX;IACA,OAAO;AACX;AACA,SAAS,gBAAgB,QAAQ,EAAE,MAAM;IACrC,OAAO,SAAS,MAAM,CAAC,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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5206, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/indices/keyword/utils.js"],"sourcesContent":["import rake from \"../../internal/deps/rake-modified.js\";\n// Get subtokens from a list of tokens., filtering for stopwords.\nexport function expandTokensWithSubtokens(tokens) {\n    const results = new Set();\n    const regex = /\\w+/g;\n    for (const token of tokens){\n        results.add(token);\n        const subTokens = token.match(regex);\n        if (subTokens && subTokens.length > 1) {\n            for (const w of subTokens){\n                results.add(w);\n            }\n        }\n    }\n    return results;\n}\nexport function extractKeywordsGivenResponse(response, startToken = \"\", lowercase = true) {\n    const results = [];\n    response = response.trim();\n    if (response.startsWith(startToken)) {\n        response = response.substring(startToken.length);\n    }\n    const keywords = response.split(\",\");\n    for (const k of keywords){\n        let rk = k;\n        if (lowercase) {\n            rk = rk.toLowerCase();\n        }\n        results.push(rk.trim());\n    }\n    return expandTokensWithSubtokens(new Set(results));\n}\nexport function simpleExtractKeywords(textChunk, maxKeywords) {\n    const regex = /\\w+/g;\n    const tokens = [\n        ...textChunk.matchAll(regex)\n    ].map((token)=>token[0].toLowerCase().trim());\n    // Creating a frequency map\n    const valueCounts = {};\n    for (const token of tokens){\n        valueCounts[token] = (valueCounts[token] || 0) + 1;\n    }\n    // Sorting tokens by frequency\n    const sortedTokens = Object.keys(valueCounts).sort((a, b)=>valueCounts[b] - valueCounts[a]);\n    const keywords = maxKeywords ? sortedTokens.slice(0, maxKeywords) : sortedTokens;\n    return new Set(keywords);\n}\nexport function rakeExtractKeywords(textChunk, maxKeywords) {\n    const keywords = Object.keys(rake(textChunk));\n    const limitedKeywords = maxKeywords ? keywords.slice(0, maxKeywords) : keywords;\n    return new Set(limitedKeywords);\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AAEO,SAAS,0BAA0B,MAAM;IAC5C,MAAM,UAAU,IAAI;IACpB,MAAM,QAAQ;IACd,KAAK,MAAM,SAAS,OAAO;QACvB,QAAQ,GAAG,CAAC;QACZ,MAAM,YAAY,MAAM,KAAK,CAAC;QAC9B,IAAI,aAAa,UAAU,MAAM,GAAG,GAAG;YACnC,KAAK,MAAM,KAAK,UAAU;gBACtB,QAAQ,GAAG,CAAC;YAChB;QACJ;IACJ;IACA,OAAO;AACX;AACO,SAAS,6BAA6B,QAAQ,EAAE,aAAa,EAAE,EAAE,YAAY,IAAI;IACpF,MAAM,UAAU,EAAE;IAClB,WAAW,SAAS,IAAI;IACxB,IAAI,SAAS,UAAU,CAAC,aAAa;QACjC,WAAW,SAAS,SAAS,CAAC,WAAW,MAAM;IACnD;IACA,MAAM,WAAW,SAAS,KAAK,CAAC;IAChC,KAAK,MAAM,KAAK,SAAS;QACrB,IAAI,KAAK;QACT,IAAI,WAAW;YACX,KAAK,GAAG,WAAW;QACvB;QACA,QAAQ,IAAI,CAAC,GAAG,IAAI;IACxB;IACA,OAAO,0BAA0B,IAAI,IAAI;AAC7C;AACO,SAAS,sBAAsB,SAAS,EAAE,WAAW;IACxD,MAAM,QAAQ;IACd,MAAM,SAAS;WACR,UAAU,QAAQ,CAAC;KACzB,CAAC,GAAG,CAAC,CAAC,QAAQ,KAAK,CAAC,EAAE,CAAC,WAAW,GAAG,IAAI;IAC1C,2BAA2B;IAC3B,MAAM,cAAc,CAAC;IACrB,KAAK,MAAM,SAAS,OAAO;QACvB,WAAW,CAAC,MAAM,GAAG,CAAC,WAAW,CAAC,MAAM,IAAI,CAAC,IAAI;IACrD;IACA,8BAA8B;IAC9B,MAAM,eAAe,OAAO,IAAI,CAAC,aAAa,IAAI,CAAC,CAAC,GAAG,IAAI,WAAW,CAAC,EAAE,GAAG,WAAW,CAAC,EAAE;IAC1F,MAAM,WAAW,cAAc,aAAa,KAAK,CAAC,GAAG,eAAe;IACpE,OAAO,IAAI,IAAI;AACnB;AACO,SAAS,oBAAoB,SAAS,EAAE,WAAW;IACtD,MAAM,WAAW,OAAO,IAAI,CAAC,CAAA,GAAA,4KAAA,CAAA,UAAI,AAAD,EAAE;IAClC,MAAM,kBAAkB,cAAc,SAAS,KAAK,CAAC,GAAG,eAAe;IACvE,OAAO,IAAI,IAAI;AACnB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5270, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/indices/keyword/index.js"],"sourcesContent":["import { MetadataMode } from \"@llamaindex/core/schema\";\nimport { RetrieverQueryEngine } from \"../../engines/query/index.js\";\nimport { storageContextFromDefaults } from \"../../storage/StorageContext.js\";\nimport { BaseIndex } from \"../BaseIndex.js\";\nimport { extractKeywordsGivenResponse, rakeExtractKeywords, simpleExtractKeywords } from \"./utils.js\";\nimport { IndexStructType, KeywordTable } from \"@llamaindex/core/data-structs\";\nimport { defaultKeywordExtractPrompt, defaultQueryKeywordExtractPrompt } from \"@llamaindex/core/prompts\";\nimport { BaseRetriever } from \"@llamaindex/core/retriever\";\nimport { extractText } from \"@llamaindex/core/utils\";\nimport { Settings } from \"../../Settings.js\";\nimport { ContextChatEngine } from \"../../engines/chat/index.js\";\nexport var KeywordTableRetrieverMode = /*#__PURE__*/ function(KeywordTableRetrieverMode) {\n    KeywordTableRetrieverMode[\"DEFAULT\"] = \"DEFAULT\";\n    KeywordTableRetrieverMode[\"SIMPLE\"] = \"SIMPLE\";\n    KeywordTableRetrieverMode[\"RAKE\"] = \"RAKE\";\n    return KeywordTableRetrieverMode;\n}({});\n// Base Keyword Table Retriever\nclass BaseKeywordTableRetriever extends BaseRetriever {\n    index;\n    indexStruct;\n    docstore;\n    llm;\n    maxKeywordsPerQuery;\n    numChunksPerQuery;\n    keywordExtractTemplate;\n    queryKeywordExtractTemplate;\n    constructor({ index, keywordExtractTemplate, queryKeywordExtractTemplate, maxKeywordsPerQuery = 10, numChunksPerQuery = 10 }){\n        super();\n        this.index = index;\n        this.indexStruct = index.indexStruct;\n        this.docstore = index.docStore;\n        this.llm = Settings.llm;\n        this.maxKeywordsPerQuery = maxKeywordsPerQuery;\n        this.numChunksPerQuery = numChunksPerQuery;\n        this.keywordExtractTemplate = keywordExtractTemplate || defaultKeywordExtractPrompt;\n        this.queryKeywordExtractTemplate = queryKeywordExtractTemplate || defaultQueryKeywordExtractPrompt;\n    }\n    async _retrieve(query) {\n        const keywords = await this.getKeywords(extractText(query));\n        const chunkIndicesCount = {};\n        const filteredKeywords = keywords.filter((keyword)=>this.indexStruct.table.has(keyword));\n        for (const keyword of filteredKeywords){\n            for (const nodeId of this.indexStruct.table.get(keyword) || []){\n                chunkIndicesCount[nodeId] = (chunkIndicesCount[nodeId] ?? 0) + 1;\n            }\n        }\n        const sortedChunkIndices = Object.keys(chunkIndicesCount).sort((a, b)=>chunkIndicesCount[b] - chunkIndicesCount[a]).slice(0, this.numChunksPerQuery);\n        const sortedNodes = await this.docstore.getNodes(sortedChunkIndices);\n        return sortedNodes.map((node)=>({\n                node\n            }));\n    }\n}\n// Extracts keywords using LLMs.\nexport class KeywordTableLLMRetriever extends BaseKeywordTableRetriever {\n    async getKeywords(query) {\n        const response = await this.llm.complete({\n            prompt: this.queryKeywordExtractTemplate.format({\n                question: query,\n                maxKeywords: `${this.maxKeywordsPerQuery}`\n            })\n        });\n        const keywords = extractKeywordsGivenResponse(response.text, \"KEYWORDS:\");\n        return [\n            ...keywords\n        ];\n    }\n}\n// Extracts keywords using simple regex-based keyword extractor.\nexport class KeywordTableSimpleRetriever extends BaseKeywordTableRetriever {\n    getKeywords(query) {\n        return Promise.resolve([\n            ...simpleExtractKeywords(query, this.maxKeywordsPerQuery)\n        ]);\n    }\n}\n// Extracts keywords using RAKE keyword extractor\nexport class KeywordTableRAKERetriever extends BaseKeywordTableRetriever {\n    getKeywords(query) {\n        return Promise.resolve([\n            ...rakeExtractKeywords(query, this.maxKeywordsPerQuery)\n        ]);\n    }\n}\nconst KeywordTableRetrieverMap = {\n    [\"DEFAULT\"]: KeywordTableLLMRetriever,\n    [\"SIMPLE\"]: KeywordTableSimpleRetriever,\n    [\"RAKE\"]: KeywordTableRAKERetriever\n};\n/**\n * The KeywordTableIndex, an index that extracts keywords from each Node and builds a mapping from each keyword to the corresponding Nodes of that keyword.\n */ export class KeywordTableIndex extends BaseIndex {\n    constructor(init){\n        super(init);\n    }\n    static async init(options) {\n        const storageContext = options.storageContext ?? await storageContextFromDefaults({});\n        const { docStore, indexStore } = storageContext;\n        // Setup IndexStruct from storage\n        const indexStructs = await indexStore.getIndexStructs();\n        let indexStruct;\n        if (options.indexStruct && indexStructs.length > 0) {\n            throw new Error(\"Cannot initialize index with both indexStruct and indexStore\");\n        }\n        if (options.indexStruct) {\n            indexStruct = options.indexStruct;\n        } else if (indexStructs.length == 1) {\n            indexStruct = indexStructs[0];\n        } else if (indexStructs.length > 1 && options.indexId) {\n            indexStruct = await indexStore.getIndexStruct(options.indexId);\n        } else {\n            indexStruct = null;\n        }\n        // check indexStruct type\n        if (indexStruct && indexStruct.type !== IndexStructType.KEYWORD_TABLE) {\n            throw new Error(\"Attempting to initialize KeywordTableIndex with non-keyword table indexStruct\");\n        }\n        if (indexStruct) {\n            if (options.nodes) {\n                throw new Error(\"Cannot initialize KeywordTableIndex with both nodes and indexStruct\");\n            }\n        } else {\n            if (!options.nodes) {\n                throw new Error(\"Cannot initialize KeywordTableIndex without nodes or indexStruct\");\n            }\n            indexStruct = await KeywordTableIndex.buildIndexFromNodes(options.nodes, storageContext.docStore);\n            await indexStore.addIndexStruct(indexStruct);\n        }\n        return new KeywordTableIndex({\n            storageContext,\n            docStore,\n            indexStore,\n            indexStruct\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    asRetriever(options) {\n        const { mode = \"DEFAULT\", ...otherOptions } = options ?? {};\n        const KeywordTableRetriever = KeywordTableRetrieverMap[mode];\n        if (KeywordTableRetriever) {\n            return new KeywordTableRetriever({\n                index: this,\n                ...otherOptions\n            });\n        }\n        throw new Error(`Unknown retriever mode: ${mode}`);\n    }\n    asQueryEngine(options) {\n        const { retriever, responseSynthesizer } = options ?? {};\n        return new RetrieverQueryEngine(retriever ?? this.asRetriever(), responseSynthesizer, options?.nodePostprocessors);\n    }\n    asChatEngine(options) {\n        const { retriever, ...contextChatEngineOptions } = options ?? {};\n        return new ContextChatEngine({\n            retriever: retriever ?? this.asRetriever(),\n            ...contextChatEngineOptions\n        });\n    }\n    static async extractKeywords(text) {\n        const llm = Settings.llm;\n        const response = await llm.complete({\n            prompt: defaultKeywordExtractPrompt.format({\n                context: text\n            })\n        });\n        return extractKeywordsGivenResponse(response.text, \"KEYWORDS:\");\n    }\n    /**\n   * High level API: split documents, get keywords, and build index.\n   * @param documents\n   * @param args\n   * @param args.storageContext\n   * @returns\n   */ static async fromDocuments(documents, args = {}) {\n        let { storageContext } = args;\n        storageContext = storageContext ?? await storageContextFromDefaults({});\n        const docStore = storageContext.docStore;\n        await docStore.addDocuments(documents, true);\n        for (const doc of documents){\n            await docStore.setDocumentHash(doc.id_, doc.hash);\n        }\n        const nodes = await Settings.nodeParser.getNodesFromDocuments(documents);\n        const index = await KeywordTableIndex.init({\n            nodes,\n            storageContext\n        });\n        return index;\n    }\n    /**\n   * Get keywords for nodes and place them into the index.\n   * @param nodes\n   * @param docStore\n   * @returns\n   */ static async buildIndexFromNodes(nodes, docStore) {\n        const indexStruct = new KeywordTable();\n        await docStore.addDocuments(nodes, true);\n        for (const node of nodes){\n            const keywords = await KeywordTableIndex.extractKeywords(node.getContent(MetadataMode.LLM));\n            indexStruct.addNode([\n                ...keywords\n            ], node.id_);\n        }\n        return indexStruct;\n    }\n    async insertNodes(nodes) {\n        for (const node of nodes){\n            const keywords = await KeywordTableIndex.extractKeywords(node.getContent(MetadataMode.LLM));\n            this.indexStruct.addNode([\n                ...keywords\n            ], node.id_);\n        }\n    }\n    deleteNode(nodeId) {\n        const keywordsToDelete = new Set();\n        for (const [keyword, existingNodeIds] of Object.entries(this.indexStruct.table)){\n            const index = existingNodeIds.indexOf(nodeId);\n            if (index !== -1) {\n                existingNodeIds.splice(index, 1);\n                // Delete keywords that have zero nodes\n                if (existingNodeIds.length === 0) {\n                    keywordsToDelete.add(keyword);\n                }\n            }\n        }\n        this.indexStruct.deleteNode([\n            ...keywordsToDelete\n        ], nodeId);\n    }\n    async deleteNodes(nodeIds, deleteFromDocStore) {\n        nodeIds.forEach((nodeId)=>{\n            this.deleteNode(nodeId);\n        });\n        if (deleteFromDocStore) {\n            for (const nodeId of nodeIds){\n                await this.docStore.deleteDocument(nodeId, false);\n            }\n        }\n        await this.storageContext.indexStore.addIndexStruct(this.indexStruct);\n    }\n    async deleteRefDoc(refDocId, deleteFromDocStore) {\n        const refDocInfo = await this.docStore.getRefDocInfo(refDocId);\n        if (!refDocInfo) {\n            return;\n        }\n        await this.deleteNodes(refDocInfo.nodeIds, false);\n        if (deleteFromDocStore) {\n            await this.docStore.deleteRefDoc(refDocId, false);\n        }\n        return;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5543, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/indices/vectorStore/index.js"],"sourcesContent":["import { ContextChatEngine } from \"@llamaindex/core/chat-engine\";\nimport { IndexDict, IndexStructType } from \"@llamaindex/core/data-structs\";\nimport { DEFAULT_SIMILARITY_TOP_K } from \"@llamaindex/core/embeddings\";\nimport { BaseRetriever } from \"@llamaindex/core/retriever\";\nimport { ImageNode, ModalityType, ObjectType, splitNodesByType } from \"@llamaindex/core/schema\";\nimport { extractText } from \"@llamaindex/core/utils\";\nimport { VectorStoreQueryMode } from \"@llamaindex/core/vector-store\";\nimport { Settings } from \"../../Settings.js\";\nimport { RetrieverQueryEngine } from \"../../engines/query/RetrieverQueryEngine.js\";\nimport { addNodesToVectorStores, runTransformations } from \"../../ingestion/IngestionPipeline.js\";\nimport { createDocStoreStrategy, DocStoreStrategy } from \"../../ingestion/strategies/index.js\";\nimport { storageContextFromDefaults } from \"../../storage/StorageContext.js\";\nimport { BaseIndex } from \"../BaseIndex.js\";\n/**\n * The VectorStoreIndex, an index that stores the nodes only according to their vector embeddings.\n */ export class VectorStoreIndex extends BaseIndex {\n    indexStore;\n    embedModel;\n    vectorStores;\n    constructor(init){\n        super(init);\n        this.indexStore = init.indexStore;\n        this.vectorStores = init.vectorStores ?? init.storageContext.vectorStores;\n        this.embedModel = Settings.embedModel;\n    }\n    /**\n   * The async init function creates a new VectorStoreIndex.\n   * @param options\n   * @returns\n   */ static async init(options) {\n        const storageContext = options.storageContext ?? await storageContextFromDefaults({});\n        const indexStore = storageContext.indexStore;\n        const docStore = storageContext.docStore;\n        let indexStruct = await VectorStoreIndex.setupIndexStructFromStorage(indexStore, options);\n        if (!options.nodes && !indexStruct) {\n            throw new Error(\"Cannot initialize VectorStoreIndex without nodes or indexStruct\");\n        }\n        indexStruct = indexStruct ?? new IndexDict();\n        const index = new this({\n            storageContext,\n            docStore,\n            indexStruct,\n            indexStore,\n            vectorStores: options.vectorStores\n        });\n        if (options.nodes) {\n            // If nodes are passed in, then we need to update the index\n            await index.buildIndexFromNodes(options.nodes, {\n                logProgress: options.logProgress\n            });\n        }\n        return index;\n    }\n    static async setupIndexStructFromStorage(indexStore, options) {\n        const indexStructs = await indexStore.getIndexStructs();\n        let indexStruct;\n        if (options.indexStruct && indexStructs.length > 0) {\n            throw new Error(\"Cannot initialize index with both indexStruct and indexStore\");\n        }\n        if (options.indexStruct) {\n            indexStruct = options.indexStruct;\n        } else if (indexStructs.length == 1) {\n            indexStruct = indexStructs[0].type === IndexStructType.SIMPLE_DICT ? indexStructs[0] : undefined;\n            indexStruct = indexStructs[0];\n        } else if (indexStructs.length > 1 && options.indexId) {\n            indexStruct = await indexStore.getIndexStruct(options.indexId);\n        }\n        // Check indexStruct type\n        if (indexStruct && indexStruct.type !== IndexStructType.SIMPLE_DICT) {\n            throw new Error(\"Attempting to initialize VectorStoreIndex with non-vector indexStruct\");\n        }\n        return indexStruct;\n    }\n    /**\n   * Calculates the embeddings for the given nodes.\n   *\n   * @param nodes - An array of BaseNode objects representing the nodes for which embeddings are to be calculated.\n   * @param {Object} [options] - An optional object containing additional parameters.\n   *   @param {boolean} [options.logProgress] - A boolean indicating whether to log progress to the console (useful for debugging).\n   */ async getNodeEmbeddingResults(nodes, options) {\n        const nodeMap = splitNodesByType(nodes);\n        for(const type in nodeMap){\n            const nodes = nodeMap[type];\n            const embedModel = this.vectorStores[type]?.embedModel ?? this.embedModel;\n            if (embedModel && nodes) {\n                await embedModel(nodes, {\n                    logProgress: options?.logProgress\n                });\n            }\n        }\n        return nodes;\n    }\n    /**\n   * Get embeddings for nodes and place them into the index.\n   * @param nodes\n   * @returns\n   */ async buildIndexFromNodes(nodes, options) {\n        await this.insertNodes(nodes, options);\n    }\n    /**\n   * High level API: split documents, get embeddings, and build index.\n   * @param documents\n   * @param args\n   * @returns\n   */ static async fromDocuments(documents, args = {}) {\n        args.storageContext = args.storageContext ?? await storageContextFromDefaults({});\n        args.vectorStores = args.vectorStores ?? args.storageContext.vectorStores;\n        args.docStoreStrategy = args.docStoreStrategy ?? // set doc store strategy defaults to the same as for the IngestionPipeline\n        (args.vectorStores ? DocStoreStrategy.UPSERTS : DocStoreStrategy.DUPLICATES_ONLY);\n        const docStore = args.storageContext.docStore;\n        if (args.logProgress) {\n            console.log(\"Using node parser on documents...\");\n        }\n        // use doc store strategy to avoid duplicates\n        const vectorStores = Object.values(args.vectorStores ?? {});\n        const docStoreStrategy = createDocStoreStrategy(args.docStoreStrategy, docStore, vectorStores);\n        args.nodes = await runTransformations(documents, [\n            Settings.nodeParser\n        ], {}, {\n            docStoreStrategy\n        });\n        if (args.logProgress) {\n            console.log(\"Finished parsing documents.\");\n        }\n        try {\n            return await this.init(args);\n        } catch (error) {\n            await docStoreStrategy.rollback(args.storageContext.docStore, args.nodes);\n            throw error;\n        }\n    }\n    static async fromVectorStores(vectorStores) {\n        if (!vectorStores[ModalityType.TEXT]?.storesText) {\n            throw new Error(\"Cannot initialize from a vector store that does not store text\");\n        }\n        const storageContext = await storageContextFromDefaults({\n            vectorStores\n        });\n        const index = await this.init({\n            nodes: [],\n            storageContext\n        });\n        return index;\n    }\n    static async fromVectorStore(vectorStore) {\n        return this.fromVectorStores({\n            [ModalityType.TEXT]: vectorStore\n        });\n    }\n    asRetriever(options) {\n        return new VectorIndexRetriever({\n            index: this,\n            ...options\n        });\n    }\n    /**\n   * Create a RetrieverQueryEngine.\n   * similarityTopK is only used if no existing retriever is provided.\n   */ asQueryEngine(options) {\n        const { retriever, responseSynthesizer, preFilters, nodePostprocessors, similarityTopK } = options ?? {};\n        return new RetrieverQueryEngine(retriever ?? this.asRetriever({\n            similarityTopK,\n            filters: preFilters\n        }), responseSynthesizer, nodePostprocessors);\n    }\n    /**\n   * Convert the index to a chat engine.\n   * @param options The options for creating the chat engine\n   * @returns A ContextChatEngine that uses the index's retriever to get context for each query\n   */ asChatEngine(options = {}) {\n        const { retriever, similarityTopK, preFilters, ...contextChatEngineOptions } = options;\n        return new ContextChatEngine({\n            retriever: retriever ?? this.asRetriever({\n                similarityTopK,\n                filters: preFilters\n            }),\n            ...contextChatEngineOptions\n        });\n    }\n    async insertNodesToStore(newIds, nodes, vectorStore) {\n        // NOTE: if the vector store doesn't store text,\n        // we need to add the nodes to the index struct and document store\n        // NOTE: if the vector store keeps text,\n        // we only need to add image and index nodes\n        for(let i = 0; i < nodes.length; ++i){\n            const { type } = nodes[i];\n            if (!vectorStore.storesText || type === ObjectType.INDEX || type === ObjectType.IMAGE) {\n                const nodeWithoutEmbedding = nodes[i].clone();\n                nodeWithoutEmbedding.embedding = undefined;\n                this.indexStruct.addNode(nodeWithoutEmbedding, newIds[i]);\n                await this.docStore.addDocuments([\n                    nodeWithoutEmbedding\n                ], true);\n            }\n        }\n    }\n    async insertNodes(nodes, options) {\n        if (!nodes || nodes.length === 0) {\n            return;\n        }\n        nodes = await this.getNodeEmbeddingResults(nodes, options);\n        await addNodesToVectorStores(nodes, this.vectorStores, this.insertNodesToStore.bind(this));\n        await this.indexStore.addIndexStruct(this.indexStruct);\n    }\n    async deleteRefDoc(refDocId, deleteFromDocStore = true) {\n        for (const vectorStore of Object.values(this.vectorStores)){\n            await this.deleteRefDocFromStore(vectorStore, refDocId);\n        }\n        if (deleteFromDocStore) {\n            await this.docStore.deleteDocument(refDocId, false);\n        }\n    }\n    async deleteRefDocFromStore(vectorStore, refDocId) {\n        await vectorStore.delete(refDocId);\n        if (!vectorStore.storesText) {\n            const refDocInfo = await this.docStore.getRefDocInfo(refDocId);\n            if (refDocInfo) {\n                for (const nodeId of refDocInfo.nodeIds){\n                    this.indexStruct.delete(nodeId);\n                    await vectorStore.delete(nodeId);\n                }\n            }\n            await this.indexStore.addIndexStruct(this.indexStruct);\n        }\n    }\n}\nexport class VectorIndexRetriever extends BaseRetriever {\n    index;\n    topK;\n    filters;\n    queryMode;\n    constructor(options){\n        super();\n        this.index = options.index;\n        this.queryMode = options.mode ?? VectorStoreQueryMode.DEFAULT;\n        if (\"topK\" in options && options.topK) {\n            this.topK = options.topK;\n        } else {\n            this.topK = {\n                [ModalityType.TEXT]: \"similarityTopK\" in options && options.similarityTopK ? options.similarityTopK : DEFAULT_SIMILARITY_TOP_K,\n                [ModalityType.IMAGE]: DEFAULT_SIMILARITY_TOP_K\n            };\n        }\n        this.filters = options.filters;\n    }\n    /**\n   * @deprecated, pass similarityTopK or topK in constructor instead or directly modify topK\n   */ set similarityTopK(similarityTopK) {\n        this.topK[ModalityType.TEXT] = similarityTopK;\n    }\n    async _retrieve(params) {\n        const { query } = params;\n        const vectorStores = this.index.vectorStores;\n        let nodesWithScores = [];\n        for(const type in vectorStores){\n            const vectorStore = vectorStores[type];\n            nodesWithScores = nodesWithScores.concat(await this.retrieveQuery(query, type, vectorStore));\n        }\n        return nodesWithScores;\n    }\n    async retrieveQuery(query, type, vectorStore, filters) {\n        // convert string message to multi-modal format\n        let queryStr = query;\n        if (typeof query === \"string\") {\n            queryStr = query;\n            query = [\n                {\n                    type: \"text\",\n                    text: queryStr\n                }\n            ];\n        } else {\n            queryStr = extractText(query);\n        }\n        // overwrite embed model if specified, otherwise use the one from the vector store\n        const embedModel = this.index.embedModel ?? vectorStore.embedModel;\n        let nodes = [];\n        // query each content item (e.g. text or image) separately\n        for (const item of query){\n            const queryEmbedding = await embedModel.getQueryEmbedding(item);\n            if (queryEmbedding) {\n                const result = await vectorStore.query({\n                    queryStr,\n                    queryEmbedding,\n                    mode: this.queryMode ?? VectorStoreQueryMode.DEFAULT,\n                    similarityTopK: this.topK[type],\n                    filters: this.filters ?? filters ?? undefined\n                });\n                nodes = nodes.concat(this.buildNodeListFromQueryResult(result));\n            }\n        }\n        return nodes;\n    }\n    buildNodeListFromQueryResult(result) {\n        const nodesWithScores = [];\n        for(let i = 0; i < result.ids.length; i++){\n            const nodeFromResult = result.nodes?.[i];\n            if (!this.index.indexStruct.nodesDict[result.ids[i]] && nodeFromResult) {\n                this.index.indexStruct.nodesDict[result.ids[i]] = nodeFromResult;\n            }\n            const node = this.index.indexStruct.nodesDict[result.ids[i]];\n            // XXX: Hack, if it's an image node, we reconstruct the image from the URL\n            // Alternative: Store image in doc store and retrieve it here\n            if (node instanceof ImageNode) {\n                node.image = node.getUrl();\n            }\n            nodesWithScores.push({\n                node: node,\n                score: result.similarities[i]\n            });\n        }\n        return nodesWithScores;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5879, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/indices/index.js"],"sourcesContent":["export * from \"@llamaindex/core/indices\";\nexport * from \"./BaseIndex.js\";\nexport * from \"./keyword/index.js\";\nexport * from \"./summary/index.js\";\nexport * from \"./vectorStore/index.js\";\n"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5909, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/ingestion/index.js"],"sourcesContent":["export * from \"./IngestionPipeline.js\";\n"],"names":[],"mappings":";AAAA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5927, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/node-parser.js"],"sourcesContent":["export * from \"@llamaindex/core/node-parser\";\nexport * from \"@llamaindex/node-parser/code\";\nexport * from \"@llamaindex/node-parser/html\";\n"],"names":[],"mappings":";AAAA;AACA;AACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5951, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/objects/base.js"],"sourcesContent":["import { BaseObjectNodeMapping, ObjectRetriever } from \"@llamaindex/core/objects\";\nimport { TextNode } from \"@llamaindex/core/schema\";\nconst convertToolToNode = (tool)=>{\n    const nodeText = `\n    Tool name: ${tool.metadata.name}\n    Tool description: ${tool.metadata.description}\n  `;\n    return new TextNode({\n        text: nodeText,\n        metadata: {\n            name: tool.metadata.name\n        },\n        excludedEmbedMetadataKeys: [\n            \"name\"\n        ],\n        excludedLlmMetadataKeys: [\n            \"name\"\n        ]\n    });\n};\nexport class SimpleToolNodeMapping extends BaseObjectNodeMapping {\n    _tools;\n    constructor(objs = []){\n        super();\n        this._tools = {};\n        for (const tool of objs){\n            this._tools[tool.metadata.name] = tool;\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    objNodeMapping() {\n        return this._tools;\n    }\n    toNode(tool) {\n        return convertToolToNode(tool);\n    }\n    _addObj(tool) {\n        this._tools[tool.metadata.name] = tool;\n    }\n    _fromNode(node) {\n        if (!node.metadata) {\n            throw new Error(\"Metadata must be set\");\n        }\n        return this._tools[node.metadata.name];\n    }\n    persist(persistDir, objNodeMappingFilename) {\n    // Implement the persist method\n    }\n    toNodes(objs) {\n        return objs.map((obj)=>this.toNode(obj));\n    }\n    addObj(obj) {\n        this._addObj(obj);\n    }\n    fromNode(node) {\n        return this._fromNode(node);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static fromObjects(objs, ...args) {\n        return new SimpleToolNodeMapping(objs);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    fromObjects(objs, ...args) {\n        return new SimpleToolNodeMapping(objs);\n    }\n}\nexport class ObjectIndex {\n    _index;\n    _objectNodeMapping;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(index, objectNodeMapping){\n        this._index = index;\n        this._objectNodeMapping = objectNodeMapping;\n    }\n    static async fromObjects(// eslint-disable-next-line @typescript-eslint/no-explicit-any\n    objects, objectMapping, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    indexCls, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    indexKwargs) {\n        if (objectMapping === null) {\n            objectMapping = SimpleToolNodeMapping.fromObjects(objects, {});\n        }\n        const nodes = objectMapping.toNodes(objects);\n        const index = await indexCls.init({\n            nodes,\n            ...indexKwargs\n        });\n        return new ObjectIndex(index, objectMapping);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async insertObject(obj) {\n        this._objectNodeMapping.addObj(obj);\n        const node = this._objectNodeMapping.toNode(obj);\n        await this._index.insertNodes([\n            node\n        ]);\n    }\n    get tools() {\n        return this._objectNodeMapping.objNodeMapping();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async asRetriever(kwargs) {\n        return new ObjectRetriever(this._index.asRetriever(kwargs), this._objectNodeMapping);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    asNodeRetriever(kwargs) {\n        return this._index.asRetriever(kwargs);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6068, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/objects/index.js"],"sourcesContent":["export * from \"./base.js\";\n"],"names":[],"mappings":";AAAA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6086, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/postprocessors/MetadataReplacementPostProcessor.js"],"sourcesContent":["import { MetadataMode } from \"@llamaindex/core/schema\";\nexport class MetadataReplacementPostProcessor {\n    targetMetadataKey;\n    constructor(targetMetadataKey){\n        this.targetMetadataKey = targetMetadataKey;\n    }\n    async postprocessNodes(nodes) {\n        for (const n of nodes){\n            n.node.setContent(n.node.metadata[this.targetMetadataKey] ?? n.node.getContent(MetadataMode.NONE));\n        }\n        return nodes;\n    }\n}\n"],"names":[],"mappings":";;;AAAA;;AACO,MAAM;IACT,kBAAkB;IAClB,YAAY,iBAAiB,CAAC;QAC1B,IAAI,CAAC,iBAAiB,GAAG;IAC7B;IACA,MAAM,iBAAiB,KAAK,EAAE;QAC1B,KAAK,MAAM,KAAK,MAAM;YAClB,EAAE,IAAI,CAAC,UAAU,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,iKAAA,CAAA,eAAY,CAAC,IAAI;QACpG;QACA,OAAO;IACX;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6109, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/postprocessors/rerankers/JinaAIReranker.js"],"sourcesContent":["import { MetadataMode } from \"@llamaindex/core/schema\";\nimport { extractText } from \"@llamaindex/core/utils\";\nimport { getEnv } from \"@llamaindex/env\";\nexport class JinaAIReranker {\n    model = \"jina-reranker-v1-base-en\";\n    topN;\n    apiKey = undefined;\n    constructor(init){\n        this.topN = init?.topN ?? 2;\n        this.model = init?.model ?? \"jina-reranker-v1-base-en\";\n        this.apiKey = getEnv(\"JINAAI_API_KEY\");\n        if (!this.apiKey) {\n            throw new Error(\"Set Jina AI API Key in JINAAI_API_KEY env variable. Get one for free or top up your key at https://jina.ai/reranker\");\n        }\n    }\n    async rerank(query, documents, topN = this.topN) {\n        const url = \"https://api.jina.ai/v1/rerank\";\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            Authorization: `Bearer ${this.apiKey}`\n        };\n        const data = {\n            model: this.model,\n            query: query,\n            documents: documents,\n            top_n: topN\n        };\n        try {\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: headers,\n                body: JSON.stringify(data)\n            });\n            const jsonData = await response.json();\n            return jsonData.results;\n        } catch (error) {\n            console.error(\"Error while reranking:\", error);\n            throw new Error(\"Failed to rerank documents due to an API error\");\n        }\n    }\n    async postprocessNodes(nodes, query) {\n        if (nodes.length === 0) {\n            return [];\n        }\n        if (query === undefined) {\n            throw new Error(\"JinaAIReranker requires a query\");\n        }\n        const documents = nodes.map((n)=>n.node.getContent(MetadataMode.ALL));\n        const results = await this.rerank(extractText(query), documents, this.topN);\n        const newNodes = [];\n        for (const result of results){\n            const node = nodes[result.index];\n            newNodes.push({\n                node: node.node,\n                score: result.relevance_score\n            });\n        }\n        return newNodes;\n    }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AAAA;;;;AACO,MAAM;IACT,QAAQ,2BAA2B;IACnC,KAAK;IACL,SAAS,UAAU;IACnB,YAAY,IAAI,CAAC;QACb,IAAI,CAAC,IAAI,GAAG,MAAM,QAAQ;QAC1B,IAAI,CAAC,KAAK,GAAG,MAAM,SAAS;QAC5B,IAAI,CAAC,MAAM,GAAG,CAAA,GAAA,sKAAA,CAAA,SAAM,AAAD,EAAE;QACrB,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;YACd,MAAM,IAAI,MAAM;QACpB;IACJ;IACA,MAAM,OAAO,KAAK,EAAE,SAAS,EAAE,OAAO,IAAI,CAAC,IAAI,EAAE;QAC7C,MAAM,MAAM;QACZ,MAAM,UAAU;YACZ,gBAAgB;YAChB,eAAe,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,EAAE;QAC1C;QACA,MAAM,OAAO;YACT,OAAO,IAAI,CAAC,KAAK;YACjB,OAAO;YACP,WAAW;YACX,OAAO;QACX;QACA,IAAI;YACA,MAAM,WAAW,MAAM,MAAM,KAAK;gBAC9B,QAAQ;gBACR,SAAS;gBACT,MAAM,KAAK,SAAS,CAAC;YACzB;YACA,MAAM,WAAW,MAAM,SAAS,IAAI;YACpC,OAAO,SAAS,OAAO;QAC3B,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,0BAA0B;YACxC,MAAM,IAAI,MAAM;QACpB;IACJ;IACA,MAAM,iBAAiB,KAAK,EAAE,KAAK,EAAE;QACjC,IAAI,MAAM,MAAM,KAAK,GAAG;YACpB,OAAO,EAAE;QACb;QACA,IAAI,UAAU,WAAW;YACrB,MAAM,IAAI,MAAM;QACpB;QACA,MAAM,YAAY,MAAM,GAAG,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,iKAAA,CAAA,eAAY,CAAC,GAAG;QACnE,MAAM,UAAU,MAAM,IAAI,CAAC,MAAM,CAAC,CAAA,GAAA,gKAAA,CAAA,cAAW,AAAD,EAAE,QAAQ,WAAW,IAAI,CAAC,IAAI;QAC1E,MAAM,WAAW,EAAE;QACnB,KAAK,MAAM,UAAU,QAAQ;YACzB,MAAM,OAAO,KAAK,CAAC,OAAO,KAAK,CAAC;YAChC,SAAS,IAAI,CAAC;gBACV,MAAM,KAAK,IAAI;gBACf,OAAO,OAAO,eAAe;YACjC;QACJ;QACA,OAAO;IACX;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6182, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/postprocessors/rerankers/index.js"],"sourcesContent":["export * from \"./JinaAIReranker.js\";\n"],"names":[],"mappings":";AAAA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6200, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/postprocessors/SimilarityPostprocessor.js"],"sourcesContent":["export class SimilarityPostprocessor {\n    similarityCutoff;\n    constructor(options){\n        this.similarityCutoff = options?.similarityCutoff;\n    }\n    async postprocessNodes(nodes) {\n        if (this.similarityCutoff === undefined) return nodes;\n        const cutoff = this.similarityCutoff || 0;\n        return nodes.filter((node)=>node.score && node.score >= cutoff);\n    }\n}\n"],"names":[],"mappings":";;;AAAO,MAAM;IACT,iBAAiB;IACjB,YAAY,OAAO,CAAC;QAChB,IAAI,CAAC,gBAAgB,GAAG,SAAS;IACrC;IACA,MAAM,iBAAiB,KAAK,EAAE;QAC1B,IAAI,IAAI,CAAC,gBAAgB,KAAK,WAAW,OAAO;QAChD,MAAM,SAAS,IAAI,CAAC,gBAAgB,IAAI;QACxC,OAAO,MAAM,MAAM,CAAC,CAAC,OAAO,KAAK,KAAK,IAAI,KAAK,KAAK,IAAI;IAC5D;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6220, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/postprocessors/index.js"],"sourcesContent":["export * from \"./MetadataReplacementPostProcessor.js\";\nexport * from \"./rerankers/index.js\";\nexport * from \"./SimilarityPostprocessor.js\";\n"],"names":[],"mappings":";AAAA;AACA;AACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6244, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/tools/index.js"],"sourcesContent":["export * from \"@llamaindex/core/tools\";\nexport * from \"./QueryEngineTool.js\";\n"],"names":[],"mappings":";AAAA;AACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6265, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/types.js"],"sourcesContent":["/**\n * Top level types to avoid circular dependencies\n */ export { };\n"],"names":[],"mappings":"AAAA;;CAEC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6275, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/index.edge.js"],"sourcesContent":["//#region initial setup for OpenAI\nimport { OpenAI, OpenAIEmbedding } from \"@llamaindex/openai\";\nimport { Settings } from \"./Settings.js\";\ntry {\n    // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n    Settings.llm;\n    // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n    Settings.embedModel;\n} catch  {\n    Settings.llm = new OpenAI();\n    Settings.embedModel = new OpenAIEmbedding();\n}\n//#endregion\nexport { LlamaParseReader } from \"@llamaindex/cloud/reader\";\nexport * from \"@llamaindex/core/agent\";\nexport * from \"@llamaindex/core/chat-engine\";\nexport * from \"@llamaindex/core/data-structs\";\nexport * from \"@llamaindex/core/embeddings\";\nexport { CallbackManager, DEFAULT_BASE_URL, DEFAULT_CHUNK_OVERLAP, DEFAULT_CHUNK_OVERLAP_RATIO, DEFAULT_CHUNK_SIZE, DEFAULT_COLLECTION, DEFAULT_CONTEXT_WINDOW, DEFAULT_DOC_STORE_PERSIST_FILENAME, DEFAULT_GRAPH_STORE_PERSIST_FILENAME, DEFAULT_INDEX_STORE_PERSIST_FILENAME, DEFAULT_NAMESPACE, DEFAULT_NUM_OUTPUTS, DEFAULT_PADDING, DEFAULT_PERSIST_DIR, DEFAULT_PROJECT_NAME, DEFAULT_VECTOR_STORE_PERSIST_FILENAME } from \"@llamaindex/core/global\";\nexport * from \"@llamaindex/core/indices\";\nexport * from \"@llamaindex/core/llms\";\nexport * from \"@llamaindex/core/memory\";\nexport * from \"@llamaindex/core/postprocessor\";\nexport * from \"@llamaindex/core/prompts\";\nexport * from \"@llamaindex/core/query-engine\";\nexport * from \"@llamaindex/core/response-synthesizers\";\nexport * from \"@llamaindex/core/retriever\";\nexport * from \"@llamaindex/core/schema\";\nexport * from \"@llamaindex/core/storage/chat-store\";\nexport * from \"@llamaindex/core/storage/doc-store\";\nexport * from \"@llamaindex/core/storage/index-store\";\nexport * from \"@llamaindex/core/storage/kv-store\";\nexport * from \"@llamaindex/core/utils\";\nexport * from \"@llamaindex/openai\";\nexport * from \"@llamaindex/workflow\";\nexport * from \"@llamaindex/workflow/agent\";\nexport * from \"./agent/index.js\";\nexport * from \"./cloud/index.js\";\nexport * from \"./engines/chat/index.js\";\nexport * from \"./engines/query/index.js\";\nexport * from \"./evaluation/index.js\";\nexport * from \"./extractors/index.js\";\nexport * from \"./indices/index.js\";\nexport * from \"./ingestion/index.js\";\nexport { imageToDataUrl } from \"./internal/utils.js\";\nexport * from \"./node-parser.js\";\nexport * from \"./objects/index.js\";\nexport * from \"./OutputParser.js\";\nexport * from \"./postprocessors/index.js\";\nexport * from \"./QuestionGenerator.js\";\nexport * from \"./selectors/index.js\";\nexport * from \"./storage/StorageContext.js\";\nexport * from \"./tools/index.js\";\nexport * from \"./types.js\";\nexport { Settings };\n"],"names":[],"mappings":"AAAA,kCAAkC;;AAClC;AACA;AAUA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAlDA,IAAI;IACA,oEAAoE;IACpE,gJAAA,CAAA,WAAQ,CAAC,GAAG;IACZ,oEAAoE;IACpE,gJAAA,CAAA,WAAQ,CAAC,UAAU;AACvB,EAAE,OAAO;IACL,gJAAA,CAAA,WAAQ,CAAC,GAAG,GAAG,IAAI,yJAAA,CAAA,SAAM;IACzB,gJAAA,CAAA,WAAQ,CAAC,UAAU,GAAG,IAAI,yJAAA,CAAA,kBAAe;AAC7C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6429, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/node_modules/llamaindex/dist/index.react-server.js"],"sourcesContent":["export * from \"./index.edge.js\";\n"],"names":[],"mappings":";AAAA","ignoreList":[0],"debugId":null}}]
}
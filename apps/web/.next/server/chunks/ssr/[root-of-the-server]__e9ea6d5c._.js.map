{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/contexts/namespace-context.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const NamespaceProvider = registerClientReference(\n    function() { throw new Error(\"Attempted to call NamespaceProvider() from the server but NamespaceProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/apps/web/src/contexts/namespace-context.tsx <module evaluation>\",\n    \"NamespaceProvider\",\n);\nexport const useNamespace = registerClientReference(\n    function() { throw new Error(\"Attempted to call useNamespace() from the server but useNamespace is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/apps/web/src/contexts/namespace-context.tsx <module evaluation>\",\n    \"useNamespace\",\n);\n"],"names":[],"mappings":";;;;AAAA;;AACO,MAAM,oBAAoB,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACnD;IAAa,MAAM,IAAI,MAAM;AAAkP,GAC/Q,6EACA;AAEG,MAAM,eAAe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EAC9C;IAAa,MAAM,IAAI,MAAM;AAAwO,GACrQ,6EACA","debugId":null}},
    {"offset": {"line": 25, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/contexts/namespace-context.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const NamespaceProvider = registerClientReference(\n    function() { throw new Error(\"Attempted to call NamespaceProvider() from the server but NamespaceProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/apps/web/src/contexts/namespace-context.tsx\",\n    \"NamespaceProvider\",\n);\nexport const useNamespace = registerClientReference(\n    function() { throw new Error(\"Attempted to call useNamespace() from the server but useNamespace is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/apps/web/src/contexts/namespace-context.tsx\",\n    \"useNamespace\",\n);\n"],"names":[],"mappings":";;;;AAAA;;AACO,MAAM,oBAAoB,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACnD;IAAa,MAAM,IAAI,MAAM;AAAkP,GAC/Q,yDACA;AAEG,MAAM,eAAe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EAC9C;IAAa,MAAM,IAAI,MAAM;AAAwO,GACrQ,yDACA","debugId":null}},
    {"offset": {"line": 43, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 53, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/server/api/auth.ts"],"sourcesContent":["import { headers } from \"next/headers\";\nimport { cache } from \"react\";\nimport { auth } from \"@/lib/auth\";\nimport type { ProtectedProcedureContext } from \"./trpc\";\n\nexport const getServerAuthSession = cache(async (headersObj?: Headers) =>\n  auth.api.getSession({\n    headers: headersObj ?? (await headers()),\n  }),\n);\n\nexport const getNamespaceByUser = cache(\n  async (\n    ctx: ProtectedProcedureContext,\n    idOrSlug:\n      | {\n          id: string;\n        }\n      | {\n          slug: string;\n        },\n  ) => {\n    return await ctx.db.namespace.findFirst({\n      where: {\n        ...(\"id\" in idOrSlug ? { id: idOrSlug.id } : { slug: idOrSlug.slug }),\n        organization: {\n          members: { some: { userId: ctx.session.user.id } },\n        },\n      },\n    });\n  },\n);\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAGO,MAAM,uBAAuB,CAAA,GAAA,qMAAA,CAAA,QAAK,AAAD,EAAE,OAAO,aAC/C,iIAAA,CAAA,OAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QAClB,SAAS,cAAe,MAAM,CAAA,GAAA,+HAAA,CAAA,UAAO,AAAD;IACtC;AAGK,MAAM,qBAAqB,CAAA,GAAA,qMAAA,CAAA,QAAK,AAAD,EACpC,OACE,KACA;IAQA,OAAO,MAAM,IAAI,EAAE,CAAC,SAAS,CAAC,SAAS,CAAC;QACtC,OAAO;YACL,GAAI,QAAQ,WAAW;gBAAE,IAAI,SAAS,EAAE;YAAC,IAAI;gBAAE,MAAM,SAAS,IAAI;YAAC,CAAC;YACpE,cAAc;gBACZ,SAAS;oBAAE,MAAM;wBAAE,QAAQ,IAAI,OAAO,CAAC,IAAI,CAAC,EAAE;oBAAC;gBAAE;YACnD;QACF;IACF;AACF","debugId":null}},
    {"offset": {"line": 90, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/server/api/trpc.ts"],"sourcesContent":["/**\r\n * YOU PROBABLY DON'T NEED TO EDIT THIS FILE, UNLESS:\r\n * 1. You want to modify request context (see Part 1).\r\n * 2. You want to create a new middleware or type of procedure (see Part 3).\r\n *\r\n * TL;DR - This is where all the tRPC server stuff is created and plugged in. The pieces you will\r\n * need to use are documented accordingly near the end.\r\n */\r\nimport { initTRPC, TRPCError } from \"@trpc/server\";\r\nimport superjson from \"superjson\";\r\nimport { ZodError } from \"zod\";\r\n\r\nimport { db } from \"@agentset/db\";\r\n\r\nimport { getServerAuthSession } from \"./auth\";\r\n\r\n/**\r\n * 1. CONTEXT\r\n *\r\n * This section defines the \"contexts\" that are available in the backend API.\r\n *\r\n * These allow you to access things when processing a request, like the database, the session, etc.\r\n *\r\n * This helper generates the \"internals\" for a tRPC context. The API handler and RSC clients each\r\n * wrap this and provides the required context.\r\n *\r\n * @see https://trpc.io/docs/server/context\r\n */\r\nexport const createTRPCContext = async (opts: { headers: Headers }) => {\r\n  const session = await getServerAuthSession(opts.headers);\r\n\r\n  return {\r\n    db,\r\n    session,\r\n    ...opts,\r\n  };\r\n};\r\n\r\n/**\r\n * 2. INITIALIZATION\r\n *\r\n * This is where the tRPC API is initialized, connecting the context and transformer. We also parse\r\n * ZodErrors so that you get typesafety on the frontend if your procedure fails due to validation\r\n * errors on the backend.\r\n */\r\nconst t = initTRPC.context<typeof createTRPCContext>().create({\r\n  transformer: superjson,\r\n  errorFormatter({ shape, error }) {\r\n    return {\r\n      ...shape,\r\n      data: {\r\n        ...shape.data,\r\n        zodError:\r\n          error.cause instanceof ZodError ? error.cause.flatten() : null,\r\n      },\r\n    };\r\n  },\r\n});\r\n\r\n/**\r\n * Create a server-side caller.\r\n *\r\n * @see https://trpc.io/docs/server/server-side-calls\r\n */\r\nexport const createCallerFactory = t.createCallerFactory;\r\n\r\n/**\r\n * 3. ROUTER & PROCEDURE (THE IMPORTANT BIT)\r\n *\r\n * These are the pieces you use to build your tRPC API. You should import these a lot in the\r\n * \"/src/server/api/routers\" directory.\r\n */\r\n\r\n/**\r\n * This is how you create new routers and sub-routers in your tRPC API.\r\n *\r\n * @see https://trpc.io/docs/router\r\n */\r\nexport const createTRPCRouter = t.router;\r\n\r\n/**\r\n * Middleware for timing procedure execution and adding an artificial delay in development.\r\n *\r\n * You can remove this if you don't like it, but it can help catch unwanted waterfalls by simulating\r\n * network latency that would occur in production but not in local development.\r\n */\r\nconst timingMiddleware = t.middleware(async ({ next, path }) => {\r\n  const start = Date.now();\r\n\r\n  if (t._config.isDev) {\r\n    // artificial delay in dev\r\n    const waitMs = Math.floor(Math.random() * 400) + 100;\r\n    await new Promise((resolve) => setTimeout(resolve, waitMs));\r\n  }\r\n\r\n  const result = await next();\r\n\r\n  const end = Date.now();\r\n  console.log(`[TRPC] ${path} took ${end - start}ms to execute`);\r\n\r\n  return result;\r\n});\r\n\r\n/**\r\n * Public (unauthenticated) procedure\r\n *\r\n * This is the base piece you use to build new queries and mutations on your tRPC API. It does not\r\n * guarantee that a user querying is authorized, but you can still access user session data if they\r\n * are logged in.\r\n */\r\nexport const publicProcedure = t.procedure.use(timingMiddleware);\r\n\r\n/**\r\n * Protected (authenticated) procedure\r\n *\r\n * If you want a query or mutation to ONLY be accessible to logged in users, use this. It verifies\r\n * the session is valid and guarantees `ctx.session.user` is not null.\r\n *\r\n * @see https://trpc.io/docs/procedures\r\n */\r\nexport const protectedProcedure = t.procedure.use(({ ctx, next }) => {\r\n  if (!ctx.session) {\r\n    throw new TRPCError({ code: \"UNAUTHORIZED\" });\r\n  }\r\n\r\n  return next({\r\n    ctx: {\r\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\r\n      session: ctx.session as NonNullable<typeof ctx.session>,\r\n    },\r\n  });\r\n});\r\n\r\nexport type ProcedureContext = Awaited<ReturnType<typeof createTRPCContext>>;\r\n\r\nexport type ProtectedProcedureContext = ProcedureContext & {\r\n  session: NonNullable<ProcedureContext[\"session\"]>;\r\n};\r\n"],"names":[],"mappings":"AAAA;;;;;;;CAOC;;;;;;;AACD;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AAEA;;;;;;AAcO,MAAM,oBAAoB,OAAO;IACtC,MAAM,UAAU,MAAM,CAAA,GAAA,2IAAA,CAAA,uBAAoB,AAAD,EAAE,KAAK,OAAO;IAEvD,OAAO;QACL,IAAA,+HAAA,CAAA,KAAE;QACF;QACA,GAAG,IAAI;IACT;AACF;AAEA;;;;;;CAMC,GACD,MAAM,IAAI,gMAAA,CAAA,WAAQ,CAAC,OAAO,GAA6B,MAAM,CAAC;IAC5D,aAAa,0IAAA,CAAA,UAAS;IACtB,gBAAe,EAAE,KAAK,EAAE,KAAK,EAAE;QAC7B,OAAO;YACL,GAAG,KAAK;YACR,MAAM;gBACJ,GAAG,MAAM,IAAI;gBACb,UACE,MAAM,KAAK,YAAY,oIAAA,CAAA,WAAQ,GAAG,MAAM,KAAK,CAAC,OAAO,KAAK;YAC9D;QACF;IACF;AACF;AAOO,MAAM,sBAAsB,EAAE,mBAAmB;AAcjD,MAAM,mBAAmB,EAAE,MAAM;AAExC;;;;;CAKC,GACD,MAAM,mBAAmB,EAAE,UAAU,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE;IACzD,MAAM,QAAQ,KAAK,GAAG;IAEtB,IAAI,EAAE,OAAO,CAAC,KAAK,EAAE;QACnB,0BAA0B;QAC1B,MAAM,SAAS,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,OAAO;QACjD,MAAM,IAAI,QAAQ,CAAC,UAAY,WAAW,SAAS;IACrD;IAEA,MAAM,SAAS,MAAM;IAErB,MAAM,MAAM,KAAK,GAAG;IACpB,QAAQ,GAAG,CAAC,CAAC,OAAO,EAAE,KAAK,MAAM,EAAE,MAAM,MAAM,aAAa,CAAC;IAE7D,OAAO;AACT;AASO,MAAM,kBAAkB,EAAE,SAAS,CAAC,GAAG,CAAC;AAUxC,MAAM,qBAAqB,EAAE,SAAS,CAAC,GAAG,CAAC,CAAC,EAAE,GAAG,EAAE,IAAI,EAAE;IAC9D,IAAI,CAAC,IAAI,OAAO,EAAE;QAChB,MAAM,IAAI,0MAAA,CAAA,YAAS,CAAC;YAAE,MAAM;QAAe;IAC7C;IAEA,OAAO,KAAK;QACV,KAAK;YACH,4EAA4E;YAC5E,SAAS,IAAI,OAAO;QACtB;IACF;AACF","debugId":null}},
    {"offset": {"line": 182, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/server/api/routers/api-keys.ts"],"sourcesContent":["import { createTRPCRouter, protectedProcedure } from \"@/server/api/trpc\";\r\nimport { TRPCError } from \"@trpc/server\";\r\nimport { z } from \"zod\";\r\n\r\nconst keyGenerator = (prefix?: string, length = 16) => {\r\n  const characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\r\n  let apiKey = `${prefix || \"\"}`;\r\n  for (let i = 0; i < length; i++) {\r\n    const randomIndex = Math.floor(Math.random() * characters.length);\r\n    apiKey += characters[randomIndex];\r\n  }\r\n\r\n  return apiKey;\r\n};\r\n\r\nexport const apiKeysRouter = createTRPCRouter({\r\n  getApiKeys: protectedProcedure\r\n    .input(\r\n      z.object({\r\n        orgId: z.string(),\r\n      }),\r\n    )\r\n    .query(async ({ ctx, input }) => {\r\n      // make sure the user is a member of the org\r\n      const member = await ctx.db.member.findFirst({\r\n        where: {\r\n          userId: ctx.session.user.id,\r\n          organizationId: input.orgId,\r\n        },\r\n        select: {\r\n          id: true,\r\n          role: true,\r\n        },\r\n      });\r\n\r\n      if (!member || (member.role !== \"admin\" && member.role !== \"owner\")) {\r\n        throw new TRPCError({ code: \"UNAUTHORIZED\" });\r\n      }\r\n\r\n      const apiKeys = await ctx.db.organizationApiKey.findMany({\r\n        where: {\r\n          organizationId: input.orgId,\r\n        },\r\n        omit: {\r\n          key: true,\r\n        },\r\n      });\r\n\r\n      return apiKeys;\r\n    }),\r\n  createApiKey: protectedProcedure\r\n    .input(\r\n      z.object({\r\n        orgId: z.string(),\r\n        label: z.string(),\r\n        scope: z.enum([\"all\"]),\r\n      }),\r\n    )\r\n    .mutation(async ({ ctx, input }) => {\r\n      const member = await ctx.db.member.findFirst({\r\n        where: {\r\n          userId: ctx.session.user.id,\r\n          organizationId: input.orgId,\r\n        },\r\n      });\r\n\r\n      if (!member || (member.role !== \"admin\" && member.role !== \"owner\")) {\r\n        throw new TRPCError({ code: \"UNAUTHORIZED\" });\r\n      }\r\n\r\n      const apiKey = await ctx.db.organizationApiKey.create({\r\n        data: {\r\n          label: input.label,\r\n          scope: input.scope,\r\n          organizationId: input.orgId,\r\n          key: keyGenerator(\"agentset_\"),\r\n        },\r\n      });\r\n\r\n      return apiKey;\r\n    }),\r\n  deleteApiKey: protectedProcedure\r\n    .input(z.object({ orgId: z.string(), id: z.string() }))\r\n    .mutation(async ({ ctx, input }) => {\r\n      const member = await ctx.db.member.findFirst({\r\n        where: {\r\n          userId: ctx.session.user.id,\r\n          organizationId: input.orgId,\r\n        },\r\n      });\r\n\r\n      if (!member || (member.role !== \"admin\" && member.role !== \"owner\")) {\r\n        throw new TRPCError({ code: \"UNAUTHORIZED\" });\r\n      }\r\n\r\n      await ctx.db.organizationApiKey.delete({\r\n        where: {\r\n          id: input.id,\r\n        },\r\n      });\r\n\r\n      return { success: true };\r\n    }),\r\n});\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 290, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/plans.ts"],"sourcesContent":["import { env } from \"@/env\";\r\n\r\nimport type { Prisma } from \"@agentset/db\";\r\n\r\nimport { INFINITY_NUMBER } from \"./constants\";\r\n\r\nexport type PlanFeature = {\r\n  id?: string;\r\n  text: string;\r\n  disabled?: boolean;\r\n  tooltip?: {\r\n    title: string;\r\n    cta: string;\r\n    href: string;\r\n  };\r\n};\r\n\r\nexport const PLANS = [\r\n  {\r\n    name: \"Free\",\r\n    description: \"For personal use and small projects.\",\r\n    price: {\r\n      monthly: 0,\r\n      yearly: 0,\r\n    },\r\n    limits: {\r\n      pages: 1000,\r\n      retrievals: 10_000,\r\n      api: 60,\r\n      // namespaces: 3,\r\n      // users: 1,\r\n    },\r\n    features: [\r\n      { id: \"pages\", text: \"1,000 pages included\" },\r\n      { id: \"retrievals\", text: \"10,000 retrievals /month\" },\r\n      { id: \"api\", text: \"60 API calls /min\" },\r\n      { id: \"support\", text: \"Basic support\" },\r\n      {\r\n        id: \"additional_pages\",\r\n        text: \"$0.01 per additional page\",\r\n        disabled: true,\r\n      },\r\n      { id: \"connector\", text: \"$100 per connector\", disabled: true },\r\n      // { id: \"users\", text: \"1 user\" },\r\n      // { id: \"namespaces\", text: \"3 namespaces\" },\r\n    ] satisfies PlanFeature[],\r\n  },\r\n  {\r\n    name: \"Pro\",\r\n    description: \"For production applications ready to scale.\",\r\n    price: {\r\n      monthly: 49,\r\n      yearly: 490,\r\n      ids: [\r\n        \"price_1RE26ODPtsw7PNYQduDp19Gx\", // yearly\r\n        \"price_1RE26ODPtsw7PNYQlDfyMYjV\", // monthly\r\n\r\n        \"price_1RE25PDPtsw7PNYQXPwhPIAt\", // yearly (test)\r\n        \"price_1RE25PDPtsw7PNYQQjlEQbPf\", // monthly (test)\r\n      ],\r\n    },\r\n    limits: {\r\n      pages: 10_000,\r\n      retrievals: INFINITY_NUMBER,\r\n      api: 600,\r\n      // users: 10,\r\n      // namespaces: 10,\r\n    },\r\n    featureTitle: \"Everything in Free, plus:\",\r\n    features: [\r\n      { id: \"pages\", text: \"10,000 pages included\" },\r\n      { id: \"retrievals\", text: \"Unlimited retrievals\" },\r\n      { id: \"additional_pages\", text: \"$0.01 per additional page\" },\r\n      { id: \"connector\", text: \"$100 per connector\" },\r\n      { id: \"api\", text: \"600 API calls /min\" },\r\n      { id: \"support\", text: \"Email support\" },\r\n      // { id: \"users\", text: \"10 users\" },\r\n      // { id: \"namespaces\", text: \"10 namespaces\" },\r\n    ] satisfies PlanFeature[],\r\n  },\r\n];\r\n\r\nexport const ENTERPRISE_PLAN = {\r\n  name: \"Enterprise\",\r\n  description: \"For organizations with custom workflows.\",\r\n  price: \"Custom\",\r\n  features: [\r\n    { id: \"pages\", text: \"Unlimited pages\" },\r\n    { id: \"retrievals\", text: \"Unlimited retrievals\" },\r\n    { id: \"connector\", text: \"Custom connector pricing\" },\r\n    { id: \"integrations\", text: \"Custom integrations\" },\r\n    { id: \"api\", text: \"Custom API rate limit\" },\r\n    { id: \"support\", text: \"Dedicated account manager\" },\r\n    // { id: \"users\", text: \"1 user\" },\r\n    // { id: \"namespaces\", text: \"3 namespaces\" },\r\n  ] satisfies PlanFeature[],\r\n};\r\n\r\nexport const PRO_PLAN_METERED = {\r\n  lookupKey: \"pro_plan_metered\",\r\n  meterName: \"ingested_pages\",\r\n  priceId: {\r\n    test: \"price_1RapvfDPtsw7PNYQvLZvqIpc\",\r\n    live: \"price_1RaqhNDPtsw7PNYQ9lqtoORc\",\r\n  },\r\n};\r\n\r\nexport const getStripeEnvironment = () => {\r\n  if (env.NODE_ENV === \"production\") return \"live\";\r\n  return \"test\";\r\n};\r\n\r\nexport const FREE_PLAN = PLANS.find((plan) => plan.name === \"Free\")!;\r\nexport const PRO_PLAN = PLANS.find((plan) => plan.name === \"Pro\")!;\r\n\r\nexport const SELF_SERVE_PAID_PLANS = PLANS.filter((p) =>\r\n  [\"Pro\"].includes(p.name),\r\n);\r\n\r\nexport const FREE_ORGANIZATIONS_LIMIT = 2;\r\n\r\nexport const getPlanFromPriceId = (priceId?: string) => {\r\n  if (!priceId) return null;\r\n  return PLANS.find((plan) => plan.price.ids?.includes(priceId)) || null;\r\n};\r\n\r\nexport const getPlanDetails = (plan: string) => {\r\n  return SELF_SERVE_PAID_PLANS.find(\r\n    (p) => p.name.toLowerCase() === plan.toLowerCase(),\r\n  )!;\r\n};\r\n\r\nexport const getCurrentPlan = (plan: string) => {\r\n  return (\r\n    PLANS.find((p) => p.name.toLowerCase() === plan.toLowerCase()) || FREE_PLAN\r\n  );\r\n};\r\n\r\nexport const getNextPlan = (plan?: string | null) => {\r\n  if (!plan) return PRO_PLAN;\r\n  return PLANS[\r\n    PLANS.findIndex((p) => p.name.toLowerCase() === plan.toLowerCase()) + 1\r\n  ];\r\n};\r\n\r\nexport const isDowngradePlan = (currentPlan: string, newPlan: string) => {\r\n  const currentPlanIndex = PLANS.findIndex(\r\n    (p) => p.name.toLowerCase() === currentPlan.toLowerCase(),\r\n  );\r\n  const newPlanIndex = PLANS.findIndex(\r\n    (p) => p.name.toLowerCase() === newPlan.toLowerCase(),\r\n  );\r\n  return currentPlanIndex > newPlanIndex;\r\n};\r\n\r\nexport const planToOrganizationFields = (plan: (typeof PLANS)[number]) => {\r\n  return {\r\n    plan: plan.name.toLowerCase(),\r\n    pagesLimit: plan.limits.pages,\r\n    searchLimit: plan.limits.retrievals,\r\n    apiRatelimit: plan.limits.api,\r\n    // TODO: add other limits\r\n  } satisfies Prisma.OrganizationUpdateInput;\r\n};\r\n\r\nexport const isProPlan = (plan: string) => {\r\n  return plan.toLowerCase() === \"pro\";\r\n};\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 533, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/stripe/index.ts"],"sourcesContent":["import { env } from \"@/env\";\r\nimport Stripe from \"stripe\";\r\n\r\n// You don't need an API Key here, because the app uses the\r\n// dashboard credentials to make requests.\r\nexport const stripe = new Stripe(env.STRIPE_API_KEY, {\r\n  // @ts-expect-error - Stripe only has the type of the latest version\r\n  apiVersion: \"2024-06-20\",\r\n  appInfo: {\r\n    name: \"Agentset.ai\",\r\n    version: \"0.1.0\",\r\n  },\r\n});\r\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAIO,MAAM,SAAS,IAAI,sJAAA,CAAA,UAAM,CAAC,yHAAA,CAAA,MAAG,CAAC,cAAc,EAAE;IACnD,oEAAoE;IACpE,YAAY;IACZ,SAAS;QACP,MAAM;QACN,SAAS;IACX;AACF","debugId":null}},
    {"offset": {"line": 554, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/server/api/routers/billing.ts"],"sourcesContent":["import { getStripeEnvironment, isProPlan, PRO_PLAN_METERED } from \"@/lib/plans\";\r\nimport { stripe } from \"@/lib/stripe\";\r\nimport { getBaseUrl } from \"@/lib/utils\";\r\nimport { TRPCError } from \"@trpc/server\";\r\nimport { z } from \"zod\";\r\n\r\nimport { createTRPCRouter, protectedProcedure } from \"../trpc\";\r\n\r\nconst organizationMiddleware = protectedProcedure\r\n  .input(\r\n    z.object({\r\n      orgId: z.string(),\r\n    }),\r\n  )\r\n  .use(async ({ ctx, next, input }) => {\r\n    const organization = await ctx.db.organization.findUnique({\r\n      where: {\r\n        id: input.orgId,\r\n        members: { some: { userId: ctx.session.user.id } },\r\n      },\r\n      select: {\r\n        id: true,\r\n        slug: true,\r\n        stripeId: true,\r\n      },\r\n    });\r\n\r\n    if (!organization) {\r\n      throw new TRPCError({\r\n        code: \"NOT_FOUND\",\r\n        message: \"Organization not found\",\r\n      });\r\n    }\r\n\r\n    return next({\r\n      ctx: {\r\n        ...ctx,\r\n        organization,\r\n      },\r\n    });\r\n  });\r\n\r\nexport const billingRouter = createTRPCRouter({\r\n  getCurrentPlan: organizationMiddleware.query(async ({ ctx }) => {\r\n    const org = await ctx.db.organization.findUnique({\r\n      where: {\r\n        id: ctx.organization.id,\r\n      },\r\n      select: {\r\n        plan: true,\r\n        pagesLimit: true,\r\n        totalPages: true,\r\n        totalDocuments: true,\r\n        totalIngestJobs: true,\r\n        totalNamespaces: true,\r\n        billingCycleStart: true,\r\n        stripeId: true,\r\n      },\r\n    });\r\n\r\n    return org!;\r\n  }),\r\n  upgrade: organizationMiddleware\r\n    .input(\r\n      z.object({\r\n        plan: z.enum([\"free\", \"pro\"]),\r\n        period: z.enum([\"monthly\", \"yearly\"]),\r\n        baseUrl: z.string(),\r\n      }),\r\n    )\r\n    .mutation(async ({ ctx, input }) => {\r\n      const { plan, period, baseUrl } = input;\r\n\r\n      const planKey = plan.replace(\" \", \"+\");\r\n      const prices = await stripe.prices.list({\r\n        lookup_keys: [`${planKey}_${period}`],\r\n      });\r\n      const priceId = prices.data[0]!.id;\r\n\r\n      const activeSubscription = ctx.organization.stripeId\r\n        ? await stripe.subscriptions\r\n            .list({\r\n              customer: ctx.organization.stripeId,\r\n              status: \"active\",\r\n            })\r\n            .then((res) => res.data[0])\r\n        : null;\r\n\r\n      // if the user has an active subscription, create billing portal to upgrade\r\n      if (ctx.organization.stripeId && activeSubscription) {\r\n        const { url } = await stripe.billingPortal.sessions.create({\r\n          customer: ctx.organization.stripeId,\r\n          return_url: baseUrl,\r\n          flow_data: {\r\n            type: \"subscription_update\",\r\n            subscription_update: {\r\n              subscription: activeSubscription.id,\r\n            },\r\n          },\r\n        });\r\n\r\n        return { url };\r\n      } else {\r\n        // For both new users and users with canceled subscriptions\r\n        const stripeSession = await stripe.checkout.sessions.create({\r\n          ...(ctx.organization.stripeId\r\n            ? {\r\n                customer: ctx.organization.stripeId,\r\n                // need to pass this or Stripe will throw an error: https://git.new/kX4fi6B\r\n                customer_update: {\r\n                  name: \"auto\",\r\n                  address: \"auto\",\r\n                },\r\n              }\r\n            : {\r\n                customer_email: ctx.session.user.email,\r\n              }),\r\n          billing_address_collection: \"required\",\r\n          success_url: `${getBaseUrl()}/${ctx.organization.slug}?upgraded=true&plan=${planKey}&period=${period}`,\r\n          cancel_url: baseUrl,\r\n          line_items: [\r\n            { price: priceId, quantity: 1 },\r\n            ...(isProPlan(plan)\r\n              ? [\r\n                  {\r\n                    price: PRO_PLAN_METERED.priceId[getStripeEnvironment()],\r\n                  },\r\n                ]\r\n              : []),\r\n          ],\r\n          allow_promotion_codes: true,\r\n          automatic_tax: {\r\n            enabled: true,\r\n          },\r\n          tax_id_collection: {\r\n            enabled: true,\r\n          },\r\n          mode: \"subscription\",\r\n          client_reference_id: ctx.organization.id,\r\n          metadata: {\r\n            agentsetCustomerId: ctx.session.user.id,\r\n          },\r\n        });\r\n\r\n        return { sessionId: stripeSession.id };\r\n      }\r\n    }),\r\n  invoices: organizationMiddleware.query(async ({ ctx }) => {\r\n    if (!ctx.organization.stripeId) {\r\n      return [];\r\n    }\r\n\r\n    try {\r\n      const invoices = await stripe.invoices.list({\r\n        customer: ctx.organization.stripeId,\r\n      });\r\n\r\n      return invoices.data.map((invoice) => {\r\n        return {\r\n          id: invoice.id,\r\n          total: invoice.amount_paid,\r\n          createdAt: new Date(invoice.created * 1000),\r\n          description: \"Agentset subscription\",\r\n          pdfUrl: invoice.invoice_pdf,\r\n        };\r\n      });\r\n    } catch (error) {\r\n      console.log(error);\r\n      return [];\r\n    }\r\n  }),\r\n  manage: organizationMiddleware.mutation(async ({ ctx }) => {\r\n    if (!ctx.organization.stripeId) {\r\n      throw new TRPCError({\r\n        code: \"BAD_REQUEST\",\r\n        message: \"No Stripe customer ID\",\r\n      });\r\n    }\r\n\r\n    try {\r\n      const { url } = await stripe.billingPortal.sessions.create({\r\n        customer: ctx.organization.stripeId,\r\n        return_url: `${getBaseUrl()}/${ctx.organization.slug}/billing`,\r\n      });\r\n      return url;\r\n    } catch (error: any) {\r\n      throw new TRPCError({\r\n        code: \"BAD_REQUEST\",\r\n        message: error?.raw?.message,\r\n      });\r\n    }\r\n  }),\r\n  getPaymentMethods: organizationMiddleware.query(async ({ ctx }) => {\r\n    if (!ctx.organization.stripeId) {\r\n      throw new TRPCError({\r\n        code: \"BAD_REQUEST\",\r\n        message: \"No Stripe customer ID\",\r\n      });\r\n    }\r\n\r\n    try {\r\n      const paymentMethods = await stripe.paymentMethods.list({\r\n        customer: ctx.organization.stripeId,\r\n      });\r\n\r\n      // reorder to put ACH first\r\n      const ach = paymentMethods.data.find(\r\n        (method) => method.type === \"us_bank_account\",\r\n      );\r\n\r\n      return [\r\n        ...(ach ? [ach] : []),\r\n        ...paymentMethods.data.filter((method) => method.id !== ach?.id),\r\n      ];\r\n    } catch (error) {\r\n      console.error(error);\r\n      return [];\r\n    }\r\n  }),\r\n  addPaymentMethod: organizationMiddleware\r\n    .input(\r\n      z.object({\r\n        method: z.enum([\"card\", \"us_bank_account\"]).optional(),\r\n      }),\r\n    )\r\n    .mutation(async ({ ctx, input }) => {\r\n      if (!ctx.organization.stripeId) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"No Stripe customer ID\",\r\n        });\r\n      }\r\n\r\n      if (!input.method) {\r\n        const { url } = await stripe.billingPortal.sessions.create({\r\n          customer: ctx.organization.stripeId,\r\n          return_url: `${getBaseUrl()}/${ctx.organization.slug}/billing`,\r\n          flow_data: {\r\n            type: \"payment_method_update\",\r\n          },\r\n        });\r\n\r\n        return url;\r\n      }\r\n\r\n      const { url } = await stripe.checkout.sessions.create({\r\n        mode: \"setup\",\r\n        customer: ctx.organization.stripeId,\r\n        payment_method_types: [input.method],\r\n        success_url: `${getBaseUrl()}/${ctx.organization.slug}/billing`,\r\n        cancel_url: `${getBaseUrl()}/${ctx.organization.slug}/billing`,\r\n      });\r\n\r\n      return url;\r\n    }),\r\n  cancel: organizationMiddleware.mutation(async ({ ctx }) => {\r\n    if (!ctx.organization.stripeId) {\r\n      throw new TRPCError({\r\n        code: \"BAD_REQUEST\",\r\n        message: \"No Stripe customer ID\",\r\n      });\r\n    }\r\n\r\n    try {\r\n      const activeSubscription = await stripe.subscriptions\r\n        .list({\r\n          customer: ctx.organization.stripeId,\r\n          status: \"active\",\r\n        })\r\n        .then((res) => res.data[0]);\r\n\r\n      if (!activeSubscription)\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"No active subscription\",\r\n        });\r\n\r\n      const { url } = await stripe.billingPortal.sessions.create({\r\n        customer: ctx.organization.stripeId,\r\n        return_url: `${getBaseUrl()}/${ctx.organization.slug}/billing`,\r\n        flow_data: {\r\n          type: \"subscription_cancel\",\r\n          subscription_cancel: {\r\n            subscription: activeSubscription.id,\r\n          },\r\n        },\r\n      });\r\n      return url;\r\n    } catch (error: any) {\r\n      throw new TRPCError({\r\n        code: \"BAD_REQUEST\",\r\n        message: error.raw.message,\r\n      });\r\n    }\r\n  }),\r\n});\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 843, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/zod/index.ts"],"sourcesContent":["import * as z from \"zod\";\r\nimport { extendZodWithOpenApi } from \"zod-openapi\";\r\n\r\nextendZodWithOpenApi(z);\r\n\r\nexport default z;\r\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAEA,CAAA,GAAA,6JAAA,CAAA,uBAAoB,AAAD,EAAE;uCAEN","debugId":null}},
    {"offset": {"line": 858, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/packages/validation/src/zod.ts"],"sourcesContent":["import * as z from \"zod\";\r\nimport { extendZodWithOpenApi } from \"zod-openapi\";\r\n\r\nextendZodWithOpenApi(z);\r\n\r\nexport default z;\r\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAEA,CAAA,GAAA,6JAAA,CAAA,uBAAoB,AAAD,EAAE;uCAEN","debugId":null}},
    {"offset": {"line": 873, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/packages/validation/src/embedding-model/openai.ts"],"sourcesContent":["import z from \"../zod\";\r\n\r\nexport const openaiEmbeddingModelEnum = z.enum([\r\n  \"text-embedding-3-small\",\r\n  \"text-embedding-3-large\",\r\n]);\r\n\r\nexport const OpenAIEmbeddingConfigSchema = z\r\n  .object({\r\n    provider: z.literal(\"OPENAI\"),\r\n    model: openaiEmbeddingModelEnum,\r\n    apiKey: z.string(),\r\n  })\r\n  .openapi({\r\n    title: \"OpenAI Embedding Config\",\r\n  });\r\n"],"names":[],"mappings":";;;;AAAA;;AAEO,MAAM,2BAA2B,oIAAA,CAAA,UAAC,CAAC,IAAI,CAAC;IAC7C;IACA;CACD;AAEM,MAAM,8BAA8B,oIAAA,CAAA,UAAC,CACzC,MAAM,CAAC;IACN,UAAU,oIAAA,CAAA,UAAC,CAAC,OAAO,CAAC;IACpB,OAAO;IACP,QAAQ,oIAAA,CAAA,UAAC,CAAC,MAAM;AAClB,GACC,OAAO,CAAC;IACP,OAAO;AACT","debugId":null}},
    {"offset": {"line": 896, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/packages/validation/src/embedding-model/azure.ts"],"sourcesContent":["import z from \"../zod\";\r\nimport { openaiEmbeddingModelEnum } from \"./openai\";\r\n\r\nexport const AzureEmbeddingConfigSchema = z\r\n  .object({\r\n    provider: z.literal(\"AZURE_OPENAI\"),\r\n    model: openaiEmbeddingModelEnum,\r\n    baseUrl: z\r\n      .string()\r\n      .url()\r\n      .describe(\"The base URL of the Azure OpenAI API.\")\r\n      .openapi({\r\n        example: `https://example.openai.azure.com/openai/deployments`,\r\n      }),\r\n    deployment: z\r\n      .string()\r\n      .describe(\"The deployment name of the Azure OpenAI API.\"),\r\n    apiKey: z.string().describe(\"The API key for the Azure OpenAI API.\"),\r\n    apiVersion: z\r\n      .string()\r\n      .optional()\r\n      .describe(\"The API version for the Azure OpenAI API.\"),\r\n  })\r\n  .openapi({\r\n    title: \"Azure Embedding Config\",\r\n  });\r\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAEO,MAAM,6BAA6B,oIAAA,CAAA,UAAC,CACxC,MAAM,CAAC;IACN,UAAU,oIAAA,CAAA,UAAC,CAAC,OAAO,CAAC;IACpB,OAAO,6JAAA,CAAA,2BAAwB;IAC/B,SAAS,oIAAA,CAAA,UAAC,CACP,MAAM,GACN,GAAG,GACH,QAAQ,CAAC,yCACT,OAAO,CAAC;QACP,SAAS,CAAC,mDAAmD,CAAC;IAChE;IACF,YAAY,oIAAA,CAAA,UAAC,CACV,MAAM,GACN,QAAQ,CAAC;IACZ,QAAQ,oIAAA,CAAA,UAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC5B,YAAY,oIAAA,CAAA,UAAC,CACV,MAAM,GACN,QAAQ,GACR,QAAQ,CAAC;AACd,GACC,OAAO,CAAC;IACP,OAAO;AACT","debugId":null}},
    {"offset": {"line": 921, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/packages/validation/src/embedding-model/google.ts"],"sourcesContent":["import z from \"../zod\";\r\n\r\nexport const googleEmbeddingModelEnum = z.enum([\"text-embedding-004\"]);\r\n\r\nexport const GoogleEmbeddingConfigSchema = z\r\n  .object({\r\n    provider: z.literal(\"GOOGLE\"),\r\n    model: googleEmbeddingModelEnum,\r\n    apiKey: z.string(),\r\n  })\r\n  .openapi({\r\n    title: \"Google Embedding Config\",\r\n  });\r\n"],"names":[],"mappings":";;;;AAAA;;AAEO,MAAM,2BAA2B,oIAAA,CAAA,UAAC,CAAC,IAAI,CAAC;IAAC;CAAqB;AAE9D,MAAM,8BAA8B,oIAAA,CAAA,UAAC,CACzC,MAAM,CAAC;IACN,UAAU,oIAAA,CAAA,UAAC,CAAC,OAAO,CAAC;IACpB,OAAO;IACP,QAAQ,oIAAA,CAAA,UAAC,CAAC,MAAM;AAClB,GACC,OAAO,CAAC;IACP,OAAO;AACT","debugId":null}},
    {"offset": {"line": 943, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/packages/validation/src/embedding-model/voyage.ts"],"sourcesContent":["import z from \"../zod\";\r\n\r\nexport const voyageEmbeddingModelEnum = z.enum([\r\n  \"voyage-3-large\",\r\n  \"voyage-3\",\r\n  \"voyage-3-lite\",\r\n  \"voyage-code-3\",\r\n  \"voyage-finance-2\",\r\n  \"voyage-law-2\",\r\n]);\r\n\r\nexport const VoyageEmbeddingConfigSchema = z\r\n  .object({\r\n    provider: z.literal(\"VOYAGE\"),\r\n    model: voyageEmbeddingModelEnum,\r\n    apiKey: z.string(),\r\n  })\r\n  .openapi({\r\n    title: \"Voyage Embedding Config\",\r\n  });\r\n"],"names":[],"mappings":";;;;AAAA;;AAEO,MAAM,2BAA2B,oIAAA,CAAA,UAAC,CAAC,IAAI,CAAC;IAC7C;IACA;IACA;IACA;IACA;IACA;CACD;AAEM,MAAM,8BAA8B,oIAAA,CAAA,UAAC,CACzC,MAAM,CAAC;IACN,UAAU,oIAAA,CAAA,UAAC,CAAC,OAAO,CAAC;IACpB,OAAO;IACP,QAAQ,oIAAA,CAAA,UAAC,CAAC,MAAM;AAClB,GACC,OAAO,CAAC;IACP,OAAO;AACT","debugId":null}},
    {"offset": {"line": 970, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/packages/validation/src/embedding-model/index.ts"],"sourcesContent":["import z from \"../zod\";\r\nimport { AzureEmbeddingConfigSchema } from \"./azure\";\r\nimport { GoogleEmbeddingConfigSchema } from \"./google\";\r\nimport { OpenAIEmbeddingConfigSchema } from \"./openai\";\r\nimport { VoyageEmbeddingConfigSchema } from \"./voyage\";\r\n\r\nexport const EmbeddingConfigSchema = z\r\n  .discriminatedUnion(\"provider\", [\r\n    OpenAIEmbeddingConfigSchema,\r\n    AzureEmbeddingConfigSchema,\r\n    VoyageEmbeddingConfigSchema,\r\n    GoogleEmbeddingConfigSchema,\r\n  ])\r\n  .describe(\r\n    \"The embedding model config. If not provided, our managed embedding model will be used. Note: You can't change the embedding model config after the namespace is created.\",\r\n  );\r\n\r\nexport type EmbeddingConfig = z.infer<typeof EmbeddingConfigSchema>;\r\n\r\nexport { AzureEmbeddingConfigSchema } from \"./azure\";\r\nexport { GoogleEmbeddingConfigSchema } from \"./google\";\r\nexport { OpenAIEmbeddingConfigSchema } from \"./openai\";\r\nexport { VoyageEmbeddingConfigSchema } from \"./voyage\";\r\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEO,MAAM,wBAAwB,oIAAA,CAAA,UAAC,CACnC,kBAAkB,CAAC,YAAY;IAC9B,6JAAA,CAAA,8BAA2B;IAC3B,4JAAA,CAAA,6BAA0B;IAC1B,6JAAA,CAAA,8BAA2B;IAC3B,6JAAA,CAAA,8BAA2B;CAC5B,EACA,QAAQ,CACP","debugId":null}},
    {"offset": {"line": 1012, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/packages/validation/src/vector-store/pinecone.ts"],"sourcesContent":["import z from \"../zod\";\r\n\r\nexport const PineconeVectorStoreConfigSchema = z\r\n  .object({\r\n    provider: z.literal(\"PINECONE\"),\r\n    apiKey: z.string().describe(\"The API key for the Pinecone index.\"),\r\n    indexHost: z\r\n      .string()\r\n      .url()\r\n      .describe(\"The host of the Pinecone index.\")\r\n      .openapi({\r\n        example: `https://example.svc.aped-1234-a56b.pinecone.io`,\r\n      }),\r\n  })\r\n  .openapi({\r\n    title: \"Pinecone Config\",\r\n  });\r\n"],"names":[],"mappings":";;;AAAA;;AAEO,MAAM,kCAAkC,oIAAA,CAAA,UAAC,CAC7C,MAAM,CAAC;IACN,UAAU,oIAAA,CAAA,UAAC,CAAC,OAAO,CAAC;IACpB,QAAQ,oIAAA,CAAA,UAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC5B,WAAW,oIAAA,CAAA,UAAC,CACT,MAAM,GACN,GAAG,GACH,QAAQ,CAAC,mCACT,OAAO,CAAC;QACP,SAAS,CAAC,8CAA8C,CAAC;IAC3D;AACJ,GACC,OAAO,CAAC;IACP,OAAO;AACT","debugId":null}},
    {"offset": {"line": 1032, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/packages/validation/src/vector-store/index.ts"],"sourcesContent":["import z from \"../zod\";\r\nimport { PineconeVectorStoreConfigSchema } from \"./pinecone\";\r\n\r\nexport const VectorStoreSchema = z\r\n  .discriminatedUnion(\"provider\", [PineconeVectorStoreConfigSchema])\r\n  .describe(\r\n    \"The vector store config. If not provided, our managed vector store will be used. Note: You can't change the vector store config after the namespace is created.\",\r\n  );\r\n\r\nexport type VectorStoreConfig = z.infer<typeof VectorStoreSchema>;\r\n\r\nexport { PineconeVectorStoreConfigSchema } from \"./pinecone\";\r\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAEO,MAAM,oBAAoB,oIAAA,CAAA,UAAC,CAC/B,kBAAkB,CAAC,YAAY;IAAC,4JAAA,CAAA,kCAA+B;CAAC,EAChE,QAAQ,CACP","debugId":null}},
    {"offset": {"line": 1059, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/packages/validation/src/ingest-payload/index.ts"],"sourcesContent":["import z from \"../zod\";\r\n\r\nconst nameSchema = z\r\n  .string()\r\n  .nullable()\r\n  .optional()\r\n  .describe(\"The name of the ingest job.\");\r\n\r\nconst fileNameSchema = z\r\n  .string()\r\n  .nullable()\r\n  .optional()\r\n  .describe(\"The name of the file.\");\r\n\r\nexport const textPayloadSchema = z\r\n  .object({\r\n    type: z.literal(\"TEXT\"),\r\n    text: z.string().describe(\"The text to ingest.\"),\r\n    name: nameSchema,\r\n  })\r\n  .openapi({\r\n    title: \"Text Payload\",\r\n  });\r\n\r\nexport const filePayloadSchema = z\r\n  .object({\r\n    type: z.literal(\"FILE\"),\r\n    fileUrl: z.string().describe(\"The URL of the file to ingest.\"),\r\n    name: nameSchema,\r\n  })\r\n  .openapi({\r\n    title: \"URL Payload\",\r\n  });\r\n\r\nexport const managedFilePayloadSchema = z\r\n  .object({\r\n    type: z.literal(\"MANAGED_FILE\"),\r\n    key: z.string().describe(\"The key of the managed file to ingest.\"),\r\n    name: nameSchema,\r\n  })\r\n  .openapi({\r\n    title: \"Managed File Payload\",\r\n  });\r\n\r\nexport const managedFilesPayloadSchema = z\r\n  .object({\r\n    type: z.literal(\"MANAGED_FILES\"),\r\n    files: z.array(\r\n      z.object({\r\n        key: z.string().describe(\"The key of the managed file to ingest.\"),\r\n        name: fileNameSchema,\r\n      }),\r\n    ),\r\n    name: nameSchema,\r\n  })\r\n  .openapi({\r\n    title: \"Managed Files Payload\",\r\n  });\r\n\r\nexport const urlsPayloadSchema = z\r\n  .object({\r\n    type: z.literal(\"URLS\"),\r\n    urls: z.array(z.string().url()).describe(\"The URLs to ingest.\"),\r\n    name: nameSchema,\r\n  })\r\n  .openapi({\r\n    title: \"URLs Payload\",\r\n  });\r\n\r\nexport const ingestJobPayloadSchema = z\r\n  .discriminatedUnion(\"type\", [\r\n    textPayloadSchema,\r\n    filePayloadSchema,\r\n    managedFilePayloadSchema,\r\n    managedFilesPayloadSchema,\r\n    urlsPayloadSchema,\r\n  ])\r\n  .describe(\"The ingest job payload.\");\r\n\r\nexport type IngestJobPayload = z.infer<typeof ingestJobPayloadSchema>;\r\n\r\n// type IngestJobPayloadConnection = {\r\n//   type: \"CONNECTION\";\r\n//   connectionId: string;\r\n// };\r\n\r\n// type IngestJobPayloadS3 = {\r\n//   type: \"S3\";\r\n//   bucket: string;\r\n//   prefix?: string;\r\n//   fileTypes?: string[];\r\n// };\r\n\r\n// type IngestJobPayloadGoogleDrive = {\r\n//   type: \"GOOGLE_DRIVE\";\r\n//   folderId: string;\r\n//   fileTypes?: string[];\r\n// };\r\n\r\nexport const configSchema = z\r\n  .object({\r\n    chunkSize: z.number().optional().describe(\"Custom chunk size.\"),\r\n    chunkOverlap: z.number().optional().describe(\"Custom chunk overlap.\"),\r\n    metadata: z\r\n      .record(z.string(), z.unknown())\r\n      .optional()\r\n      .describe(\"Custom metadata to be added to the ingested documents.\"),\r\n    chunkingStrategy: z\r\n      .enum([\"basic\", \"by_title\"])\r\n      .optional()\r\n      .describe(\"The chunking strategy to use. Defaults to `basic`.\"),\r\n    strategy: z\r\n      .enum([\"auto\", \"fast\", \"hi_res\", \"ocr_only\"])\r\n      .optional()\r\n      .describe(\"The strategy to use. Defaults to `auto`.\"),\r\n    // languages: z.array(z.string()).optional().describe(\"The languages to use.\"),\r\n  })\r\n  .describe(\"The ingest job config.\");\r\n\r\nexport type IngestJobConfig = z.infer<typeof configSchema>;\r\n"],"names":[],"mappings":";;;;;;;;;AAAA;;AAEA,MAAM,aAAa,oIAAA,CAAA,UAAC,CACjB,MAAM,GACN,QAAQ,GACR,QAAQ,GACR,QAAQ,CAAC;AAEZ,MAAM,iBAAiB,oIAAA,CAAA,UAAC,CACrB,MAAM,GACN,QAAQ,GACR,QAAQ,GACR,QAAQ,CAAC;AAEL,MAAM,oBAAoB,oIAAA,CAAA,UAAC,CAC/B,MAAM,CAAC;IACN,MAAM,oIAAA,CAAA,UAAC,CAAC,OAAO,CAAC;IAChB,MAAM,oIAAA,CAAA,UAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC1B,MAAM;AACR,GACC,OAAO,CAAC;IACP,OAAO;AACT;AAEK,MAAM,oBAAoB,oIAAA,CAAA,UAAC,CAC/B,MAAM,CAAC;IACN,MAAM,oIAAA,CAAA,UAAC,CAAC,OAAO,CAAC;IAChB,SAAS,oIAAA,CAAA,UAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC7B,MAAM;AACR,GACC,OAAO,CAAC;IACP,OAAO;AACT;AAEK,MAAM,2BAA2B,oIAAA,CAAA,UAAC,CACtC,MAAM,CAAC;IACN,MAAM,oIAAA,CAAA,UAAC,CAAC,OAAO,CAAC;IAChB,KAAK,oIAAA,CAAA,UAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACzB,MAAM;AACR,GACC,OAAO,CAAC;IACP,OAAO;AACT;AAEK,MAAM,4BAA4B,oIAAA,CAAA,UAAC,CACvC,MAAM,CAAC;IACN,MAAM,oIAAA,CAAA,UAAC,CAAC,OAAO,CAAC;IAChB,OAAO,oIAAA,CAAA,UAAC,CAAC,KAAK,CACZ,oIAAA,CAAA,UAAC,CAAC,MAAM,CAAC;QACP,KAAK,oIAAA,CAAA,UAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;QACzB,MAAM;IACR;IAEF,MAAM;AACR,GACC,OAAO,CAAC;IACP,OAAO;AACT;AAEK,MAAM,oBAAoB,oIAAA,CAAA,UAAC,CAC/B,MAAM,CAAC;IACN,MAAM,oIAAA,CAAA,UAAC,CAAC,OAAO,CAAC;IAChB,MAAM,oIAAA,CAAA,UAAC,CAAC,KAAK,CAAC,oIAAA,CAAA,UAAC,CAAC,MAAM,GAAG,GAAG,IAAI,QAAQ,CAAC;IACzC,MAAM;AACR,GACC,OAAO,CAAC;IACP,OAAO;AACT;AAEK,MAAM,yBAAyB,oIAAA,CAAA,UAAC,CACpC,kBAAkB,CAAC,QAAQ;IAC1B;IACA;IACA;IACA;IACA;CACD,EACA,QAAQ,CAAC;AAsBL,MAAM,eAAe,oIAAA,CAAA,UAAC,CAC1B,MAAM,CAAC;IACN,WAAW,oIAAA,CAAA,UAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;IAC1C,cAAc,oIAAA,CAAA,UAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;IAC7C,UAAU,oIAAA,CAAA,UAAC,CACR,MAAM,CAAC,oIAAA,CAAA,UAAC,CAAC,MAAM,IAAI,oIAAA,CAAA,UAAC,CAAC,OAAO,IAC5B,QAAQ,GACR,QAAQ,CAAC;IACZ,kBAAkB,oIAAA,CAAA,UAAC,CAChB,IAAI,CAAC;QAAC;QAAS;KAAW,EAC1B,QAAQ,GACR,QAAQ,CAAC;IACZ,UAAU,oIAAA,CAAA,UAAC,CACR,IAAI,CAAC;QAAC;QAAQ;QAAQ;QAAU;KAAW,EAC3C,QAAQ,GACR,QAAQ,CAAC;AAEd,GACC,QAAQ,CAAC","debugId":null}},
    {"offset": {"line": 1138, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/packages/validation/src/document-payload/index.ts"],"sourcesContent":["import {\r\n  filePayloadSchema,\r\n  managedFilePayloadSchema,\r\n  textPayloadSchema,\r\n} from \"../ingest-payload\";\r\nimport z from \"../zod\";\r\n\r\n// remove name from the payload since it's a separate field\r\nexport const documentPayloadSchema = z\r\n  .discriminatedUnion(\"type\", [\r\n    textPayloadSchema.omit({ name: true }),\r\n    filePayloadSchema.omit({ name: true }),\r\n    managedFilePayloadSchema.omit({ name: true }),\r\n  ])\r\n  .describe(\"The source of the document.\");\r\n\r\nexport type DocumentPayload = z.infer<typeof documentPayloadSchema>;\r\n\r\nexport const documentPropertiesSchema = z\r\n  .object({\r\n    fileSize: z.number().describe(\"The size of the file in bytes.\"),\r\n    mimeType: z\r\n      .string()\r\n      .nullable()\r\n      .default(null)\r\n      .describe(\"The MIME type of the file.\"),\r\n  })\r\n  .describe(\"The properties of the document.\");\r\n\r\nexport type DocumentProperties = z.infer<typeof documentPropertiesSchema>;\r\n"],"names":[],"mappings":";;;;AAAA;AAKA;;;AAGO,MAAM,wBAAwB,oIAAA,CAAA,UAAC,CACnC,kBAAkB,CAAC,QAAQ;IAC1B,2JAAA,CAAA,oBAAiB,CAAC,IAAI,CAAC;QAAE,MAAM;IAAK;IACpC,2JAAA,CAAA,oBAAiB,CAAC,IAAI,CAAC;QAAE,MAAM;IAAK;IACpC,2JAAA,CAAA,2BAAwB,CAAC,IAAI,CAAC;QAAE,MAAM;IAAK;CAC5C,EACA,QAAQ,CAAC;AAIL,MAAM,2BAA2B,oIAAA,CAAA,UAAC,CACtC,MAAM,CAAC;IACN,UAAU,oIAAA,CAAA,UAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC9B,UAAU,oIAAA,CAAA,UAAC,CACR,MAAM,GACN,QAAQ,GACR,OAAO,CAAC,MACR,QAAQ,CAAC;AACd,GACC,QAAQ,CAAC","debugId":null}},
    {"offset": {"line": 1167, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/packages/validation/src/index.ts"],"sourcesContent":["export * from \"./embedding-model\";\r\nexport * from \"./vector-store\";\r\nexport * from \"./ingest-payload\";\r\nexport * from \"./document-payload\";\r\n"],"names":[],"mappings":";AAAA;AACA;AACA;AACA","debugId":null}},
    {"offset": {"line": 1194, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/schemas/api/pagination.ts"],"sourcesContent":["import z from \"@/lib/zod\";\r\n\r\nexport const paginationSchema = z.object({\r\n  cursor: z.string().optional().describe(\"The cursor to paginate by.\"),\r\n  cursorDirection: z\r\n    .enum([\"forward\", \"backward\"])\r\n    .default(\"forward\")\r\n    .describe(\"The direction to paginate by.\"),\r\n  perPage: z.coerce\r\n    .number()\r\n    .min(1)\r\n    .max(100)\r\n    .optional()\r\n    .default(30)\r\n    .describe(\"The number of records to return per page.\"),\r\n});\r\n\r\nexport const paginationResponseSchema = <T>(recordSchema: z.ZodSchema<T>) =>\r\n  z.object({\r\n    records: z.array(recordSchema).describe(\"The records to return.\"),\r\n    nextCursor: z\r\n      .string()\r\n      .nullable()\r\n      .describe(\"The next cursor to paginate by.\"),\r\n  });\r\n"],"names":[],"mappings":";;;;AAAA;;AAEO,MAAM,mBAAmB,yIAAA,CAAA,UAAC,CAAC,MAAM,CAAC;IACvC,QAAQ,yIAAA,CAAA,UAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;IACvC,iBAAiB,yIAAA,CAAA,UAAC,CACf,IAAI,CAAC;QAAC;QAAW;KAAW,EAC5B,OAAO,CAAC,WACR,QAAQ,CAAC;IACZ,SAAS,yIAAA,CAAA,UAAC,CAAC,MAAM,CACd,MAAM,GACN,GAAG,CAAC,GACJ,GAAG,CAAC,KACJ,QAAQ,GACR,OAAO,CAAC,IACR,QAAQ,CAAC;AACd;AAEO,MAAM,2BAA2B,CAAI,eAC1C,yIAAA,CAAA,UAAC,CAAC,MAAM,CAAC;QACP,SAAS,yIAAA,CAAA,UAAC,CAAC,KAAK,CAAC,cAAc,QAAQ,CAAC;QACxC,YAAY,yIAAA,CAAA,UAAC,CACV,MAAM,GACN,QAAQ,GACR,QAAQ,CAAC;IACd","debugId":null}},
    {"offset": {"line": 1218, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/schemas/api/document.ts"],"sourcesContent":["import z from \"@/lib/zod\";\r\n\r\nimport { DocumentStatus } from \"@agentset/db\";\r\nimport {\r\n  documentPayloadSchema,\r\n  documentPropertiesSchema,\r\n} from \"@agentset/validation\";\r\n\r\nimport { paginationSchema } from \"./pagination\";\r\n\r\nconst nameSchema = z\r\n  .string()\r\n  .nullable()\r\n  .default(null)\r\n  .describe(\"The name of the document.\");\r\n\r\nexport const DocumentStatusSchema = z\r\n  .nativeEnum(DocumentStatus)\r\n  .describe(\"The status of the document.\");\r\n\r\nexport const DocumentSchema = z\r\n  .object({\r\n    id: z.string().describe(\"The unique ID of the document.\"),\r\n    ingestJobId: z.string().describe(\"The ingest job ID of the document.\"),\r\n    externalId: z\r\n      .string()\r\n      .nullable()\r\n      .default(null)\r\n      .describe(\"A unique external ID.\"),\r\n    name: nameSchema,\r\n    tenantId: z\r\n      .string()\r\n      .nullable()\r\n      .default(null)\r\n      .describe(\"The tenant ID of the ingest job.\"),\r\n    status: DocumentStatusSchema,\r\n    error: z\r\n      .string()\r\n      .nullable()\r\n      .default(null)\r\n      .describe(\r\n        \"The error message of the document. Only exists when the status is failed.\",\r\n      ),\r\n    source: documentPayloadSchema,\r\n    properties: documentPropertiesSchema.nullable().default(null),\r\n    totalChunks: z.number().describe(\"The total number of chunks.\"),\r\n    totalTokens: z.number().describe(\"The total number of tokens.\"),\r\n    totalCharacters: z.number().describe(\"The total number of characters.\"),\r\n    totalPages: z\r\n      .number()\r\n      .describe(\r\n        \"The total number of pages. Will be 0 if the document is not paged (e.g. PDF).\",\r\n      ),\r\n    createdAt: z.date().describe(\"The date and time the document was created.\"),\r\n    queuedAt: z\r\n      .date()\r\n      .nullable()\r\n      .describe(\"The date and time the document was queued.\")\r\n      .default(null),\r\n    preProcessingAt: z\r\n      .date()\r\n      .nullable()\r\n      .describe(\"The date and time the document was pre-processed.\")\r\n      .default(null),\r\n    processingAt: z\r\n      .date()\r\n      .nullable()\r\n      .describe(\"The date and time the document was processed.\")\r\n      .default(null),\r\n    completedAt: z\r\n      .date()\r\n      .nullable()\r\n      .describe(\"The date and time the document was completed.\")\r\n      .default(null),\r\n    failedAt: z\r\n      .date()\r\n      .nullable()\r\n      .describe(\"The date and time the document failed.\")\r\n      .default(null),\r\n  })\r\n  .openapi({\r\n    title: \"Document\",\r\n  });\r\n\r\nexport const DocumentsQuerySchema = z.object({\r\n  statuses: z\r\n    .array(DocumentStatusSchema)\r\n    .optional()\r\n    .describe(\"Statuses to filter by.\"),\r\n  orderBy: z\r\n    .enum([\"createdAt\"])\r\n    .optional()\r\n    .default(\"createdAt\")\r\n    .describe(\"The field to order by. Default is `createdAt`.\"),\r\n  order: z\r\n    .enum([\"asc\", \"desc\"])\r\n    .optional()\r\n    .default(\"desc\")\r\n    .describe(\"The order to sort by. Default is `desc`.\"),\r\n  ingestJobId: z\r\n    .string()\r\n    .optional()\r\n    .describe(\"The ingest job ID to filter documents by.\"),\r\n});\r\n\r\nexport const getDocumentsSchema = DocumentsQuerySchema.merge(paginationSchema);\r\n"],"names":[],"mappings":";;;;;;AAAA;AAEA;AAAA;AACA;AAAA;AAKA;;;;;AAEA,MAAM,aAAa,yIAAA,CAAA,UAAC,CACjB,MAAM,GACN,QAAQ,GACR,OAAO,CAAC,MACR,QAAQ,CAAC;AAEL,MAAM,uBAAuB,yIAAA,CAAA,UAAC,CAClC,UAAU,CAAC,6HAAA,CAAA,iBAAc,EACzB,QAAQ,CAAC;AAEL,MAAM,iBAAiB,yIAAA,CAAA,UAAC,CAC5B,MAAM,CAAC;IACN,IAAI,yIAAA,CAAA,UAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACxB,aAAa,yIAAA,CAAA,UAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACjC,YAAY,yIAAA,CAAA,UAAC,CACV,MAAM,GACN,QAAQ,GACR,OAAO,CAAC,MACR,QAAQ,CAAC;IACZ,MAAM;IACN,UAAU,yIAAA,CAAA,UAAC,CACR,MAAM,GACN,QAAQ,GACR,OAAO,CAAC,MACR,QAAQ,CAAC;IACZ,QAAQ;IACR,OAAO,yIAAA,CAAA,UAAC,CACL,MAAM,GACN,QAAQ,GACR,OAAO,CAAC,MACR,QAAQ,CACP;IAEJ,QAAQ,6JAAA,CAAA,wBAAqB;IAC7B,YAAY,6JAAA,CAAA,2BAAwB,CAAC,QAAQ,GAAG,OAAO,CAAC;IACxD,aAAa,yIAAA,CAAA,UAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACjC,aAAa,yIAAA,CAAA,UAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACjC,iBAAiB,yIAAA,CAAA,UAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACrC,YAAY,yIAAA,CAAA,UAAC,CACV,MAAM,GACN,QAAQ,CACP;IAEJ,WAAW,yIAAA,CAAA,UAAC,CAAC,IAAI,GAAG,QAAQ,CAAC;IAC7B,UAAU,yIAAA,CAAA,UAAC,CACR,IAAI,GACJ,QAAQ,GACR,QAAQ,CAAC,8CACT,OAAO,CAAC;IACX,iBAAiB,yIAAA,CAAA,UAAC,CACf,IAAI,GACJ,QAAQ,GACR,QAAQ,CAAC,qDACT,OAAO,CAAC;IACX,cAAc,yIAAA,CAAA,UAAC,CACZ,IAAI,GACJ,QAAQ,GACR,QAAQ,CAAC,iDACT,OAAO,CAAC;IACX,aAAa,yIAAA,CAAA,UAAC,CACX,IAAI,GACJ,QAAQ,GACR,QAAQ,CAAC,iDACT,OAAO,CAAC;IACX,UAAU,yIAAA,CAAA,UAAC,CACR,IAAI,GACJ,QAAQ,GACR,QAAQ,CAAC,0CACT,OAAO,CAAC;AACb,GACC,OAAO,CAAC;IACP,OAAO;AACT;AAEK,MAAM,uBAAuB,yIAAA,CAAA,UAAC,CAAC,MAAM,CAAC;IAC3C,UAAU,yIAAA,CAAA,UAAC,CACR,KAAK,CAAC,sBACN,QAAQ,GACR,QAAQ,CAAC;IACZ,SAAS,yIAAA,CAAA,UAAC,CACP,IAAI,CAAC;QAAC;KAAY,EAClB,QAAQ,GACR,OAAO,CAAC,aACR,QAAQ,CAAC;IACZ,OAAO,yIAAA,CAAA,UAAC,CACL,IAAI,CAAC;QAAC;QAAO;KAAO,EACpB,QAAQ,GACR,OAAO,CAAC,QACR,QAAQ,CAAC;IACZ,aAAa,yIAAA,CAAA,UAAC,CACX,MAAM,GACN,QAAQ,GACR,QAAQ,CAAC;AACd;AAEO,MAAM,qBAAqB,qBAAqB,KAAK,CAAC,kJAAA,CAAA,mBAAgB","debugId":null}},
    {"offset": {"line": 1277, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/workflow.ts"],"sourcesContent":["import { env } from \"@/env\";\r\nimport { Client as QstashClient, Receiver } from \"@upstash/qstash\";\r\nimport { Client as WorkflowClient } from \"@upstash/workflow\";\r\n\r\nimport { getBaseUrl } from \"./utils\";\r\n\r\nexport const qstashClient = new QstashClient({\r\n  baseUrl: env.QSTASH_URL,\r\n  token: env.QSTASH_TOKEN,\r\n});\r\n\r\nconst workflowClient = new WorkflowClient({\r\n  baseUrl: env.QSTASH_URL,\r\n  token: env.QSTASH_TOKEN,\r\n});\r\n\r\nexport const qstashReceiver = new Receiver({\r\n  currentSigningKey: env.QSTASH_CURRENT_SIGNING_KEY,\r\n  nextSigningKey: env.QSTASH_NEXT_SIGNING_KEY,\r\n});\r\n\r\nexport type TriggerIngestionJobBody = {\r\n  jobId: string;\r\n};\r\nexport const triggerIngestionJob = async (body: TriggerIngestionJobBody) => {\r\n  return workflowClient.trigger({\r\n    url: `${getBaseUrl()}/api/workflows/ingest`,\r\n    body,\r\n  });\r\n};\r\n\r\nexport type TriggerDocumentJobBody = {\r\n  documentId: string;\r\n  cleanup?: boolean;\r\n};\r\nexport const triggerDocumentJob = async (body: TriggerDocumentJobBody) => {\r\n  return workflowClient.trigger({\r\n    url: `${getBaseUrl()}/api/workflows/process-document`,\r\n    body,\r\n  });\r\n};\r\n\r\nexport type DeleteDocumentBody = {\r\n  documentId: string;\r\n  deleteJobWhenDone?: boolean;\r\n  deleteNamespaceWhenDone?: boolean;\r\n  deleteOrgWhenDone?: boolean;\r\n};\r\nexport const triggerDeleteDocumentJob = async (body: DeleteDocumentBody) => {\r\n  return workflowClient.trigger({\r\n    url: `${getBaseUrl()}/api/workflows/delete-document`,\r\n    body,\r\n  });\r\n};\r\n\r\nexport type DeleteIngestJobBody = {\r\n  jobId: string;\r\n  deleteNamespaceWhenDone?: boolean;\r\n  deleteOrgWhenDone?: boolean;\r\n};\r\nexport const triggerDeleteIngestJob = async (body: DeleteIngestJobBody) => {\r\n  return workflowClient.trigger({\r\n    url: `${getBaseUrl()}/api/workflows/delete-ingest-job`,\r\n    body,\r\n  });\r\n};\r\n\r\nexport type DeleteNamespaceBody = {\r\n  namespaceId: string;\r\n  deleteOrgWhenDone?: boolean;\r\n};\r\nexport const triggerDeleteNamespace = async (body: DeleteNamespaceBody) => {\r\n  return workflowClient.trigger({\r\n    url: `${getBaseUrl()}/api/workflows/delete-namespace`,\r\n    body,\r\n  });\r\n};\r\n\r\nexport type ReIngestJobBody = {\r\n  jobId: string;\r\n};\r\nexport const triggerReIngestJob = async (body: ReIngestJobBody) => {\r\n  return workflowClient.trigger({\r\n    url: `${getBaseUrl()}/api/workflows/re-ingest`,\r\n    body,\r\n  });\r\n};\r\n\r\ntype CancelArgs = Parameters<typeof workflowClient.cancel>[0];\r\nexport const cancelWorkflow = async (args: CancelArgs) => {\r\n  return workflowClient.cancel(args);\r\n};\r\n"],"names":[],"mappings":";;;;;;;;;;;AAAA;AACA;AAAA;AACA;AAAA;AAEA;;;;;AAEO,MAAM,eAAe,IAAI,yJAAA,CAAA,SAAY,CAAC;IAC3C,SAAS,yHAAA,CAAA,MAAG,CAAC,UAAU;IACvB,OAAO,yHAAA,CAAA,MAAG,CAAC,YAAY;AACzB;AAEA,MAAM,iBAAiB,IAAI,+JAAA,CAAA,SAAc,CAAC;IACxC,SAAS,yHAAA,CAAA,MAAG,CAAC,UAAU;IACvB,OAAO,yHAAA,CAAA,MAAG,CAAC,YAAY;AACzB;AAEO,MAAM,iBAAiB,IAAI,yJAAA,CAAA,WAAQ,CAAC;IACzC,mBAAmB,yHAAA,CAAA,MAAG,CAAC,0BAA0B;IACjD,gBAAgB,yHAAA,CAAA,MAAG,CAAC,uBAAuB;AAC7C;AAKO,MAAM,sBAAsB,OAAO;IACxC,OAAO,eAAe,OAAO,CAAC;QAC5B,KAAK,GAAG,CAAA,GAAA,kIAAA,CAAA,aAAU,AAAD,IAAI,qBAAqB,CAAC;QAC3C;IACF;AACF;AAMO,MAAM,qBAAqB,OAAO;IACvC,OAAO,eAAe,OAAO,CAAC;QAC5B,KAAK,GAAG,CAAA,GAAA,kIAAA,CAAA,aAAU,AAAD,IAAI,+BAA+B,CAAC;QACrD;IACF;AACF;AAQO,MAAM,2BAA2B,OAAO;IAC7C,OAAO,eAAe,OAAO,CAAC;QAC5B,KAAK,GAAG,CAAA,GAAA,kIAAA,CAAA,aAAU,AAAD,IAAI,8BAA8B,CAAC;QACpD;IACF;AACF;AAOO,MAAM,yBAAyB,OAAO;IAC3C,OAAO,eAAe,OAAO,CAAC;QAC5B,KAAK,GAAG,CAAA,GAAA,kIAAA,CAAA,aAAU,AAAD,IAAI,gCAAgC,CAAC;QACtD;IACF;AACF;AAMO,MAAM,yBAAyB,OAAO;IAC3C,OAAO,eAAe,OAAO,CAAC;QAC5B,KAAK,GAAG,CAAA,GAAA,kIAAA,CAAA,aAAU,AAAD,IAAI,+BAA+B,CAAC;QACrD;IACF;AACF;AAKO,MAAM,qBAAqB,OAAO;IACvC,OAAO,eAAe,OAAO,CAAC;QAC5B,KAAK,GAAG,CAAA,GAAA,kIAAA,CAAA,aAAU,AAAD,IAAI,wBAAwB,CAAC;QAC9C;IACF;AACF;AAGO,MAAM,iBAAiB,OAAO;IACnC,OAAO,eAAe,MAAM,CAAC;AAC/B","debugId":null}},
    {"offset": {"line": 1355, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/services/documents/delete.ts"],"sourcesContent":["import { triggerDeleteDocumentJob } from \"@/lib/workflow\";\r\n\r\nimport { db, DocumentStatus } from \"@agentset/db\";\r\n\r\nexport const deleteDocument = async (documentId: string) => {\r\n  const updatedDoc = await db.document.update({\r\n    where: { id: documentId },\r\n    data: {\r\n      status: DocumentStatus.QUEUED_FOR_DELETE,\r\n    },\r\n  });\r\n\r\n  const { workflowRunId } = await triggerDeleteDocumentJob({\r\n    documentId: updatedDoc.id,\r\n  });\r\n\r\n  await db.document.update({\r\n    where: { id: updatedDoc.id },\r\n    data: {\r\n      workflowRunsIds: { push: workflowRunId },\r\n    },\r\n  });\r\n\r\n  return updatedDoc;\r\n};\r\n"],"names":[],"mappings":";;;AAAA;AAEA;AAAA;AAAA;;;AAEO,MAAM,iBAAiB,OAAO;IACnC,MAAM,aAAa,MAAM,+HAAA,CAAA,KAAE,CAAC,QAAQ,CAAC,MAAM,CAAC;QAC1C,OAAO;YAAE,IAAI;QAAW;QACxB,MAAM;YACJ,QAAQ,6HAAA,CAAA,iBAAc,CAAC,iBAAiB;QAC1C;IACF;IAEA,MAAM,EAAE,aAAa,EAAE,GAAG,MAAM,CAAA,GAAA,qIAAA,CAAA,2BAAwB,AAAD,EAAE;QACvD,YAAY,WAAW,EAAE;IAC3B;IAEA,MAAM,+HAAA,CAAA,KAAE,CAAC,QAAQ,CAAC,MAAM,CAAC;QACvB,OAAO;YAAE,IAAI,WAAW,EAAE;QAAC;QAC3B,MAAM;YACJ,iBAAiB;gBAAE,MAAM;YAAc;QACzC;IACF;IAEA,OAAO;AACT","debugId":null}},
    {"offset": {"line": 1394, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/api/ids.ts"],"sourcesContent":["const _prefixes = [\"ns_\", \"user_\", \"org_\", \"job_\", \"doc_\"] as const;\r\n\r\nexport const prefixId = (id: string, prefix: (typeof _prefixes)[number]) => {\r\n  return id.startsWith(prefix) ? id : `${prefix}${id}`;\r\n};\r\n\r\nexport const normalizeId = (id: string, prefix: (typeof _prefixes)[number]) => {\r\n  return id.startsWith(prefix) ? id.replace(prefix, \"\") : id;\r\n};\r\n"],"names":[],"mappings":";;;;AAAA,MAAM,YAAY;IAAC;IAAO;IAAS;IAAQ;IAAQ;CAAO;AAEnD,MAAM,WAAW,CAAC,IAAY;IACnC,OAAO,GAAG,UAAU,CAAC,UAAU,KAAK,GAAG,SAAS,IAAI;AACtD;AAEO,MAAM,cAAc,CAAC,IAAY;IACtC,OAAO,GAAG,UAAU,CAAC,UAAU,GAAG,OAAO,CAAC,QAAQ,MAAM;AAC1D","debugId":null}},
    {"offset": {"line": 1417, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/services/pagination.ts"],"sourcesContent":["import type z from \"@/lib/zod\";\r\nimport type { paginationSchema } from \"@/schemas/api/pagination\";\r\nimport { normalizeId } from \"@/lib/api/ids\";\r\n\r\nexport const getPaginationArgs = (\r\n  input: z.infer<typeof paginationSchema>,\r\n  cursorPrefix?: Parameters<typeof normalizeId>[1],\r\n) => {\r\n  return {\r\n    take: (input.perPage + 1) * (input.cursorDirection === \"forward\" ? 1 : -1),\r\n    cursor: input.cursor\r\n      ? {\r\n          id: cursorPrefix\r\n            ? normalizeId(input.cursor, cursorPrefix)\r\n            : input.cursor,\r\n        }\r\n      : undefined,\r\n  };\r\n};\r\n\r\nexport const paginateResults = <T extends { id: string }>(\r\n  input: z.infer<typeof paginationSchema>,\r\n  results: T[],\r\n) => {\r\n  return {\r\n    records: results.slice(0, input.perPage),\r\n    nextCursor:\r\n      results.length > input.perPage\r\n        ? (results[results.length - 1]?.id ?? null)\r\n        : null,\r\n  };\r\n};\r\n"],"names":[],"mappings":";;;;AAEA;;AAEO,MAAM,oBAAoB,CAC/B,OACA;IAEA,OAAO;QACL,MAAM,CAAC,MAAM,OAAO,GAAG,CAAC,IAAI,CAAC,MAAM,eAAe,KAAK,YAAY,IAAI,CAAC,CAAC;QACzE,QAAQ,MAAM,MAAM,GAChB;YACE,IAAI,eACA,CAAA,GAAA,uIAAA,CAAA,cAAW,AAAD,EAAE,MAAM,MAAM,EAAE,gBAC1B,MAAM,MAAM;QAClB,IACA;IACN;AACF;AAEO,MAAM,kBAAkB,CAC7B,OACA;IAEA,OAAO;QACL,SAAS,QAAQ,KAAK,CAAC,GAAG,MAAM,OAAO;QACvC,YACE,QAAQ,MAAM,GAAG,MAAM,OAAO,GACzB,OAAO,CAAC,QAAQ,MAAM,GAAG,EAAE,EAAE,MAAM,OACpC;IACR;AACF","debugId":null}},
    {"offset": {"line": 1443, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/server/api/routers/documents.ts"],"sourcesContent":["import z from \"@/lib/zod\";\r\nimport { getDocumentsSchema } from \"@/schemas/api/document\";\r\nimport { createTRPCRouter, protectedProcedure } from \"@/server/api/trpc\";\r\nimport { deleteDocument } from \"@/services/documents/delete\";\r\nimport { getPaginationArgs, paginateResults } from \"@/services/pagination\";\r\nimport { TRPCError } from \"@trpc/server\";\r\n\r\nimport { DocumentStatus } from \"@agentset/db\";\r\n\r\nimport { getNamespaceByUser } from \"../auth\";\r\n\r\nexport const documentsRouter = createTRPCRouter({\r\n  all: protectedProcedure\r\n    .input(\r\n      getDocumentsSchema.extend({\r\n        namespaceId: z.string(),\r\n        ingestJobId: z.string().optional(),\r\n      }),\r\n    )\r\n    .query(async ({ ctx, input }) => {\r\n      const namespace = await getNamespaceByUser(ctx, {\r\n        id: input.namespaceId,\r\n      });\r\n\r\n      if (!namespace) {\r\n        throw new TRPCError({ code: \"NOT_FOUND\" });\r\n      }\r\n\r\n      const documents = await ctx.db.document.findMany({\r\n        where: {\r\n          ingestJob: {\r\n            namespaceId: namespace.id,\r\n            ...(input.ingestJobId && { id: input.ingestJobId }),\r\n          },\r\n          ...(input.statuses &&\r\n            input.statuses.length > 0 && { status: { in: input.statuses } }),\r\n        },\r\n        orderBy: [\r\n          {\r\n            [input.orderBy]: input.order,\r\n          },\r\n        ],\r\n        ...getPaginationArgs(input, \"doc_\"),\r\n      });\r\n\r\n      return paginateResults(input, documents);\r\n    }),\r\n  delete: protectedProcedure\r\n    .input(\r\n      z.object({\r\n        documentId: z.string(),\r\n        namespaceId: z.string(),\r\n      }),\r\n    )\r\n    .mutation(async ({ ctx, input }) => {\r\n      const namespace = await getNamespaceByUser(ctx, {\r\n        id: input.namespaceId,\r\n      });\r\n\r\n      if (!namespace) {\r\n        throw new TRPCError({ code: \"NOT_FOUND\" });\r\n      }\r\n\r\n      const document = await ctx.db.document.findUnique({\r\n        where: {\r\n          id: input.documentId,\r\n          ingestJob: {\r\n            namespaceId: namespace.id,\r\n          },\r\n        },\r\n        select: { id: true, status: true },\r\n      });\r\n\r\n      if (!document) {\r\n        throw new TRPCError({ code: \"NOT_FOUND\" });\r\n      }\r\n\r\n      if (\r\n        document.status === DocumentStatus.QUEUED_FOR_DELETE ||\r\n        document.status === DocumentStatus.DELETING\r\n      ) {\r\n        throw new TRPCError({ code: \"BAD_REQUEST\" });\r\n      }\r\n\r\n      const updatedDocument = await deleteDocument(input.documentId);\r\n\r\n      return updatedDocument;\r\n    }),\r\n});\r\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAEA;;;;;;;;;AAEO,MAAM,kBAAkB,CAAA,GAAA,2IAAA,CAAA,mBAAgB,AAAD,EAAE;IAC9C,KAAK,2IAAA,CAAA,qBAAkB,CACpB,KAAK,CACJ,gJAAA,CAAA,qBAAkB,CAAC,MAAM,CAAC;QACxB,aAAa,yIAAA,CAAA,UAAC,CAAC,MAAM;QACrB,aAAa,yIAAA,CAAA,UAAC,CAAC,MAAM,GAAG,QAAQ;IAClC,IAED,KAAK,CAAC,OAAO,EAAE,GAAG,EAAE,KAAK,EAAE;QAC1B,MAAM,YAAY,MAAM,CAAA,GAAA,2IAAA,CAAA,qBAAkB,AAAD,EAAE,KAAK;YAC9C,IAAI,MAAM,WAAW;QACvB;QAEA,IAAI,CAAC,WAAW;YACd,MAAM,IAAI,0MAAA,CAAA,YAAS,CAAC;gBAAE,MAAM;YAAY;QAC1C;QAEA,MAAM,YAAY,MAAM,IAAI,EAAE,CAAC,QAAQ,CAAC,QAAQ,CAAC;YAC/C,OAAO;gBACL,WAAW;oBACT,aAAa,UAAU,EAAE;oBACzB,GAAI,MAAM,WAAW,IAAI;wBAAE,IAAI,MAAM,WAAW;oBAAC,CAAC;gBACpD;gBACA,GAAI,MAAM,QAAQ,IAChB,MAAM,QAAQ,CAAC,MAAM,GAAG,KAAK;oBAAE,QAAQ;wBAAE,IAAI,MAAM,QAAQ;oBAAC;gBAAE,CAAC;YACnE;YACA,SAAS;gBACP;oBACE,CAAC,MAAM,OAAO,CAAC,EAAE,MAAM,KAAK;gBAC9B;aACD;YACD,GAAG,CAAA,GAAA,4IAAA,CAAA,oBAAiB,AAAD,EAAE,OAAO,OAAO;QACrC;QAEA,OAAO,CAAA,GAAA,4IAAA,CAAA,kBAAe,AAAD,EAAE,OAAO;IAChC;IACF,QAAQ,2IAAA,CAAA,qBAAkB,CACvB,KAAK,CACJ,yIAAA,CAAA,UAAC,CAAC,MAAM,CAAC;QACP,YAAY,yIAAA,CAAA,UAAC,CAAC,MAAM;QACpB,aAAa,yIAAA,CAAA,UAAC,CAAC,MAAM;IACvB,IAED,QAAQ,CAAC,OAAO,EAAE,GAAG,EAAE,KAAK,EAAE;QAC7B,MAAM,YAAY,MAAM,CAAA,GAAA,2IAAA,CAAA,qBAAkB,AAAD,EAAE,KAAK;YAC9C,IAAI,MAAM,WAAW;QACvB;QAEA,IAAI,CAAC,WAAW;YACd,MAAM,IAAI,0MAAA,CAAA,YAAS,CAAC;gBAAE,MAAM;YAAY;QAC1C;QAEA,MAAM,WAAW,MAAM,IAAI,EAAE,CAAC,QAAQ,CAAC,UAAU,CAAC;YAChD,OAAO;gBACL,IAAI,MAAM,UAAU;gBACpB,WAAW;oBACT,aAAa,UAAU,EAAE;gBAC3B;YACF;YACA,QAAQ;gBAAE,IAAI;gBAAM,QAAQ;YAAK;QACnC;QAEA,IAAI,CAAC,UAAU;YACb,MAAM,IAAI,0MAAA,CAAA,YAAS,CAAC;gBAAE,MAAM;YAAY;QAC1C;QAEA,IACE,SAAS,MAAM,KAAK,6HAAA,CAAA,iBAAc,CAAC,iBAAiB,IACpD,SAAS,MAAM,KAAK,6HAAA,CAAA,iBAAc,CAAC,QAAQ,EAC3C;YACA,MAAM,IAAI,0MAAA,CAAA,YAAS,CAAC;gBAAE,MAAM;YAAc;QAC5C;QAEA,MAAM,kBAAkB,MAAM,CAAA,GAAA,qJAAA,CAAA,iBAAc,AAAD,EAAE,MAAM,UAAU;QAE7D,OAAO;IACT;AACJ","debugId":null}},
    {"offset": {"line": 1544, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/domains/constants.ts"],"sourcesContent":["export const ccTLDs = new Set([\r\n  \"af\",\r\n  \"ax\",\r\n  \"al\",\r\n  \"dz\",\r\n  \"as\",\r\n  \"ad\",\r\n  \"ao\",\r\n  \"ai\",\r\n  \"aq\",\r\n  \"ag\",\r\n  \"ar\",\r\n  \"am\",\r\n  \"aw\",\r\n  \"ac\",\r\n  \"au\",\r\n  \"at\",\r\n  \"az\",\r\n  \"bs\",\r\n  \"bh\",\r\n  \"bd\",\r\n  \"bb\",\r\n  \"eus\",\r\n  \"by\",\r\n  \"be\",\r\n  \"bz\",\r\n  \"bj\",\r\n  \"bm\",\r\n  \"bt\",\r\n  \"bo\",\r\n  \"bq\",\r\n  \"an\",\r\n  \"nl\",\r\n  \"ba\",\r\n  \"bw\",\r\n  \"bv\",\r\n  \"br\",\r\n  \"io\",\r\n  \"vg\",\r\n  \"bn\",\r\n  \"bg\",\r\n  \"bf\",\r\n  \"mm\",\r\n  \"bi\",\r\n  \"kh\",\r\n  \"cm\",\r\n  \"ca\",\r\n  \"cv\",\r\n  \"cat\",\r\n  \"ky\",\r\n  \"cf\",\r\n  \"td\",\r\n  \"cl\",\r\n  \"cn\",\r\n  \"cx\",\r\n  \"cc\",\r\n  \"co\",\r\n  \"km\",\r\n  \"cd\",\r\n  \"cg\",\r\n  \"ck\",\r\n  \"cr\",\r\n  \"ci\",\r\n  \"hr\",\r\n  \"cu\",\r\n  \"cw\",\r\n  \"cy\",\r\n  \"cz\",\r\n  \"dk\",\r\n  \"dj\",\r\n  \"dm\",\r\n  \"do\",\r\n  \"tl\",\r\n  \"tp\",\r\n  \"ec\",\r\n  \"eg\",\r\n  \"sv\",\r\n  \"gq\",\r\n  \"er\",\r\n  \"ee\",\r\n  \"et\",\r\n  \"eu\",\r\n  \"fk\",\r\n  \"fo\",\r\n  \"fm\",\r\n  \"fj\",\r\n  \"fi\",\r\n  \"fr\",\r\n  \"gf\",\r\n  \"pf\",\r\n  \"tf\",\r\n  \"ga\",\r\n  \"gal\",\r\n  \"gm\",\r\n  \"ps\",\r\n  \"ge\",\r\n  \"de\",\r\n  \"gh\",\r\n  \"gi\",\r\n  \"gr\",\r\n  \"gl\",\r\n  \"gd\",\r\n  \"gp\",\r\n  \"gu\",\r\n  \"gt\",\r\n  \"gg\",\r\n  \"gn\",\r\n  \"gw\",\r\n  \"gy\",\r\n  \"ht\",\r\n  \"hm\",\r\n  \"hn\",\r\n  \"hk\",\r\n  \"hu\",\r\n  \"is\",\r\n  \"in\",\r\n  \"id\",\r\n  \"ir\",\r\n  \"iq\",\r\n  \"ie\",\r\n  \"im\",\r\n  \"il\",\r\n  \"it\",\r\n  \"jm\",\r\n  \"jp\",\r\n  \"je\",\r\n  \"jo\",\r\n  \"kz\",\r\n  \"ke\",\r\n  \"ki\",\r\n  \"kw\",\r\n  \"kg\",\r\n  \"la\",\r\n  \"lv\",\r\n  \"lb\",\r\n  \"ls\",\r\n  \"lr\",\r\n  \"ly\",\r\n  \"li\",\r\n  \"lt\",\r\n  \"lu\",\r\n  \"mo\",\r\n  \"mk\",\r\n  \"mg\",\r\n  \"mw\",\r\n  \"my\",\r\n  \"mv\",\r\n  \"ml\",\r\n  \"mt\",\r\n  \"mh\",\r\n  \"mq\",\r\n  \"mr\",\r\n  \"mu\",\r\n  \"yt\",\r\n  \"mx\",\r\n  \"md\",\r\n  \"mc\",\r\n  \"mn\",\r\n  \"me\",\r\n  \"ms\",\r\n  \"ma\",\r\n  \"mz\",\r\n  \"mm\",\r\n  \"na\",\r\n  \"nr\",\r\n  \"np\",\r\n  \"nl\",\r\n  \"nc\",\r\n  \"nz\",\r\n  \"ni\",\r\n  \"ne\",\r\n  \"ng\",\r\n  \"nu\",\r\n  \"nf\",\r\n  \"nc\",\r\n  \"tr\",\r\n  \"kp\",\r\n  \"mp\",\r\n  \"no\",\r\n  \"om\",\r\n  \"pk\",\r\n  \"pw\",\r\n  \"ps\",\r\n  \"pa\",\r\n  \"pg\",\r\n  \"py\",\r\n  \"pe\",\r\n  \"ph\",\r\n  \"pn\",\r\n  \"pl\",\r\n  \"pt\",\r\n  \"pr\",\r\n  \"qa\",\r\n  \"ro\",\r\n  \"ru\",\r\n  \"rw\",\r\n  \"re\",\r\n  \"bq\",\r\n  \"an\",\r\n  \"bl\",\r\n  \"gp\",\r\n  \"fr\",\r\n  \"sh\",\r\n  \"kn\",\r\n  \"lc\",\r\n  \"mf\",\r\n  \"gp\",\r\n  \"fr\",\r\n  \"pm\",\r\n  \"vc\",\r\n  \"ws\",\r\n  \"sm\",\r\n  \"st\",\r\n  \"sa\",\r\n  \"sn\",\r\n  \"rs\",\r\n  \"sc\",\r\n  \"sl\",\r\n  \"sg\",\r\n  \"bq\",\r\n  \"an\",\r\n  \"nl\",\r\n  \"sx\",\r\n  \"an\",\r\n  \"sk\",\r\n  \"si\",\r\n  \"sb\",\r\n  \"so\",\r\n  \"so\",\r\n  \"za\",\r\n  \"gs\",\r\n  \"kr\",\r\n  \"ss\",\r\n  \"es\",\r\n  \"lk\",\r\n  \"sd\",\r\n  \"sr\",\r\n  \"sj\",\r\n  \"sz\",\r\n  \"se\",\r\n  \"ch\",\r\n  \"sy\",\r\n  \"tw\",\r\n  \"tj\",\r\n  \"tz\",\r\n  \"th\",\r\n  \"tg\",\r\n  \"tk\",\r\n  \"to\",\r\n  \"tt\",\r\n  \"tn\",\r\n  \"tr\",\r\n  \"tm\",\r\n  \"tc\",\r\n  \"tv\",\r\n  \"ug\",\r\n  \"ua\",\r\n  \"ae\",\r\n  \"uk\",\r\n  \"us\",\r\n  \"vi\",\r\n  \"uy\",\r\n  \"uz\",\r\n  \"vu\",\r\n  \"va\",\r\n  \"ve\",\r\n  \"vn\",\r\n  \"wf\",\r\n  \"eh\",\r\n  \"ma\",\r\n  \"ye\",\r\n  \"zm\",\r\n  \"zw\",\r\n]);\r\n\r\nexport const SECOND_LEVEL_DOMAINS = new Set([\r\n  \"com\",\r\n  \"co\",\r\n  \"net\",\r\n  \"org\",\r\n  \"edu\",\r\n  \"gov\",\r\n  \"in\",\r\n]);\r\n\r\nexport const SPECIAL_APEX_DOMAINS = new Set([\r\n  \"my.id\",\r\n  \"github.io\",\r\n  \"vercel.app\",\r\n  \"now.sh\",\r\n  \"pages.dev\",\r\n  \"webflow.io\",\r\n  \"netlify.app\",\r\n  \"fly.dev\",\r\n  \"web.app\",\r\n]);\r\n"],"names":[],"mappings":";;;;;AAAO,MAAM,SAAS,IAAI,IAAI;IAC5B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAEM,MAAM,uBAAuB,IAAI,IAAI;IAC1C;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAEM,MAAM,uBAAuB,IAAI,IAAI;IAC1C;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD","debugId":null}},
    {"offset": {"line": 1849, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/domains/utils.ts"],"sourcesContent":["import { env } from \"@/env\";\r\n\r\nimport { db } from \"@agentset/db\";\r\n\r\nimport type { AgentsetApiError } from \"../api/errors\";\r\nimport {\r\n  ccTLDs,\r\n  SECOND_LEVEL_DOMAINS,\r\n  SPECIAL_APEX_DOMAINS,\r\n} from \"./constants\";\r\n\r\nexport const validDomainRegex = new RegExp(\r\n  /^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,}$/,\r\n);\r\nexport const isValidDomain = (domain: string) => {\r\n  return validDomainRegex.test(domain);\r\n  // return (\r\n  //   validDomainRegex.test(domain) &&\r\n  //   // make sure the domain isn't agentset.ai\r\n  //   !/^(agentset\\.ai|.*\\.agentset\\.ai)$/i.test(domain)\r\n  // );\r\n};\r\n\r\nexport const domainExists = async (domain: string) => {\r\n  const response = await db.domain.findFirst({\r\n    where: {\r\n      slug: domain,\r\n    },\r\n    select: {\r\n      slug: true,\r\n    },\r\n  });\r\n\r\n  return !!response;\r\n};\r\n\r\nexport const validateDomain = async (\r\n  domain: string,\r\n): Promise<\r\n  { error: null } | { error: string; code: AgentsetApiError[\"code\"] }\r\n> => {\r\n  if (!domain || typeof domain !== \"string\") {\r\n    return { error: \"Missing domain\", code: \"unprocessable_entity\" };\r\n  }\r\n\r\n  if (!isValidDomain(domain)) {\r\n    return { error: \"Invalid domain\", code: \"unprocessable_entity\" };\r\n  }\r\n\r\n  const exists = await domainExists(domain);\r\n  if (exists) {\r\n    return { error: \"Domain is already in use.\", code: \"conflict\" };\r\n  }\r\n\r\n  return { error: null };\r\n};\r\n\r\nexport const getApexDomain = (url: string) => {\r\n  let domain;\r\n  try {\r\n    // replace any custom scheme (e.g. notion://) with https://\r\n    // use the URL constructor to get the hostname\r\n    domain = new URL(url.replace(/^[a-zA-Z]+:\\/\\//, \"https://\")).hostname;\r\n  } catch {\r\n    return \"\";\r\n  }\r\n  if (domain === \"youtu.be\") return \"youtube.com\";\r\n\r\n  const parts = domain.split(\".\");\r\n  if (parts.length > 2) {\r\n    if (\r\n      // if this is a second-level TLD (e.g. co.uk, .com.ua, .org.tt), we need to return the last 3 parts\r\n      (SECOND_LEVEL_DOMAINS.has(parts[parts.length - 2]!) &&\r\n        ccTLDs.has(parts[parts.length - 1]!)) ||\r\n      // if it's a special subdomain for website builders (e.g. weathergpt.vercel.app/)\r\n      SPECIAL_APEX_DOMAINS.has(parts.slice(-2).join(\".\"))\r\n    ) {\r\n      return parts.slice(-3).join(\".\");\r\n    }\r\n    // otherwise, it's a subdomain (e.g. agentset.vercel.app), so we return the last 2 parts\r\n    return parts.slice(-2).join(\".\");\r\n  }\r\n  // if it's a normal domain (e.g. agentset.ai), we return the domain\r\n  return domain;\r\n};\r\n\r\nexport const callVercelApi = async <T>(\r\n  path: string,\r\n  method: \"GET\" | \"POST\" | \"DELETE\",\r\n  body?: any,\r\n) => {\r\n  const url = new URL(`https://api.vercel.com${path}`);\r\n  const searchParams = url.searchParams;\r\n  searchParams.set(\"teamId\", env.VERCEL_TEAM_ID);\r\n\r\n  const response = await fetch(url.toString(), {\r\n    method,\r\n    headers: {\r\n      Authorization: `Bearer ${env.VERCEL_API_TOKEN}`,\r\n      ...(method !== \"DELETE\" && {\r\n        \"Content-Type\": \"application/json\",\r\n      }),\r\n    },\r\n    ...(!!body && {\r\n      body: JSON.stringify(body),\r\n    }),\r\n  });\r\n\r\n  return response.json() as Promise<T>;\r\n};\r\n"],"names":[],"mappings":";;;;;;;;AAAA;AAEA;AAAA;AAGA;;;;AAMO,MAAM,mBAAmB,IAAI,OAClC;AAEK,MAAM,gBAAgB,CAAC;IAC5B,OAAO,iBAAiB,IAAI,CAAC;AAC7B,WAAW;AACX,qCAAqC;AACrC,8CAA8C;AAC9C,uDAAuD;AACvD,KAAK;AACP;AAEO,MAAM,eAAe,OAAO;IACjC,MAAM,WAAW,MAAM,+HAAA,CAAA,KAAE,CAAC,MAAM,CAAC,SAAS,CAAC;QACzC,OAAO;YACL,MAAM;QACR;QACA,QAAQ;YACN,MAAM;QACR;IACF;IAEA,OAAO,CAAC,CAAC;AACX;AAEO,MAAM,iBAAiB,OAC5B;IAIA,IAAI,CAAC,UAAU,OAAO,WAAW,UAAU;QACzC,OAAO;YAAE,OAAO;YAAkB,MAAM;QAAuB;IACjE;IAEA,IAAI,CAAC,cAAc,SAAS;QAC1B,OAAO;YAAE,OAAO;YAAkB,MAAM;QAAuB;IACjE;IAEA,MAAM,SAAS,MAAM,aAAa;IAClC,IAAI,QAAQ;QACV,OAAO;YAAE,OAAO;YAA6B,MAAM;QAAW;IAChE;IAEA,OAAO;QAAE,OAAO;IAAK;AACvB;AAEO,MAAM,gBAAgB,CAAC;IAC5B,IAAI;IACJ,IAAI;QACF,2DAA2D;QAC3D,8CAA8C;QAC9C,SAAS,IAAI,IAAI,IAAI,OAAO,CAAC,mBAAmB,aAAa,QAAQ;IACvE,EAAE,OAAM;QACN,OAAO;IACT;IACA,IAAI,WAAW,YAAY,OAAO;IAElC,MAAM,QAAQ,OAAO,KAAK,CAAC;IAC3B,IAAI,MAAM,MAAM,GAAG,GAAG;QACpB,IACE,mGAAmG;QAClG,iJAAA,CAAA,uBAAoB,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,MAAM,GAAG,EAAE,KAC/C,iJAAA,CAAA,SAAM,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,MAAM,GAAG,EAAE,KACpC,iFAAiF;QACjF,iJAAA,CAAA,uBAAoB,CAAC,GAAG,CAAC,MAAM,KAAK,CAAC,CAAC,GAAG,IAAI,CAAC,OAC9C;YACA,OAAO,MAAM,KAAK,CAAC,CAAC,GAAG,IAAI,CAAC;QAC9B;QACA,wFAAwF;QACxF,OAAO,MAAM,KAAK,CAAC,CAAC,GAAG,IAAI,CAAC;IAC9B;IACA,mEAAmE;IACnE,OAAO;AACT;AAEO,MAAM,gBAAgB,OAC3B,MACA,QACA;IAEA,MAAM,MAAM,IAAI,IAAI,CAAC,sBAAsB,EAAE,MAAM;IACnD,MAAM,eAAe,IAAI,YAAY;IACrC,aAAa,GAAG,CAAC,UAAU,yHAAA,CAAA,MAAG,CAAC,cAAc;IAE7C,MAAM,WAAW,MAAM,MAAM,IAAI,QAAQ,IAAI;QAC3C;QACA,SAAS;YACP,eAAe,CAAC,OAAO,EAAE,yHAAA,CAAA,MAAG,CAAC,gBAAgB,EAAE;YAC/C,GAAI,WAAW,YAAY;gBACzB,gBAAgB;YAClB,CAAC;QACH;QACA,GAAI,CAAC,CAAC,QAAQ;YACZ,MAAM,KAAK,SAAS,CAAC;QACvB,CAAC;IACH;IAEA,OAAO,SAAS,IAAI;AACtB","debugId":null}},
    {"offset": {"line": 1955, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/domains/add-domain.ts"],"sourcesContent":["import { env } from \"@/env\";\r\n\r\nimport { callVercelApi } from \"./utils\";\r\n\r\nexport const addDomainToVercel = async (domain: string) => {\r\n  return callVercelApi<{\r\n    error?: { code: string; message: string };\r\n  }>(`/v10/projects/${env.VERCEL_PROJECT_ID}/domains`, \"POST\", {\r\n    name: domain.toLowerCase(),\r\n  });\r\n};\r\n"],"names":[],"mappings":";;;AAAA;AAEA;;;AAEO,MAAM,oBAAoB,OAAO;IACtC,OAAO,CAAA,GAAA,6IAAA,CAAA,gBAAa,AAAD,EAEhB,CAAC,cAAc,EAAE,yHAAA,CAAA,MAAG,CAAC,iBAAiB,CAAC,QAAQ,CAAC,EAAE,QAAQ;QAC3D,MAAM,OAAO,WAAW;IAC1B;AACF","debugId":null}},
    {"offset": {"line": 1973, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/domains/get-config-response.ts"],"sourcesContent":["import type { DomainConfigResponse } from \"@/types/vercel\";\r\n\r\nimport { callVercelApi } from \"./utils\";\r\n\r\nexport const getConfigResponse = async (domain: string) => {\r\n  return callVercelApi<DomainConfigResponse>(\r\n    `/v6/domains/${domain.toLowerCase()}/config`,\r\n    \"GET\",\r\n  );\r\n};\r\n"],"names":[],"mappings":";;;AAEA;;AAEO,MAAM,oBAAoB,OAAO;IACtC,OAAO,CAAA,GAAA,6IAAA,CAAA,gBAAa,AAAD,EACjB,CAAC,YAAY,EAAE,OAAO,WAAW,GAAG,OAAO,CAAC,EAC5C;AAEJ","debugId":null}},
    {"offset": {"line": 1987, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/domains/get-domain-response.ts"],"sourcesContent":["import type { DomainResponse } from \"@/types/vercel\";\r\nimport { env } from \"@/env\";\r\n\r\nimport { callVercelApi } from \"./utils\";\r\n\r\nexport const getDomainResponse = async (domain: string) => {\r\n  return callVercelApi<\r\n    DomainResponse & { error?: { code: string; message: string } }\r\n  >(\r\n    `/v9/projects/${env.VERCEL_PROJECT_ID}/domains/${domain.toLowerCase()}`,\r\n    \"GET\",\r\n  );\r\n};\r\n"],"names":[],"mappings":";;;AACA;AAEA;;;AAEO,MAAM,oBAAoB,OAAO;IACtC,OAAO,CAAA,GAAA,6IAAA,CAAA,gBAAa,AAAD,EAGjB,CAAC,aAAa,EAAE,yHAAA,CAAA,MAAG,CAAC,iBAAiB,CAAC,SAAS,EAAE,OAAO,WAAW,IAAI,EACvE;AAEJ","debugId":null}},
    {"offset": {"line": 2003, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/domains/remove-domain.ts"],"sourcesContent":["import { env } from \"@/env\";\r\n\r\nimport { callVercelApi } from \"./utils\";\r\n\r\nexport const removeDomainFromVercel = async (domain: string) => {\r\n  // if there are other subdomains or the apex domain itself is in use\r\n  // so we should only remove it from our Vercel project\r\n  return callVercelApi<{\r\n    error?: { code: string; message: string };\r\n  }>(\r\n    `/v9/projects/${env.VERCEL_PROJECT_ID}/domains/${domain.toLowerCase()}`,\r\n    \"DELETE\",\r\n  );\r\n};\r\n"],"names":[],"mappings":";;;AAAA;AAEA;;;AAEO,MAAM,yBAAyB,OAAO;IAC3C,oEAAoE;IACpE,sDAAsD;IACtD,OAAO,CAAA,GAAA,6IAAA,CAAA,gBAAa,AAAD,EAGjB,CAAC,aAAa,EAAE,yHAAA,CAAA,MAAG,CAAC,iBAAiB,CAAC,SAAS,EAAE,OAAO,WAAW,IAAI,EACvE;AAEJ","debugId":null}},
    {"offset": {"line": 2021, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/domains/verify-domain.ts"],"sourcesContent":["import type { DomainResponse } from \"@/types/vercel\";\r\nimport { env } from \"@/env\";\r\n\r\nimport { callVercelApi } from \"./utils\";\r\n\r\nexport const verifyDomain = async (domain: string) => {\r\n  return callVercelApi<DomainResponse>(\r\n    `/v9/projects/${env.VERCEL_PROJECT_ID}/domains/${domain.toLowerCase()}/verify`,\r\n    \"POST\",\r\n  );\r\n};\r\n"],"names":[],"mappings":";;;AACA;AAEA;;;AAEO,MAAM,eAAe,OAAO;IACjC,OAAO,CAAA,GAAA,6IAAA,CAAA,gBAAa,AAAD,EACjB,CAAC,aAAa,EAAE,yHAAA,CAAA,MAAG,CAAC,iBAAiB,CAAC,SAAS,EAAE,OAAO,WAAW,GAAG,OAAO,CAAC,EAC9E;AAEJ","debugId":null}},
    {"offset": {"line": 2037, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/server/api/routers/domains.ts"],"sourcesContent":["import type { ProtectedProcedureContext } from \"@/server/api/trpc\";\r\nimport { addDomainToVercel } from \"@/lib/domains/add-domain\";\r\nimport { getConfigResponse } from \"@/lib/domains/get-config-response\";\r\nimport { getDomainResponse } from \"@/lib/domains/get-domain-response\";\r\nimport { removeDomainFromVercel } from \"@/lib/domains/remove-domain\";\r\nimport { validateDomain } from \"@/lib/domains/utils\";\r\nimport { verifyDomain } from \"@/lib/domains/verify-domain\";\r\nimport { createTRPCRouter, protectedProcedure } from \"@/server/api/trpc\";\r\nimport { TRPCError } from \"@trpc/server\";\r\nimport { z } from \"zod\";\r\n\r\nimport type { Domain } from \"@agentset/db\";\r\n\r\nconst commonInput = z.object({\r\n  namespaceId: z.string(),\r\n});\r\n\r\nexport type DomainVerificationStatusProps =\r\n  | \"Valid Configuration\"\r\n  | \"Invalid Configuration\"\r\n  | \"Conflicting DNS Records\"\r\n  | \"Pending Verification\"\r\n  | \"Domain Not Found\"\r\n  | \"Unknown Error\";\r\n\r\nconst getHosting = async (\r\n  ctx: ProtectedProcedureContext,\r\n  input: z.infer<typeof commonInput>,\r\n) => {\r\n  const hosting = await ctx.db.hosting.findFirst({\r\n    where: {\r\n      namespace: {\r\n        id: input.namespaceId,\r\n        organization: {\r\n          members: { some: { userId: ctx.session.user.id } },\r\n        },\r\n      },\r\n    },\r\n  });\r\n\r\n  return hosting ?? null;\r\n};\r\n\r\nexport const domainsRouter = createTRPCRouter({\r\n  add: protectedProcedure\r\n    .input(commonInput.extend({ domain: z.string() }))\r\n    .mutation(async ({ ctx, input }) => {\r\n      const hosting = await getHosting(ctx, input);\r\n      if (!hosting) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Hosting not found\",\r\n        });\r\n      }\r\n\r\n      // get domain from hosting\r\n      const domain = await ctx.db.domain.findUnique({\r\n        where: {\r\n          hostingId: hosting.id,\r\n        },\r\n      });\r\n\r\n      if (domain) {\r\n        throw new TRPCError({\r\n          code: \"CONFLICT\",\r\n          message: \"You already set a domain\",\r\n        });\r\n      }\r\n\r\n      const validDomain = await validateDomain(input.domain);\r\n\r\n      if (validDomain.error) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: validDomain.error,\r\n        });\r\n      }\r\n\r\n      const vercelResponse = await addDomainToVercel(input.domain);\r\n      if (\r\n        vercelResponse.error &&\r\n        vercelResponse.error.code !== \"domain_already_in_use\" // ignore this error\r\n      ) {\r\n        throw new TRPCError({\r\n          code: \"UNPROCESSABLE_CONTENT\",\r\n          message: vercelResponse.error.message,\r\n        });\r\n      }\r\n\r\n      return ctx.db.domain.create({\r\n        data: {\r\n          hostingId: hosting.id,\r\n          slug: input.domain,\r\n        },\r\n      });\r\n    }),\r\n  checkStatus: protectedProcedure\r\n    .input(commonInput)\r\n    .query(async ({ ctx, input }) => {\r\n      const hosting = await getHosting(ctx, input);\r\n      if (!hosting) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Hosting not found\",\r\n        });\r\n      }\r\n\r\n      const domain = await ctx.db.domain.findUnique({\r\n        where: {\r\n          hostingId: hosting.id,\r\n        },\r\n      });\r\n\r\n      if (!domain) {\r\n        throw new TRPCError({ code: \"NOT_FOUND\", message: \"Domain not found\" });\r\n      }\r\n\r\n      let status: DomainVerificationStatusProps = \"Valid Configuration\";\r\n\r\n      const [domainJson, configJson] = await Promise.all([\r\n        getDomainResponse(domain.slug),\r\n        getConfigResponse(domain.slug),\r\n      ]);\r\n\r\n      if (domainJson.error?.code === \"not_found\") {\r\n        // domain not found on Vercel project\r\n        status = \"Domain Not Found\";\r\n        return {\r\n          status,\r\n          response: { configJson, domainJson },\r\n        };\r\n      } else if (domainJson.error) {\r\n        status = \"Unknown Error\";\r\n        return {\r\n          status,\r\n          response: { configJson, domainJson },\r\n        };\r\n      }\r\n\r\n      /**\r\n       * Domain has DNS conflicts\r\n       */\r\n      if (configJson.conflicts && configJson.conflicts.length > 0) {\r\n        status = \"Conflicting DNS Records\";\r\n        return {\r\n          status,\r\n          response: { configJson, domainJson },\r\n        };\r\n      }\r\n\r\n      /**\r\n       * If domain is not verified, we try to verify now\r\n       */\r\n      if (!domainJson.verified) {\r\n        status = \"Pending Verification\";\r\n        const verificationJson = await verifyDomain(domain.slug);\r\n        if (verificationJson.verified) {\r\n          /**\r\n           * Domain was just verified\r\n           */\r\n          status = \"Valid Configuration\";\r\n        }\r\n\r\n        return {\r\n          status,\r\n          response: { configJson, domainJson, verificationJson },\r\n        };\r\n      }\r\n\r\n      let prismaResponse: Domain | null = null;\r\n      if (!configJson.misconfigured) {\r\n        prismaResponse = await ctx.db.domain.update({\r\n          where: {\r\n            id: domain.id,\r\n          },\r\n          data: {\r\n            verified: true,\r\n            lastChecked: new Date(),\r\n          },\r\n        });\r\n      } else {\r\n        status = \"Invalid Configuration\";\r\n        prismaResponse = await ctx.db.domain.update({\r\n          where: {\r\n            id: domain.id,\r\n          },\r\n          data: {\r\n            verified: false,\r\n            lastChecked: new Date(),\r\n          },\r\n        });\r\n      }\r\n\r\n      return {\r\n        status,\r\n        response: { configJson, domainJson, prismaResponse },\r\n      };\r\n    }),\r\n  remove: protectedProcedure\r\n    .input(commonInput)\r\n    .mutation(async ({ ctx, input }) => {\r\n      const hosting = await getHosting(ctx, input);\r\n      if (!hosting) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Hosting not found\",\r\n        });\r\n      }\r\n\r\n      const domain = await ctx.db.domain.findUnique({\r\n        where: {\r\n          hostingId: hosting.id,\r\n        },\r\n      });\r\n\r\n      if (!domain) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Domain not found\",\r\n        });\r\n      }\r\n\r\n      const vercelResponse = await removeDomainFromVercel(domain.slug);\r\n      // ignore not_found error\r\n      if (vercelResponse.error && vercelResponse.error.code !== \"not_found\") {\r\n        throw new TRPCError({\r\n          code: \"UNPROCESSABLE_CONTENT\",\r\n          message: vercelResponse.error.message,\r\n        });\r\n      }\r\n\r\n      return ctx.db.domain.delete({\r\n        where: {\r\n          id: domain.id,\r\n        },\r\n      });\r\n    }),\r\n});\r\n"],"names":[],"mappings":";;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;AAIA,MAAM,cAAc,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC3B,aAAa,oIAAA,CAAA,IAAC,CAAC,MAAM;AACvB;AAUA,MAAM,aAAa,OACjB,KACA;IAEA,MAAM,UAAU,MAAM,IAAI,EAAE,CAAC,OAAO,CAAC,SAAS,CAAC;QAC7C,OAAO;YACL,WAAW;gBACT,IAAI,MAAM,WAAW;gBACrB,cAAc;oBACZ,SAAS;wBAAE,MAAM;4BAAE,QAAQ,IAAI,OAAO,CAAC,IAAI,CAAC,EAAE;wBAAC;oBAAE;gBACnD;YACF;QACF;IACF;IAEA,OAAO,WAAW;AACpB;AAEO,MAAM,gBAAgB,CAAA,GAAA,2IAAA,CAAA,mBAAgB,AAAD,EAAE;IAC5C,KAAK,2IAAA,CAAA,qBAAkB,CACpB,KAAK,CAAC,YAAY,MAAM,CAAC;QAAE,QAAQ,oIAAA,CAAA,IAAC,CAAC,MAAM;IAAG,IAC9C,QAAQ,CAAC,OAAO,EAAE,GAAG,EAAE,KAAK,EAAE;QAC7B,MAAM,UAAU,MAAM,WAAW,KAAK;QACtC,IAAI,CAAC,SAAS;YACZ,MAAM,IAAI,0MAAA,CAAA,YAAS,CAAC;gBAClB,MAAM;gBACN,SAAS;YACX;QACF;QAEA,0BAA0B;QAC1B,MAAM,SAAS,MAAM,IAAI,EAAE,CAAC,MAAM,CAAC,UAAU,CAAC;YAC5C,OAAO;gBACL,WAAW,QAAQ,EAAE;YACvB;QACF;QAEA,IAAI,QAAQ;YACV,MAAM,IAAI,0MAAA,CAAA,YAAS,CAAC;gBAClB,MAAM;gBACN,SAAS;YACX;QACF;QAEA,MAAM,cAAc,MAAM,CAAA,GAAA,6IAAA,CAAA,iBAAc,AAAD,EAAE,MAAM,MAAM;QAErD,IAAI,YAAY,KAAK,EAAE;YACrB,MAAM,IAAI,0MAAA,CAAA,YAAS,CAAC;gBAClB,MAAM;gBACN,SAAS,YAAY,KAAK;YAC5B;QACF;QAEA,MAAM,iBAAiB,MAAM,CAAA,GAAA,qJAAA,CAAA,oBAAiB,AAAD,EAAE,MAAM,MAAM;QAC3D,IACE,eAAe,KAAK,IACpB,eAAe,KAAK,CAAC,IAAI,KAAK,wBAAwB,oBAAoB;UAC1E;YACA,MAAM,IAAI,0MAAA,CAAA,YAAS,CAAC;gBAClB,MAAM;gBACN,SAAS,eAAe,KAAK,CAAC,OAAO;YACvC;QACF;QAEA,OAAO,IAAI,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC;YAC1B,MAAM;gBACJ,WAAW,QAAQ,EAAE;gBACrB,MAAM,MAAM,MAAM;YACpB;QACF;IACF;IACF,aAAa,2IAAA,CAAA,qBAAkB,CAC5B,KAAK,CAAC,aACN,KAAK,CAAC,OAAO,EAAE,GAAG,EAAE,KAAK,EAAE;QAC1B,MAAM,UAAU,MAAM,WAAW,KAAK;QACtC,IAAI,CAAC,SAAS;YACZ,MAAM,IAAI,0MAAA,CAAA,YAAS,CAAC;gBAClB,MAAM;gBACN,SAAS;YACX;QACF;QAEA,MAAM,SAAS,MAAM,IAAI,EAAE,CAAC,MAAM,CAAC,UAAU,CAAC;YAC5C,OAAO;gBACL,WAAW,QAAQ,EAAE;YACvB;QACF;QAEA,IAAI,CAAC,QAAQ;YACX,MAAM,IAAI,0MAAA,CAAA,YAAS,CAAC;gBAAE,MAAM;gBAAa,SAAS;YAAmB;QACvE;QAEA,IAAI,SAAwC;QAE5C,MAAM,CAAC,YAAY,WAAW,GAAG,MAAM,QAAQ,GAAG,CAAC;YACjD,CAAA,GAAA,iKAAA,CAAA,oBAAiB,AAAD,EAAE,OAAO,IAAI;YAC7B,CAAA,GAAA,iKAAA,CAAA,oBAAiB,AAAD,EAAE,OAAO,IAAI;SAC9B;QAED,IAAI,WAAW,KAAK,EAAE,SAAS,aAAa;YAC1C,qCAAqC;YACrC,SAAS;YACT,OAAO;gBACL;gBACA,UAAU;oBAAE;oBAAY;gBAAW;YACrC;QACF,OAAO,IAAI,WAAW,KAAK,EAAE;YAC3B,SAAS;YACT,OAAO;gBACL;gBACA,UAAU;oBAAE;oBAAY;gBAAW;YACrC;QACF;QAEA;;OAEC,GACD,IAAI,WAAW,SAAS,IAAI,WAAW,SAAS,CAAC,MAAM,GAAG,GAAG;YAC3D,SAAS;YACT,OAAO;gBACL;gBACA,UAAU;oBAAE;oBAAY;gBAAW;YACrC;QACF;QAEA;;OAEC,GACD,IAAI,CAAC,WAAW,QAAQ,EAAE;YACxB,SAAS;YACT,MAAM,mBAAmB,MAAM,CAAA,GAAA,wJAAA,CAAA,eAAY,AAAD,EAAE,OAAO,IAAI;YACvD,IAAI,iBAAiB,QAAQ,EAAE;gBAC7B;;WAEC,GACD,SAAS;YACX;YAEA,OAAO;gBACL;gBACA,UAAU;oBAAE;oBAAY;oBAAY;gBAAiB;YACvD;QACF;QAEA,IAAI,iBAAgC;QACpC,IAAI,CAAC,WAAW,aAAa,EAAE;YAC7B,iBAAiB,MAAM,IAAI,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC;gBAC1C,OAAO;oBACL,IAAI,OAAO,EAAE;gBACf;gBACA,MAAM;oBACJ,UAAU;oBACV,aAAa,IAAI;gBACnB;YACF;QACF,OAAO;YACL,SAAS;YACT,iBAAiB,MAAM,IAAI,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC;gBAC1C,OAAO;oBACL,IAAI,OAAO,EAAE;gBACf;gBACA,MAAM;oBACJ,UAAU;oBACV,aAAa,IAAI;gBACnB;YACF;QACF;QAEA,OAAO;YACL;YACA,UAAU;gBAAE;gBAAY;gBAAY;YAAe;QACrD;IACF;IACF,QAAQ,2IAAA,CAAA,qBAAkB,CACvB,KAAK,CAAC,aACN,QAAQ,CAAC,OAAO,EAAE,GAAG,EAAE,KAAK,EAAE;QAC7B,MAAM,UAAU,MAAM,WAAW,KAAK;QACtC,IAAI,CAAC,SAAS;YACZ,MAAM,IAAI,0MAAA,CAAA,YAAS,CAAC;gBAClB,MAAM;gBACN,SAAS;YACX;QACF;QAEA,MAAM,SAAS,MAAM,IAAI,EAAE,CAAC,MAAM,CAAC,UAAU,CAAC;YAC5C,OAAO;gBACL,WAAW,QAAQ,EAAE;YACvB;QACF;QAEA,IAAI,CAAC,QAAQ;YACX,MAAM,IAAI,0MAAA,CAAA,YAAS,CAAC;gBAClB,MAAM;gBACN,SAAS;YACX;QACF;QAEA,MAAM,iBAAiB,MAAM,CAAA,GAAA,wJAAA,CAAA,yBAAsB,AAAD,EAAE,OAAO,IAAI;QAC/D,yBAAyB;QACzB,IAAI,eAAe,KAAK,IAAI,eAAe,KAAK,CAAC,IAAI,KAAK,aAAa;YACrE,MAAM,IAAI,0MAAA,CAAA,YAAS,CAAC;gBAClB,MAAM;gBACN,SAAS,eAAe,KAAK,CAAC,OAAO;YACvC;QACF;QAEA,OAAO,IAAI,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC;YAC1B,OAAO;gBACL,IAAI,OAAO,EAAE;YACf;QACF;IACF;AACJ","debugId":null}},
    {"offset": {"line": 2271, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/prompt.ts"],"sourcesContent":["type PlaceholderKey = string;\r\n\r\ntype InferPromptVars<T extends PlaceholderKey[]> = T extends []\r\n  ? Record<string, never>\r\n  : { [K in T[number]]: string | number | boolean };\r\n\r\ntype CompileFunction<T> =\r\n  T extends Record<string, never> ? () => string : (variables: T) => string;\r\n\r\ntype PromptResult<T> = {\r\n  compile: CompileFunction<T>;\r\n};\r\n\r\nexport const prmpt = <K extends PlaceholderKey[]>(\r\n  strings: TemplateStringsArray,\r\n  ...keys: K\r\n): PromptResult<InferPromptVars<K>> => {\r\n  if (keys.length === 0) {\r\n    return {\r\n      compile: (() => strings[0]?.trim()) as CompileFunction<\r\n        InferPromptVars<K>\r\n      >,\r\n    };\r\n  }\r\n\r\n  return {\r\n    compile: ((variables: InferPromptVars<K>) => {\r\n      let result = strings[0];\r\n\r\n      for (let i = 0; i < keys.length; i++) {\r\n        const key = keys[i];\r\n        if (key !== undefined) {\r\n          result += variables[key] + (strings[i + 1] ?? \"\");\r\n        }\r\n      }\r\n\r\n      return result?.trim();\r\n    }) as CompileFunction<InferPromptVars<K>>,\r\n  };\r\n};\r\n"],"names":[],"mappings":";;;AAaO,MAAM,QAAQ,CACnB,SACA,GAAG;IAEH,IAAI,KAAK,MAAM,KAAK,GAAG;QACrB,OAAO;YACL,SAAU,IAAM,OAAO,CAAC,EAAE,EAAE;QAG9B;IACF;IAEA,OAAO;QACL,SAAU,CAAC;YACT,IAAI,SAAS,OAAO,CAAC,EAAE;YAEvB,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,IAAK;gBACpC,MAAM,MAAM,IAAI,CAAC,EAAE;gBACnB,IAAI,QAAQ,WAAW;oBACrB,UAAU,SAAS,CAAC,IAAI,GAAG,CAAC,OAAO,CAAC,IAAI,EAAE,IAAI,EAAE;gBAClD;YACF;YAEA,OAAO,QAAQ;QACjB;IACF;AACF","debugId":null}},
    {"offset": {"line": 2299, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/prompts.ts"],"sourcesContent":["import { prmpt } from \"@/lib/prompt\";\r\n\r\nexport const DEFAULT_SYSTEM_PROMPT = prmpt`\r\nYou are an AI assistant powered by Agentset. Your primary task is to provide accurate, factual responses based STRICTLY on the provided search results. You must ONLY answer questions using information explicitly found in the search results - do not make assumptions or add information from outside knowledge.\r\n\r\nFollow these STRICT guidelines:\r\n1. If the search results do not contain information to fully answer the query, state clearly: \"I cannot fully answer this question based on the available information.\" Then explain what specific aspects cannot be answered.\r\n2. Only use information directly stated in the search results - do not infer, assume, or add external knowledge.\r\n3. Your response must match the language of the user's query.\r\n4. Citations are MANDATORY for every factual statement. Format citations by placing the chunk number in brackets immediately after the relevant statement with no space, like this: \"The temperature is 20 degrees[3]\"\r\n5. When possible, include relevant direct quotes from the search results with proper citations.\r\n6. Do not preface responses with phrases like \"based on the search results\" - simply provide the cited answer.\r\n7. Maintain a clear, professional tone focused on accuracy and fidelity to the source material.\r\n\r\nIf the search results are completely irrelevant or insufficient to address any part of the query, respond: \"I cannot answer this question as the search results do not contain relevant information about [specific topic].\"\r\n`;\r\n\r\nexport const NEW_MESSAGE_PROMPT = prmpt`\r\nMost relevant search results:\r\n${\"chunks\"}\r\n\r\nUser's query:\r\n${\"query\"}\r\n`;\r\n\r\nexport const CONDENSE_SYSTEM_PROMPT = prmpt`\r\nGiven a conversation history between Human and Assistant and a follow-up question from Human, rewrite the question into a standalone query that:\r\n\r\n1. Incorporates all relevant context from the prior conversation\r\n2. Preserves specific details, names, and technical terms mentioned earlier\r\n3. Maintains the original language and tone of the user's question\r\n4. Focuses on searchable keywords and concepts to optimize vector database retrieval\r\n5. Removes conversational elements like \"as mentioned before\" or \"following up on\"\r\n6. Expands pronouns and references to their full form (e.g. \"it\"  \"the database schema\")\r\n\r\nYour task is to create a clear, context-rich query that will yield the most relevant search results from the vector database.\r\n\r\n\r\nQuestion: ${\"question\"}\r\n\r\nHistory:\r\n${\"chatHistory\"}\r\n`;\r\n\r\nexport const CONDENSE_USER_PROMPT = prmpt`\r\nChat History:\r\n${\"chatHistory\"}\r\n\r\nFollow Up Message:\r\n${\"query\"}\r\n`;\r\n"],"names":[],"mappings":";;;;;;AAAA;;AAEO,MAAM,wBAAwB,mIAAA,CAAA,QAAK,CAAC;;;;;;;;;;;;;AAa3C,CAAC;AAEM,MAAM,qBAAqB,mIAAA,CAAA,QAAK,CAAC;;AAExC,EAAE,SAAS;;;AAGX,EAAE,QAAQ;AACV,CAAC;AAEM,MAAM,yBAAyB,mIAAA,CAAA,QAAK,CAAC;;;;;;;;;;;;;UAalC,EAAE,WAAW;;;AAGvB,EAAE,cAAc;AAChB,CAAC;AAEM,MAAM,uBAAuB,mIAAA,CAAA,QAAK,CAAC;;AAE1C,EAAE,cAAc;;;AAGhB,EAAE,QAAQ;AACV,CAAC","debugId":null}},
    {"offset": {"line": 2359, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/uploadthing/server.ts"],"sourcesContent":["import { env } from \"@/env\";\n\n// Wrapper functions to replace S3 functionality\nexport async function uploadFile(file: File, key?: string) {\n  try {\n    const formData = new FormData();\n    formData.append(\"files\", file);\n    \n    const response = await fetch(\"/api/uploadthing\", {\n      method: \"POST\",\n      body: formData,\n    });\n    \n    if (!response.ok) {\n      throw new Error(\"Upload failed\");\n    }\n    \n    const result = await response.json();\n    return {\n      url: result[0]?.url || \"\",\n      key: result[0]?.key || \"\",\n    };\n  } catch (error) {\n    console.error(\"Upload error:\", error);\n    throw error;\n  }\n}\n\nexport async function deleteFile(key: string) {\n  try {\n    // Uploadthing delete logic would go here\n    console.log(\"Deleting file:\", key);\n    return true;\n  } catch (error) {\n    console.error(\"Delete error:\", error);\n    throw error;\n  }\n}\n\nexport async function uploadAsset(file: File, key?: string) {\n  try {\n    const formData = new FormData();\n    formData.append(\"files\", file);\n    \n    const response = await fetch(\"/api/uploadthing\", {\n      method: \"POST\",\n      body: formData,\n    });\n    \n    if (!response.ok) {\n      throw new Error(\"Asset upload failed\");\n    }\n    \n    const result = await response.json();\n    return {\n      url: result[0]?.url || \"\",\n      key: result[0]?.key || \"\",\n    };\n  } catch (error) {\n    console.error(\"Asset upload error:\", error);\n    throw error;\n  }\n}\n\nexport async function deleteAsset(key: string) {\n  try {\n    // Uploadthing delete logic would go here\n    console.log(\"Deleting asset:\", key);\n    return true;\n  } catch (error) {\n    console.error(\"Asset delete error:\", error);\n    throw error;\n  }\n}\n\n// Helper function to extract key from Uploadthing URL\nexport function extractKeyFromUrl(url: string): string {\n  const parts = url.split(\"/\");\n  return parts[parts.length - 1] || \"\";\n}\n\n// Helper function to get file metadata (placeholder for S3 functionality)\nexport async function getFileMetadata(key: string) {\n  // Uploadthing doesn't provide metadata API like S3\n  // Return basic metadata structure\n  return {\n    ContentLength: 0,\n    ContentType: \"application/octet-stream\",\n    LastModified: new Date(),\n  };\n}\n"],"names":[],"mappings":";;;;;;;;AAGO,eAAe,WAAW,IAAU,EAAE,GAAY;IACvD,IAAI;QACF,MAAM,WAAW,IAAI;QACrB,SAAS,MAAM,CAAC,SAAS;QAEzB,MAAM,WAAW,MAAM,MAAM,oBAAoB;YAC/C,QAAQ;YACR,MAAM;QACR;QAEA,IAAI,CAAC,SAAS,EAAE,EAAE;YAChB,MAAM,IAAI,MAAM;QAClB;QAEA,MAAM,SAAS,MAAM,SAAS,IAAI;QAClC,OAAO;YACL,KAAK,MAAM,CAAC,EAAE,EAAE,OAAO;YACvB,KAAK,MAAM,CAAC,EAAE,EAAE,OAAO;QACzB;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iBAAiB;QAC/B,MAAM;IACR;AACF;AAEO,eAAe,WAAW,GAAW;IAC1C,IAAI;QACF,yCAAyC;QACzC,QAAQ,GAAG,CAAC,kBAAkB;QAC9B,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iBAAiB;QAC/B,MAAM;IACR;AACF;AAEO,eAAe,YAAY,IAAU,EAAE,GAAY;IACxD,IAAI;QACF,MAAM,WAAW,IAAI;QACrB,SAAS,MAAM,CAAC,SAAS;QAEzB,MAAM,WAAW,MAAM,MAAM,oBAAoB;YAC/C,QAAQ;YACR,MAAM;QACR;QAEA,IAAI,CAAC,SAAS,EAAE,EAAE;YAChB,MAAM,IAAI,MAAM;QAClB;QAEA,MAAM,SAAS,MAAM,SAAS,IAAI;QAClC,OAAO;YACL,KAAK,MAAM,CAAC,EAAE,EAAE,OAAO;YACvB,KAAK,MAAM,CAAC,EAAE,EAAE,OAAO;QACzB;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,uBAAuB;QACrC,MAAM;IACR;AACF;AAEO,eAAe,YAAY,GAAW;IAC3C,IAAI;QACF,yCAAyC;QACzC,QAAQ,GAAG,CAAC,mBAAmB;QAC/B,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,uBAAuB;QACrC,MAAM;IACR;AACF;AAGO,SAAS,kBAAkB,GAAW;IAC3C,MAAM,QAAQ,IAAI,KAAK,CAAC;IACxB,OAAO,KAAK,CAAC,MAAM,MAAM,GAAG,EAAE,IAAI;AACpC;AAGO,eAAe,gBAAgB,GAAW;IAC/C,mDAAmD;IACnD,kCAAkC;IAClC,OAAO;QACL,eAAe;QACf,aAAa;QACb,cAAc,IAAI;IACpB;AACF","debugId":null}},
    {"offset": {"line": 2448, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/server/api/routers/hosting.ts"],"sourcesContent":["import type { ProtectedProcedureContext } from \"@/server/api/trpc\";\nimport { env } from \"@/env\";\nimport { prefixId } from \"@/lib/api/ids\";\nimport { DEFAULT_SYSTEM_PROMPT } from \"@/lib/prompts\";\nimport { tryCatch } from \"@/lib/error\";\nimport { deleteAsset, uploadAsset } from \"@/lib/uploadthing/server\";\nimport { createTRPCRouter, protectedProcedure } from \"@/server/api/trpc\";\nimport { TRPCError } from \"@trpc/server\";\nimport { z } from \"zod\";\n\nimport { getNamespaceByUser } from \"../auth\";\n\nimport { nanoid } from \"nanoid\";\n\nimport { Prisma } from \"@agentset/db\";\n\nconst commonInput = z.object({\n  namespaceId: z.string(),\n});\n\n// Helper function to replace uploadImage from S3\nconst uploadImage = async (buffer: Buffer, key: string, contentType: string) => {\n  // Convert buffer to File for Uploadthing\n  const file = new File([buffer], key, { type: contentType });\n  return await uploadAsset(file);\n};\n\nconst getHosting = async (\n  ctx: ProtectedProcedureContext,\n  input: z.infer<typeof commonInput>,\n) => {\n  const hosting = await ctx.db.hosting.findFirst({\n    where: {\n      namespace: {\n        id: input.namespaceId,\n        organization: {\n          members: { some: { userId: ctx.session.user.id } },\n        },\n      },\n    },\n    include: {\n      domain: true,\n    },\n  });\n\n  return hosting ?? null;\n};\n\n// TODO: only allow for pro users\nexport const hostingRouter = createTRPCRouter({\n  get: protectedProcedure.input(commonInput).query(async ({ ctx, input }) => {\n    return getHosting(ctx, input);\n  }),\n  enable: protectedProcedure\n    .input(commonInput)\n    .mutation(async ({ ctx, input }) => {\n      const namespace = await ctx.db.namespace.findUnique({\n        where: {\n          id: input.namespaceId,\n          organization: {\n            members: { some: { userId: ctx.session.user.id } },\n          },\n        },\n        select: {\n          id: true,\n          slug: true,\n          name: true,\n          hosting: true,\n          organization: {\n            select: {\n              id: true,\n\n              slug: true,\n            },\n          },\n        },\n      });\n\n      if (!namespace) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Namespace not found\",\n        });\n      }\n\n      if (namespace.hosting) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Hosting already enabled\",\n        });\n      }\n\n      let slug = `${namespace.slug}-${nanoid(10)}`;\n      while ((await ctx.db.hosting.count({ where: { slug } })) > 0) {\n        slug = `${namespace.slug}-${nanoid(10)}`;\n      }\n\n      return ctx.db.hosting.create({\n        data: {\n          // set default values\n          namespaceId: namespace.id,\n          title: namespace.name,\n          slug,\n          systemPrompt: DEFAULT_SYSTEM_PROMPT.compile(),\n        },\n      });\n    }),\n  update: protectedProcedure\n    .input(\n      commonInput.extend({\n        title: z.string().min(1).optional(),\n        slug: z.string().min(1).optional(),\n        logo: z.instanceof(Blob).nullish(),\n        protected: z.boolean().optional(),\n        allowedEmails: z\n          .array(z.string().email().trim().toLowerCase())\n          .optional(),\n        allowedEmailDomains: z\n          .array(z.string().trim().toLowerCase())\n          .optional(),\n        systemPrompt: z.string().optional(),\n        examplesQuestions: z.array(z.string()).max(4).optional(),\n        exampleSearchQueries: z.array(z.string()).max(4).optional(),\n        welcomeMessage: z.string().optional(),\n        citationMetadataPath: z.string().optional(),\n        searchEnabled: z.boolean().optional(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      const hosting = await getHosting(ctx, input);\n\n      if (!hosting) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Hosting not found\",\n        });\n      }\n\n      const newLogo = input.logo\n        ? await uploadImage(\n            Buffer.from(await input.logo.arrayBuffer()),\n            `namespaces/${prefixId(hosting.namespaceId, \"ns_\")}/hosting/logo_${nanoid(7)}`,\n            input.logo.type,\n          )\n        : input.logo === null\n          ? null\n          : undefined;\n\n      try {\n        const updatedHosting = await ctx.db.hosting.update({\n          where: {\n            id: hosting.id,\n          },\n          data: {\n            title: input.title,\n            ...(input.slug && { slug: input.slug }),\n            ...(newLogo !== undefined && {\n              logo: newLogo ? newLogo.url : null,\n            }),\n            protected: input.protected,\n            allowedEmails: input.allowedEmails ?? [],\n            allowedEmailDomains: input.allowedEmailDomains ?? [],\n            systemPrompt: input.systemPrompt,\n            exampleQuestions: input.examplesQuestions,\n            exampleSearchQueries: input.exampleSearchQueries,\n            welcomeMessage: input.welcomeMessage,\n            citationMetadataPath: input.citationMetadataPath,\n            searchEnabled: input.searchEnabled,\n          },\n        });\n\n        // Delete old logo if it exists\n        if ((newLogo || newLogo === null) && hosting.logo) {\n          await deleteAsset(hosting.logo.replace(`${env.ASSETS_UPLOADTHING_URL}/`, \"\"));\n        }\n\n        return updatedHosting;\n      } catch (error) {\n        if (\n          error instanceof Prisma.PrismaClientKnownRequestError &&\n          error.code === \"P2002\"\n        ) {\n          throw new TRPCError({\n            code: \"CONFLICT\",\n            message: `The slug \"${input.slug}\" is already in use.`,\n          });\n        } else {\n          throw new TRPCError({\n            code: \"INTERNAL_SERVER_ERROR\",\n            message:\n              error instanceof Error\n                ? error.message\n                : \"An unknown error occurred\",\n          });\n        }\n      }\n    }),\n});\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2635, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/schemas/api/ingest-job.ts"],"sourcesContent":["import z from \"@/lib/zod\";\r\n\r\nimport { IngestJobStatus } from \"@agentset/db\";\r\nimport { configSchema, ingestJobPayloadSchema } from \"@agentset/validation\";\r\n\r\nimport { paginationSchema } from \"./pagination\";\r\n\r\nexport const IngestJobStatusSchema = z\r\n  .nativeEnum(IngestJobStatus)\r\n  .describe(\"The status of the ingest job.\");\r\n\r\nexport const IngestJobSchema = z\r\n  .object({\r\n    id: z.string().describe(\"The unique ID of the ingest job.\"),\r\n    namespaceId: z.string().describe(\"The namespace ID of the ingest job.\"),\r\n    tenantId: z\r\n      .string()\r\n      .nullable()\r\n      .default(null)\r\n      .describe(\"The tenant ID of the ingest job.\"),\r\n    status: IngestJobStatusSchema,\r\n    error: z\r\n      .string()\r\n      .nullable()\r\n      .default(null)\r\n      .describe(\r\n        \"The error message of the ingest job. Only exists when the status is failed.\",\r\n      ),\r\n    payload: ingestJobPayloadSchema,\r\n    config: configSchema.nullable().default(null),\r\n    createdAt: z\r\n      .date()\r\n      .describe(\"The date and time the namespace was created.\"),\r\n    queuedAt: z\r\n      .date()\r\n      .nullable()\r\n      .describe(\"The date and time the ingest job was queued.\")\r\n      .default(null),\r\n    preProcessingAt: z\r\n      .date()\r\n      .nullable()\r\n      .describe(\"The date and time the ingest job was pre-processed.\")\r\n      .default(null),\r\n    processingAt: z\r\n      .date()\r\n      .nullable()\r\n      .describe(\"The date and time the ingest job was processed.\")\r\n      .default(null),\r\n    completedAt: z\r\n      .date()\r\n      .nullable()\r\n      .describe(\"The date and time the ingest job was completed.\")\r\n      .default(null),\r\n    failedAt: z\r\n      .date()\r\n      .nullable()\r\n      .describe(\"The date and time the ingest job failed.\")\r\n      .default(null),\r\n  })\r\n  .openapi({\r\n    title: \"Ingest Job\",\r\n  });\r\n\r\nexport const IngestJobsQuerySchema = z.object({\r\n  statuses: z\r\n    .array(IngestJobStatusSchema)\r\n    .optional()\r\n    .describe(\"Statuses to filter by.\"),\r\n  orderBy: z\r\n    .enum([\"createdAt\"])\r\n    .optional()\r\n    .default(\"createdAt\")\r\n    .describe(\"The field to order by. Default is `createdAt`.\"),\r\n  order: z\r\n    .enum([\"asc\", \"desc\"])\r\n    .optional()\r\n    .default(\"desc\")\r\n    .describe(\"The sort order. Default is `desc`.\"),\r\n});\r\n\r\nexport const getIngestionJobsSchema =\r\n  IngestJobsQuerySchema.merge(paginationSchema);\r\n\r\nexport const createIngestJobSchema = z.object({\r\n  payload: ingestJobPayloadSchema,\r\n  config: configSchema.optional(),\r\n});\r\n"],"names":[],"mappings":";;;;;;;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;;;;;AAEO,MAAM,wBAAwB,yIAAA,CAAA,UAAC,CACnC,UAAU,CAAC,6HAAA,CAAA,kBAAe,EAC1B,QAAQ,CAAC;AAEL,MAAM,kBAAkB,yIAAA,CAAA,UAAC,CAC7B,MAAM,CAAC;IACN,IAAI,yIAAA,CAAA,UAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACxB,aAAa,yIAAA,CAAA,UAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACjC,UAAU,yIAAA,CAAA,UAAC,CACR,MAAM,GACN,QAAQ,GACR,OAAO,CAAC,MACR,QAAQ,CAAC;IACZ,QAAQ;IACR,OAAO,yIAAA,CAAA,UAAC,CACL,MAAM,GACN,QAAQ,GACR,OAAO,CAAC,MACR,QAAQ,CACP;IAEJ,SAAS,2JAAA,CAAA,yBAAsB;IAC/B,QAAQ,2JAAA,CAAA,eAAY,CAAC,QAAQ,GAAG,OAAO,CAAC;IACxC,WAAW,yIAAA,CAAA,UAAC,CACT,IAAI,GACJ,QAAQ,CAAC;IACZ,UAAU,yIAAA,CAAA,UAAC,CACR,IAAI,GACJ,QAAQ,GACR,QAAQ,CAAC,gDACT,OAAO,CAAC;IACX,iBAAiB,yIAAA,CAAA,UAAC,CACf,IAAI,GACJ,QAAQ,GACR,QAAQ,CAAC,uDACT,OAAO,CAAC;IACX,cAAc,yIAAA,CAAA,UAAC,CACZ,IAAI,GACJ,QAAQ,GACR,QAAQ,CAAC,mDACT,OAAO,CAAC;IACX,aAAa,yIAAA,CAAA,UAAC,CACX,IAAI,GACJ,QAAQ,GACR,QAAQ,CAAC,mDACT,OAAO,CAAC;IACX,UAAU,yIAAA,CAAA,UAAC,CACR,IAAI,GACJ,QAAQ,GACR,QAAQ,CAAC,4CACT,OAAO,CAAC;AACb,GACC,OAAO,CAAC;IACP,OAAO;AACT;AAEK,MAAM,wBAAwB,yIAAA,CAAA,UAAC,CAAC,MAAM,CAAC;IAC5C,UAAU,yIAAA,CAAA,UAAC,CACR,KAAK,CAAC,uBACN,QAAQ,GACR,QAAQ,CAAC;IACZ,SAAS,yIAAA,CAAA,UAAC,CACP,IAAI,CAAC;QAAC;KAAY,EAClB,QAAQ,GACR,OAAO,CAAC,aACR,QAAQ,CAAC;IACZ,OAAO,yIAAA,CAAA,UAAC,CACL,IAAI,CAAC;QAAC;QAAO;KAAO,EACpB,QAAQ,GACR,OAAO,CAAC,QACR,QAAQ,CAAC;AACd;AAEO,MAAM,yBACX,sBAAsB,KAAK,CAAC,kJAAA,CAAA,mBAAgB;AAEvC,MAAM,wBAAwB,yIAAA,CAAA,UAAC,CAAC,MAAM,CAAC;IAC5C,SAAS,2JAAA,CAAA,yBAAsB;IAC/B,QAAQ,2JAAA,CAAA,eAAY,CAAC,QAAQ;AAC/B","debugId":null}},
    {"offset": {"line": 2691, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/services/ingest-jobs/create.ts"],"sourcesContent":["import { triggerIngestionJob } from \"@/lib/workflow\";\n\nimport type { IngestJob } from \"@agentset/db\";\nimport { db, IngestJobStatus } from \"@agentset/db\";\n\n// Helper function - Uploadthing doesn't have file existence check\n// Files are assumed to exist if they have a valid key/URL\nconst checkFileExists = async (key: string): Promise<boolean> => {\n  // For Uploadthing, we assume files exist if they have a valid key\n  // In a production app, you might want to store file metadata in your database\n  return Boolean(key);\n};\n\nexport const createIngestJob = async ({\n  namespaceId,\n  organizationId,\n  tenantId,\n  config,\n  payload,\n}: {\n  namespaceId: string;\n  organizationId: string;\n  tenantId?: string;\n  payload: IngestJob[\"payload\"];\n  config?: NonNullable<IngestJob[\"config\"]>;\n}) => {\n  let finalPayload: PrismaJson.IngestJobPayload | null = null;\n  if (payload.type === \"FILE\") {\n    finalPayload = {\n      type: \"FILE\",\n      ...(payload.name && { name: payload.name }),\n      fileUrl: payload.fileUrl,\n    };\n  } else if (payload.type === \"TEXT\") {\n    finalPayload = {\n      type: \"TEXT\",\n      ...(payload.name && { name: payload.name }),\n      text: payload.text,\n    };\n  } else if (payload.type === \"URLS\") {\n    const deduplicatedUrls = [...new Set(payload.urls)];\n    finalPayload = {\n      type: \"URLS\",\n      ...(payload.name && { name: payload.name }),\n      urls: deduplicatedUrls,\n    };\n  } else if (payload.type === \"MANAGED_FILE\") {\n    const exists = await checkFileExists(payload.key);\n    if (!exists) {\n      throw new Error(\"FILE_NOT_FOUND\");\n    }\n\n    finalPayload = {\n      type: \"MANAGED_FILE\",\n      ...(payload.name && { name: payload.name }),\n      key: payload.key,\n    };\n  } else if (payload.type === \"MANAGED_FILES\") {\n    const deduplicatedFiles: {\n      key: string;\n      name?: string | null | undefined;\n    }[] = [];\n    for (const file of payload.files) {\n      if (deduplicatedFiles.find((f) => f.key === file.key)) {\n        continue;\n      }\n      deduplicatedFiles.push(file);\n    }\n\n    const results = await Promise.all(\n      deduplicatedFiles.map((file) => checkFileExists(file.key)),\n    );\n\n    const missingKeys = results.filter((result) => !result);\n    if (missingKeys.length > 0) {\n      throw new Error(\"FILE_NOT_FOUND\");\n    }\n\n    finalPayload = {\n      type: \"MANAGED_FILES\",\n      ...(payload.name && { name: payload.name }),\n      files: deduplicatedFiles,\n    };\n  }\n\n  if (!finalPayload) {\n    throw new Error(\"INVALID_PAYLOAD\");\n  }\n\n  const [job] = await db.$transaction([\n    db.ingestJob.create({\n      data: {\n        namespace: { connect: { id: namespaceId } },\n        tenantId,\n        status: IngestJobStatus.QUEUED,\n        payload: finalPayload,\n        config,\n      },\n    }),\n    db.namespace.update({\n      where: { id: namespaceId },\n      data: {\n        totalIngestJobs: { increment: 1 },\n        organization: {\n          update: {\n            totalIngestJobs: { increment: 1 },\n          },\n        },\n      },\n      select: { id: true },\n    }),\n  ]);\n\n  const { workflowRunId } = await triggerIngestionJob({ jobId: job.id });\n\n  await db.ingestJob.update({\n    where: { id: job.id },\n    data: { workflowRunsIds: { push: workflowRunId } },\n    select: { id: true },\n  });\n\n  return job;\n};\n"],"names":[],"mappings":";;;AAAA;AAGA;AAAA;AAAA;;;AAEA,kEAAkE;AAClE,0DAA0D;AAC1D,MAAM,kBAAkB,OAAO;IAC7B,kEAAkE;IAClE,8EAA8E;IAC9E,OAAO,QAAQ;AACjB;AAEO,MAAM,kBAAkB,OAAO,EACpC,WAAW,EACX,cAAc,EACd,QAAQ,EACR,MAAM,EACN,OAAO,EAOR;IACC,IAAI,eAAmD;IACvD,IAAI,QAAQ,IAAI,KAAK,QAAQ;QAC3B,eAAe;YACb,MAAM;YACN,GAAI,QAAQ,IAAI,IAAI;gBAAE,MAAM,QAAQ,IAAI;YAAC,CAAC;YAC1C,SAAS,QAAQ,OAAO;QAC1B;IACF,OAAO,IAAI,QAAQ,IAAI,KAAK,QAAQ;QAClC,eAAe;YACb,MAAM;YACN,GAAI,QAAQ,IAAI,IAAI;gBAAE,MAAM,QAAQ,IAAI;YAAC,CAAC;YAC1C,MAAM,QAAQ,IAAI;QACpB;IACF,OAAO,IAAI,QAAQ,IAAI,KAAK,QAAQ;QAClC,MAAM,mBAAmB;eAAI,IAAI,IAAI,QAAQ,IAAI;SAAE;QACnD,eAAe;YACb,MAAM;YACN,GAAI,QAAQ,IAAI,IAAI;gBAAE,MAAM,QAAQ,IAAI;YAAC,CAAC;YAC1C,MAAM;QACR;IACF,OAAO,IAAI,QAAQ,IAAI,KAAK,gBAAgB;QAC1C,MAAM,SAAS,MAAM,gBAAgB,QAAQ,GAAG;QAChD,IAAI,CAAC,QAAQ;YACX,MAAM,IAAI,MAAM;QAClB;QAEA,eAAe;YACb,MAAM;YACN,GAAI,QAAQ,IAAI,IAAI;gBAAE,MAAM,QAAQ,IAAI;YAAC,CAAC;YAC1C,KAAK,QAAQ,GAAG;QAClB;IACF,OAAO,IAAI,QAAQ,IAAI,KAAK,iBAAiB;QAC3C,MAAM,oBAGA,EAAE;QACR,KAAK,MAAM,QAAQ,QAAQ,KAAK,CAAE;YAChC,IAAI,kBAAkB,IAAI,CAAC,CAAC,IAAM,EAAE,GAAG,KAAK,KAAK,GAAG,GAAG;gBACrD;YACF;YACA,kBAAkB,IAAI,CAAC;QACzB;QAEA,MAAM,UAAU,MAAM,QAAQ,GAAG,CAC/B,kBAAkB,GAAG,CAAC,CAAC,OAAS,gBAAgB,KAAK,GAAG;QAG1D,MAAM,cAAc,QAAQ,MAAM,CAAC,CAAC,SAAW,CAAC;QAChD,IAAI,YAAY,MAAM,GAAG,GAAG;YAC1B,MAAM,IAAI,MAAM;QAClB;QAEA,eAAe;YACb,MAAM;YACN,GAAI,QAAQ,IAAI,IAAI;gBAAE,MAAM,QAAQ,IAAI;YAAC,CAAC;YAC1C,OAAO;QACT;IACF;IAEA,IAAI,CAAC,cAAc;QACjB,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,CAAC,IAAI,GAAG,MAAM,+HAAA,CAAA,KAAE,CAAC,YAAY,CAAC;QAClC,+HAAA,CAAA,KAAE,CAAC,SAAS,CAAC,MAAM,CAAC;YAClB,MAAM;gBACJ,WAAW;oBAAE,SAAS;wBAAE,IAAI;oBAAY;gBAAE;gBAC1C;gBACA,QAAQ,6HAAA,CAAA,kBAAe,CAAC,MAAM;gBAC9B,SAAS;gBACT;YACF;QACF;QACA,+HAAA,CAAA,KAAE,CAAC,SAAS,CAAC,MAAM,CAAC;YAClB,OAAO;gBAAE,IAAI;YAAY;YACzB,MAAM;gBACJ,iBAAiB;oBAAE,WAAW;gBAAE;gBAChC,cAAc;oBACZ,QAAQ;wBACN,iBAAiB;4BAAE,WAAW;wBAAE;oBAClC;gBACF;YACF;YACA,QAAQ;gBAAE,IAAI;YAAK;QACrB;KACD;IAED,MAAM,EAAE,aAAa,EAAE,GAAG,MAAM,CAAA,GAAA,qIAAA,CAAA,sBAAmB,AAAD,EAAE;QAAE,OAAO,IAAI,EAAE;IAAC;IAEpE,MAAM,+HAAA,CAAA,KAAE,CAAC,SAAS,CAAC,MAAM,CAAC;QACxB,OAAO;YAAE,IAAI,IAAI,EAAE;QAAC;QACpB,MAAM;YAAE,iBAAiB;gBAAE,MAAM;YAAc;QAAE;QACjD,QAAQ;YAAE,IAAI;QAAK;IACrB;IAEA,OAAO;AACT","debugId":null}},
    {"offset": {"line": 2831, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/services/ingest-jobs/delete.ts"],"sourcesContent":["import { triggerDeleteIngestJob } from \"@/lib/workflow\";\r\n\r\nimport { db, IngestJobStatus } from \"@agentset/db\";\r\n\r\nexport const deleteIngestJob = async (jobId: string) => {\r\n  const job = await db.ingestJob.update({\r\n    where: { id: jobId },\r\n    data: {\r\n      status: IngestJobStatus.QUEUED_FOR_DELETE,\r\n    },\r\n  });\r\n\r\n  const { workflowRunId } = await triggerDeleteIngestJob({ jobId: job.id });\r\n  await db.ingestJob.update({\r\n    where: { id: job.id },\r\n    data: {\r\n      workflowRunsIds: { push: workflowRunId },\r\n    },\r\n    select: { id: true },\r\n  });\r\n\r\n  return job;\r\n};\r\n"],"names":[],"mappings":";;;AAAA;AAEA;AAAA;AAAA;;;AAEO,MAAM,kBAAkB,OAAO;IACpC,MAAM,MAAM,MAAM,+HAAA,CAAA,KAAE,CAAC,SAAS,CAAC,MAAM,CAAC;QACpC,OAAO;YAAE,IAAI;QAAM;QACnB,MAAM;YACJ,QAAQ,6HAAA,CAAA,kBAAe,CAAC,iBAAiB;QAC3C;IACF;IAEA,MAAM,EAAE,aAAa,EAAE,GAAG,MAAM,CAAA,GAAA,qIAAA,CAAA,yBAAsB,AAAD,EAAE;QAAE,OAAO,IAAI,EAAE;IAAC;IACvE,MAAM,+HAAA,CAAA,KAAE,CAAC,SAAS,CAAC,MAAM,CAAC;QACxB,OAAO;YAAE,IAAI,IAAI,EAAE;QAAC;QACpB,MAAM;YACJ,iBAAiB;gBAAE,MAAM;YAAc;QACzC;QACA,QAAQ;YAAE,IAAI;QAAK;IACrB;IAEA,OAAO;AACT","debugId":null}},
    {"offset": {"line": 2873, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/server/api/routers/ingest-jobs.ts"],"sourcesContent":["import { isProPlan } from \"@/lib/plans\";\r\nimport { triggerReIngestJob } from \"@/lib/workflow\";\r\nimport {\r\n  createIngestJobSchema,\r\n  getIngestionJobsSchema,\r\n} from \"@/schemas/api/ingest-job\";\r\nimport { createTRPCRouter, protectedProcedure } from \"@/server/api/trpc\";\r\nimport { createIngestJob } from \"@/services/ingest-jobs/create\";\r\nimport { deleteIngestJob } from \"@/services/ingest-jobs/delete\";\r\nimport { getPaginationArgs, paginateResults } from \"@/services/pagination\";\r\nimport { TRPCError } from \"@trpc/server\";\r\nimport { z } from \"zod\";\r\n\r\nimport { IngestJobStatus } from \"@agentset/db\";\r\n\r\nimport { getNamespaceByUser } from \"../auth\";\r\n\r\nexport const ingestJobRouter = createTRPCRouter({\r\n  all: protectedProcedure\r\n    .input(getIngestionJobsSchema.extend({ namespaceId: z.string() }))\r\n    .query(async ({ ctx, input }) => {\r\n      const namespace = await getNamespaceByUser(ctx, {\r\n        id: input.namespaceId,\r\n      });\r\n\r\n      if (!namespace) {\r\n        throw new TRPCError({ code: \"NOT_FOUND\" });\r\n      }\r\n\r\n      const ingestJobs = await ctx.db.ingestJob.findMany({\r\n        where: {\r\n          namespaceId: input.namespaceId,\r\n          ...(input.statuses &&\r\n            input.statuses.length > 0 && {\r\n              status: { in: input.statuses },\r\n            }),\r\n        },\r\n        orderBy: [\r\n          {\r\n            [input.orderBy]: input.order,\r\n          },\r\n        ],\r\n        ...getPaginationArgs(input),\r\n      });\r\n\r\n      return paginateResults(input, ingestJobs);\r\n    }),\r\n  ingest: protectedProcedure\r\n    .input(\r\n      createIngestJobSchema.extend({\r\n        namespaceId: z.string(),\r\n      }),\r\n    )\r\n    .mutation(async ({ ctx, input }) => {\r\n      const namespace = await getNamespaceByUser(ctx, {\r\n        id: input.namespaceId,\r\n      });\r\n\r\n      if (!namespace) {\r\n        throw new TRPCError({ code: \"NOT_FOUND\" });\r\n      }\r\n\r\n      const organization = await ctx.db.organization.findUnique({\r\n        where: { id: namespace.organizationId },\r\n      });\r\n\r\n      if (!organization) {\r\n        throw new TRPCError({ code: \"NOT_FOUND\" });\r\n      }\r\n\r\n      // if it's not a pro plan, check if the user has exceeded the limit\r\n      // pro plan is unlimited with usage based billing\r\n      if (\r\n        !isProPlan(organization.plan) &&\r\n        organization.totalPages >= organization.pagesLimit\r\n      ) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"You've reached the maximum number of pages.\",\r\n        });\r\n      }\r\n\r\n      return await createIngestJob({\r\n        payload: input.payload,\r\n        namespaceId: input.namespaceId,\r\n        organizationId: namespace.organizationId,\r\n        config: input.config,\r\n      });\r\n    }),\r\n  delete: protectedProcedure\r\n    .input(z.object({ jobId: z.string(), namespaceId: z.string() }))\r\n    .mutation(async ({ ctx, input }) => {\r\n      const namespace = await getNamespaceByUser(ctx, {\r\n        id: input.namespaceId,\r\n      });\r\n\r\n      if (!namespace) {\r\n        throw new TRPCError({ code: \"NOT_FOUND\" });\r\n      }\r\n\r\n      const ingestJob = await ctx.db.ingestJob.findUnique({\r\n        where: {\r\n          id: input.jobId,\r\n          namespaceId: namespace.id,\r\n        },\r\n        select: { id: true, status: true },\r\n      });\r\n\r\n      if (!ingestJob) {\r\n        throw new TRPCError({ code: \"NOT_FOUND\" });\r\n      }\r\n\r\n      if (\r\n        ingestJob.status === IngestJobStatus.QUEUED_FOR_DELETE ||\r\n        ingestJob.status === IngestJobStatus.DELETING\r\n      ) {\r\n        throw new TRPCError({ code: \"BAD_REQUEST\" });\r\n      }\r\n\r\n      const updatedIngestJob = await deleteIngestJob(ingestJob.id);\r\n\r\n      return updatedIngestJob;\r\n    }),\r\n  reIngest: protectedProcedure\r\n    .input(z.object({ jobId: z.string(), namespaceId: z.string() }))\r\n    .mutation(async ({ ctx, input }) => {\r\n      const namespace = await getNamespaceByUser(ctx, {\r\n        id: input.namespaceId,\r\n      });\r\n\r\n      if (!namespace) {\r\n        throw new TRPCError({ code: \"NOT_FOUND\" });\r\n      }\r\n\r\n      const ingestJob = await ctx.db.ingestJob.findUnique({\r\n        where: {\r\n          id: input.jobId,\r\n          namespaceId: namespace.id,\r\n        },\r\n        select: { id: true, status: true },\r\n      });\r\n\r\n      if (!ingestJob) {\r\n        throw new TRPCError({ code: \"NOT_FOUND\" });\r\n      }\r\n\r\n      if (\r\n        ingestJob.status === IngestJobStatus.PRE_PROCESSING ||\r\n        ingestJob.status === IngestJobStatus.PROCESSING\r\n      ) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"Job is already being processed\",\r\n        });\r\n      }\r\n\r\n      const { workflowRunId } = await triggerReIngestJob({\r\n        jobId: ingestJob.id,\r\n      });\r\n\r\n      await ctx.db.ingestJob.update({\r\n        where: { id: ingestJob.id },\r\n        data: {\r\n          status: IngestJobStatus.QUEUED_FOR_RESYNC,\r\n          queuedAt: new Date(),\r\n          workflowRunsIds: { push: workflowRunId },\r\n        },\r\n        select: { id: true },\r\n      });\r\n\r\n      return ingestJob;\r\n    }),\r\n});\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3061, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/embedding.ts"],"sourcesContent":["import { env } from \"@/env\";\n\nimport type { Namespace } from \"@agentset/db\";\n\nexport const getNamespaceEmbeddingModel = async (\n  namespace: Pick<Namespace, \"embeddingConfig\">,\n  type?: \"document\" | \"query\",\n) => {\n  const config = namespace.embeddingConfig;\n\n  if (!config) {\n    const { createOpenAI } = await import(\"@ai-sdk/openai\");\n\n    const defaultOpenAI = createOpenAI({\n      apiKey: env.DEFAULT_OPENAI_API_KEY,\n    });\n\n    return defaultOpenAI.textEmbeddingModel(\n      env.DEFAULT_OPENAI_EMBEDDING_MODEL || \"text-embedding-3-large\",\n    );\n  }\n\n  switch (config.provider) {\n    case \"AZURE_OPENAI\": {\n      const { createAzure } = await import(\"@ai-sdk/azure\");\n\n      const { apiKey, baseUrl, deployment, apiVersion } = config;\n      const azure = createAzure({\n        apiKey,\n        apiVersion,\n        baseURL: baseUrl,\n      });\n      return azure.textEmbeddingModel(deployment);\n    }\n\n    case \"OPENAI\": {\n      const { createOpenAI } = await import(\"@ai-sdk/openai\");\n\n      const { apiKey, model } = config;\n      const openai = createOpenAI({ apiKey });\n      return openai.textEmbeddingModel(model);\n    }\n\n    case \"VOYAGE\": {\n      const { createVoyage } = await import(\"voyage-ai-provider\");\n\n      const { apiKey, model } = config;\n      const voyage = createVoyage({ apiKey });\n      return voyage.textEmbeddingModel(model, {\n        inputType: type === \"document\" ? \"document\" : \"query\",\n      });\n    }\n\n    case \"GOOGLE\": {\n      const { createGoogleGenerativeAI } = await import(\"@ai-sdk/google\");\n\n      const { apiKey, model } = config;\n      const google = createGoogleGenerativeAI({ apiKey });\n      return google.textEmbeddingModel(model);\n    }\n\n    default: {\n      // This exhaustive check ensures TypeScript will error if a new provider\n      // is added without handling it in the switch statement\n      const _exhaustiveCheck: never = config;\n      throw new Error(`Unknown vector store provider: ${_exhaustiveCheck}`);\n    }\n  }\n};\n"],"names":[],"mappings":";;;AAAA;;AAIO,MAAM,6BAA6B,OACxC,WACA;IAEA,MAAM,SAAS,UAAU,eAAe;IAExC,IAAI,CAAC,QAAQ;QACX,MAAM,EAAE,YAAY,EAAE,GAAG;QAEzB,MAAM,gBAAgB,aAAa;YACjC,QAAQ,yHAAA,CAAA,MAAG,CAAC,sBAAsB;QACpC;QAEA,OAAO,cAAc,kBAAkB,CACrC,yHAAA,CAAA,MAAG,CAAC,8BAA8B,IAAI;IAE1C;IAEA,OAAQ,OAAO,QAAQ;QACrB,KAAK;YAAgB;gBACnB,MAAM,EAAE,WAAW,EAAE,GAAG;gBAExB,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,UAAU,EAAE,UAAU,EAAE,GAAG;gBACpD,MAAM,QAAQ,YAAY;oBACxB;oBACA;oBACA,SAAS;gBACX;gBACA,OAAO,MAAM,kBAAkB,CAAC;YAClC;QAEA,KAAK;YAAU;gBACb,MAAM,EAAE,YAAY,EAAE,GAAG;gBAEzB,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG;gBAC1B,MAAM,SAAS,aAAa;oBAAE;gBAAO;gBACrC,OAAO,OAAO,kBAAkB,CAAC;YACnC;QAEA,KAAK;YAAU;gBACb,MAAM,EAAE,YAAY,EAAE,GAAG;gBAEzB,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG;gBAC1B,MAAM,SAAS,aAAa;oBAAE;gBAAO;gBACrC,OAAO,OAAO,kBAAkB,CAAC,OAAO;oBACtC,WAAW,SAAS,aAAa,aAAa;gBAChD;YACF;QAEA,KAAK;YAAU;gBACb,MAAM,EAAE,wBAAwB,EAAE,GAAG;gBAErC,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG;gBAC1B,MAAM,SAAS,yBAAyB;oBAAE;gBAAO;gBACjD,OAAO,OAAO,kBAAkB,CAAC;YACnC;QAEA;YAAS;gBACP,wEAAwE;gBACxE,uDAAuD;gBACvD,MAAM,mBAA0B;gBAChC,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,kBAAkB;YACtE;IACF;AACF","debugId":null}},
    {"offset": {"line": 3215, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/vector-store/index.ts"],"sourcesContent":["import { env } from \"@/env\";\r\n\r\nimport type { Namespace } from \"@agentset/db\";\r\n\r\nexport const DIGNA_NAMESPACE_ID = \"cm7zzvk4w0001ri45hfl7lkyo\";\r\n\r\nexport const getNamespaceVectorStore = async (\r\n  namespace: Pick<Namespace, \"vectorStoreConfig\" | \"id\" | \"createdAt\">,\r\n  tenant?: string,\r\n) => {\r\n  const config = namespace.vectorStoreConfig;\r\n\r\n  const tenantId = tenant\r\n    ? `agentset:${namespace.id}:${tenant}`\r\n    : `agentset:${namespace.id === DIGNA_NAMESPACE_ID ? \"digna\" : namespace.id}`;\r\n\r\n  // TODO: handle different embedding models\r\n  if (!config) {\r\n    const { Pinecone } = await import(\"./pinecone\");\r\n    const shouldUseSecondary =\r\n      namespace.createdAt &&\r\n      (typeof namespace.createdAt === \"string\"\r\n        ? new Date(namespace.createdAt)\r\n        : namespace.createdAt\r\n      ).getTime() > 1747418241190 &&\r\n      !!env.SECONDARY_PINECONE_API_KEY &&\r\n      !!env.SECONDARY_PINECONE_HOST;\r\n\r\n    return new Pinecone({\r\n      apiKey: shouldUseSecondary\r\n        ? env.SECONDARY_PINECONE_API_KEY!\r\n        : env.DEFAULT_PINECONE_API_KEY,\r\n      indexHost: shouldUseSecondary\r\n        ? env.SECONDARY_PINECONE_HOST!\r\n        : env.DEFAULT_PINECONE_HOST,\r\n      namespace: tenantId,\r\n    });\r\n  }\r\n\r\n  switch (config.provider) {\r\n    case \"PINECONE\": {\r\n      const { Pinecone } = await import(\"./pinecone\");\r\n      const { apiKey, indexHost } = config;\r\n      return new Pinecone({ apiKey, indexHost, namespace: tenantId });\r\n    }\r\n\r\n    default: {\r\n      // This exhaustive check ensures TypeScript will error if a new provider\r\n      // is added without handling it in the switch statement\r\n      const _exhaustiveCheck: never = config.provider;\r\n      throw new Error(`Unknown vector store provider: ${_exhaustiveCheck}`);\r\n    }\r\n  }\r\n};\r\n\r\nexport { queryVectorStore } from \"./parse\";\r\n"],"names":[],"mappings":";;;;AAAA;AAuDA;;AAnDO,MAAM,qBAAqB;AAE3B,MAAM,0BAA0B,OACrC,WACA;IAEA,MAAM,SAAS,UAAU,iBAAiB;IAE1C,MAAM,WAAW,SACb,CAAC,SAAS,EAAE,UAAU,EAAE,CAAC,CAAC,EAAE,QAAQ,GACpC,CAAC,SAAS,EAAE,UAAU,EAAE,KAAK,qBAAqB,UAAU,UAAU,EAAE,EAAE;IAE9E,0CAA0C;IAC1C,IAAI,CAAC,QAAQ;QACX,MAAM,EAAE,QAAQ,EAAE,GAAG;QACrB,MAAM,qBACJ,UAAU,SAAS,IACnB,CAAC,OAAO,UAAU,SAAS,KAAK,WAC5B,IAAI,KAAK,UAAU,SAAS,IAC5B,UAAU,SAAS,AACvB,EAAE,OAAO,KAAK,iBACd,CAAC,CAAC,yHAAA,CAAA,MAAG,CAAC,0BAA0B,IAChC,CAAC,CAAC,yHAAA,CAAA,MAAG,CAAC,uBAAuB;QAE/B,OAAO,IAAI,SAAS;YAClB,QAAQ,qBACJ,yHAAA,CAAA,MAAG,CAAC,0BAA0B,GAC9B,yHAAA,CAAA,MAAG,CAAC,wBAAwB;YAChC,WAAW,qBACP,yHAAA,CAAA,MAAG,CAAC,uBAAuB,GAC3B,yHAAA,CAAA,MAAG,CAAC,qBAAqB;YAC7B,WAAW;QACb;IACF;IAEA,OAAQ,OAAO,QAAQ;QACrB,KAAK;YAAY;gBACf,MAAM,EAAE,QAAQ,EAAE,GAAG;gBACrB,MAAM,EAAE,MAAM,EAAE,SAAS,EAAE,GAAG;gBAC9B,OAAO,IAAI,SAAS;oBAAE;oBAAQ;oBAAW,WAAW;gBAAS;YAC/D;QAEA;YAAS;gBACP,wEAAwE;gBACxE,uDAAuD;gBACvD,MAAM,mBAA0B,OAAO,QAAQ;gBAC/C,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,kBAAkB;YACtE;IACF;AACF","debugId":null}},
    {"offset": {"line": 3263, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/functions.ts"],"sourcesContent":["// chunk an array into smaller arrays of a given size\r\nexport const chunkArray = <T>(array: T[], size: number) => {\r\n  return Array.from({ length: Math.ceil(array.length / size) }, (_, i) =>\r\n    array.slice(i * size, i * size + size),\r\n  );\r\n};\r\n\r\nexport const filterFalsy = <T>(arr: T[]): NonNullable<T>[] =>\r\n  arr.filter(Boolean) as NonNullable<T>[];\r\n"],"names":[],"mappings":"AAAA,qDAAqD;;;;;AAC9C,MAAM,aAAa,CAAI,OAAY;IACxC,OAAO,MAAM,IAAI,CAAC;QAAE,QAAQ,KAAK,IAAI,CAAC,MAAM,MAAM,GAAG;IAAM,GAAG,CAAC,GAAG,IAChE,MAAM,KAAK,CAAC,IAAI,MAAM,IAAI,OAAO;AAErC;AAEO,MAAM,cAAc,CAAI,MAC7B,IAAI,MAAM,CAAC","debugId":null}},
    {"offset": {"line": 3352, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/error.ts"],"sourcesContent":["type Success<T> = {\r\n  data: T;\r\n  error: null;\r\n};\r\n\r\ntype Failure<E> = {\r\n  data: null;\r\n  error: E;\r\n};\r\n\r\ntype Result<T, E = Error> = Success<T> | Failure<E>;\r\n\r\ntype MaybePromise<T> = T | Promise<T>;\r\n\r\nexport function tryCatch<T, E = Error>(\r\n  arg: Promise<T> | (() => MaybePromise<T>),\r\n): Result<T, E> | Promise<Result<T, E>> {\r\n  if (typeof arg === \"function\") {\r\n    try {\r\n      const result = arg();\r\n\r\n      if (result instanceof Promise) {\r\n        return tryCatch(result);\r\n      }\r\n\r\n      return { data: result, error: null };\r\n    } catch (error) {\r\n      return { data: null, error: error as E };\r\n    }\r\n  }\r\n\r\n  return arg\r\n    .then((data) => ({ data, error: null }))\r\n    .catch((error) => ({\r\n      data: null,\r\n      error: error as E,\r\n    }));\r\n}\r\n"],"names":[],"mappings":";;;AAcO,SAAS,SACd,GAAyC;IAEzC,IAAI,OAAO,QAAQ,YAAY;QAC7B,IAAI;YACF,MAAM,SAAS;YAEf,IAAI,kBAAkB,SAAS;gBAC7B,OAAO,SAAS;YAClB;YAEA,OAAO;gBAAE,MAAM;gBAAQ,OAAO;YAAK;QACrC,EAAE,OAAO,OAAO;YACd,OAAO;gBAAE,MAAM;gBAAM,OAAO;YAAW;QACzC;IACF;IAEA,OAAO,IACJ,IAAI,CAAC,CAAC,OAAS,CAAC;YAAE;YAAM,OAAO;QAAK,CAAC,GACrC,KAAK,CAAC,CAAC,QAAU,CAAC;YACjB,MAAM;YACN,OAAO;QACT,CAAC;AACL","debugId":null}},
    {"offset": {"line": 3387, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/rerank/cohere.ts"],"sourcesContent":["import type { BaseNode, Metadata } from \"llamaindex\";\r\nimport { env } from \"@/env\";\r\nimport { CohereClient } from \"cohere-ai\";\r\nimport { MetadataMode } from \"llamaindex\";\r\n\r\nimport { tryCatch } from \"../error\";\r\n\r\ninterface BaseRerankDocument {\r\n  node: BaseNode<Metadata>;\r\n}\r\n\r\ninterface RerankOptions {\r\n  limit: number;\r\n  query: string;\r\n  cohereApiKey?: string;\r\n}\r\n\r\nexport type RerankResult<T extends BaseRerankDocument> = T & {\r\n  rerankScore?: number;\r\n};\r\n\r\nexport async function rerankResults<T extends BaseRerankDocument>(\r\n  results: T[],\r\n  options: RerankOptions,\r\n): Promise<RerankResult<T>[]> {\r\n  if (!results.length) return results;\r\n\r\n  const client = new CohereClient({\r\n    token: options.cohereApiKey || env.DEFAULT_COHERE_API_KEY,\r\n  });\r\n\r\n  const { data: rerankResults, error } = await tryCatch(\r\n    client.v2.rerank({\r\n      documents: results.map((doc) => doc.node.getContent(MetadataMode.NONE)),\r\n      query: options.query,\r\n      topN: options.limit,\r\n      model: \"rerank-v3.5\",\r\n      returnDocuments: false,\r\n    }),\r\n  );\r\n\r\n  if (error) {\r\n    console.error(\"Cohere rerank failed:\", error);\r\n    return results;\r\n  }\r\n\r\n  // TODO: track usage with rerankResults.meta\r\n  return rerankResults.results\r\n    .map((result) => {\r\n      // Use the index from the result to find the original document\r\n      const originalIndex = result.index;\r\n      const originalDoc = results[originalIndex];\r\n\r\n      if (!originalDoc) {\r\n        return null;\r\n      }\r\n\r\n      return {\r\n        ...originalDoc,\r\n        rerankScore: result.relevanceScore,\r\n      };\r\n    })\r\n    .filter(Boolean) as RerankResult<T>[];\r\n}\r\n"],"names":[],"mappings":";;;AACA;AACA;AACA;AAAA;AAEA;;;;;AAgBO,eAAe,cACpB,OAAY,EACZ,OAAsB;IAEtB,IAAI,CAAC,QAAQ,MAAM,EAAE,OAAO;IAE5B,MAAM,SAAS,IAAI,qIAAA,CAAA,eAAY,CAAC;QAC9B,OAAO,QAAQ,YAAY,IAAI,yHAAA,CAAA,MAAG,CAAC,sBAAsB;IAC3D;IAEA,MAAM,EAAE,MAAM,aAAa,EAAE,KAAK,EAAE,GAAG,MAAM,CAAA,GAAA,kIAAA,CAAA,WAAQ,AAAD,EAClD,OAAO,EAAE,CAAC,MAAM,CAAC;QACf,WAAW,QAAQ,GAAG,CAAC,CAAC,MAAQ,IAAI,IAAI,CAAC,UAAU,CAAC,+JAAA,CAAA,eAAY,CAAC,IAAI;QACrE,OAAO,QAAQ,KAAK;QACpB,MAAM,QAAQ,KAAK;QACnB,OAAO;QACP,iBAAiB;IACnB;IAGF,IAAI,OAAO;QACT,QAAQ,KAAK,CAAC,yBAAyB;QACvC,OAAO;IACT;IAEA,4CAA4C;IAC5C,OAAO,cAAc,OAAO,CACzB,GAAG,CAAC,CAAC;QACJ,8DAA8D;QAC9D,MAAM,gBAAgB,OAAO,KAAK;QAClC,MAAM,cAAc,OAAO,CAAC,cAAc;QAE1C,IAAI,CAAC,aAAa;YAChB,OAAO;QACT;QAEA,OAAO;YACL,GAAG,WAAW;YACd,aAAa,OAAO,cAAc;QACpC;IACF,GACC,MAAM,CAAC;AACZ","debugId":null}},
    {"offset": {"line": 3435, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/vector-store/parse.ts"],"sourcesContent":["import type { BaseNode, Metadata } from \"llamaindex\";\r\nimport { metadataDictToNode } from \"@llamaindex/core/vector-store\";\r\nimport { embed } from \"ai\";\r\nimport { MetadataMode } from \"llamaindex\";\r\n\r\nimport type { Namespace } from \"@agentset/db\";\r\n\r\nimport { getNamespaceVectorStore } from \".\";\r\nimport { getNamespaceEmbeddingModel } from \"../embedding\";\r\nimport { filterFalsy } from \"../functions\";\r\nimport { rerankResults } from \"../rerank/cohere\";\r\n\r\ntype Result = {\r\n  id: string;\r\n  node: BaseNode<Metadata>;\r\n  score?: number;\r\n  rerankScore?: number;\r\n};\r\n\r\nexport const formatResults = (\r\n  results: Result[],\r\n  {\r\n    includeMetadata,\r\n    includeRelationships,\r\n  }: { includeMetadata?: boolean; includeRelationships?: boolean },\r\n) => {\r\n  return results.map((result) => {\r\n    return {\r\n      id: result.id,\r\n      text: result.node.getContent(MetadataMode.NONE),\r\n      metadata: includeMetadata ? result.node.metadata : undefined,\r\n      relationships: includeRelationships\r\n        ? result.node.relationships\r\n        : undefined,\r\n      score: result.score,\r\n      rerankScore: result.rerankScore,\r\n    };\r\n  });\r\n};\r\n\r\nexport type QueryVectorStoreOptions = {\r\n  query: string;\r\n  topK: number;\r\n  tenantId?: string;\r\n  minScore?: number;\r\n  filter?: Record<string, string>;\r\n  includeMetadata?: boolean;\r\n  includeRelationships?: boolean;\r\n  rerankLimit?: number;\r\n  rerank?: boolean;\r\n};\r\n\r\nexport const queryVectorStore = async (\r\n  namespace: Pick<\r\n    Namespace,\r\n    \"id\" | \"vectorStoreConfig\" | \"embeddingConfig\" | \"createdAt\"\r\n  >,\r\n  options: QueryVectorStoreOptions,\r\n) => {\r\n  // TODO: if the embedding model is managed, track the usage\r\n  const [embeddingModel, vectorStore] = await Promise.all([\r\n    getNamespaceEmbeddingModel(namespace, \"query\"),\r\n    getNamespaceVectorStore(namespace, options.tenantId),\r\n  ]);\r\n\r\n  const embedding = await embed({\r\n    model: embeddingModel,\r\n    value: options.query,\r\n  });\r\n\r\n  // TODO: track usage\r\n  let { matches } = await vectorStore.query({\r\n    vector: embedding.embedding,\r\n    topK: options.topK,\r\n    filter: options.filter,\r\n    includeMetadata: true,\r\n  });\r\n\r\n  if (options.minScore !== undefined) {\r\n    matches = matches.filter(\r\n      (match) => match.score && match.score >= options.minScore!,\r\n    );\r\n  }\r\n\r\n  const parsedResults = filterFalsy(\r\n    matches.map((match) => {\r\n      const nodeContent = match.metadata?._node_content;\r\n      if (!nodeContent) return null;\r\n\r\n      try {\r\n        return {\r\n          id: match.id,\r\n          score: match.score,\r\n          node: metadataDictToNode(match.metadata!),\r\n        };\r\n      } catch (e) {\r\n        console.error(e);\r\n        return null;\r\n      }\r\n    }),\r\n  );\r\n\r\n  if (matches.length > 0 && parsedResults.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  // If re-ranking is enabled and we have a query, perform reranking\r\n  let rerankedResults: typeof parsedResults | null = null;\r\n  if (options.rerank) {\r\n    rerankedResults = await rerankResults(parsedResults, {\r\n      limit: options.rerankLimit || options.topK,\r\n      query: options.query,\r\n    });\r\n  }\r\n\r\n  return {\r\n    query: options.query,\r\n    unorderedIds: rerankedResults\r\n      ? parsedResults.map((result) => result.id)\r\n      : null,\r\n    results: formatResults(rerankedResults ?? parsedResults, {\r\n      includeMetadata: options.includeMetadata,\r\n      includeRelationships: options.includeRelationships,\r\n    }),\r\n  };\r\n};\r\n\r\nexport type QueryVectorStoreResult = NonNullable<\r\n  Awaited<ReturnType<typeof queryVectorStore>>\r\n>;\r\n"],"names":[],"mappings":";;;;AACA;AACA;AACA;AAAA;AAIA;AAAA;AACA;AACA;AACA;;;;;;;;AASO,MAAM,gBAAgB,CAC3B,SACA,EACE,eAAe,EACf,oBAAoB,EAC0C;IAEhE,OAAO,QAAQ,GAAG,CAAC,CAAC;QAClB,OAAO;YACL,IAAI,OAAO,EAAE;YACb,MAAM,OAAO,IAAI,CAAC,UAAU,CAAC,+JAAA,CAAA,eAAY,CAAC,IAAI;YAC9C,UAAU,kBAAkB,OAAO,IAAI,CAAC,QAAQ,GAAG;YACnD,eAAe,uBACX,OAAO,IAAI,CAAC,aAAa,GACzB;YACJ,OAAO,OAAO,KAAK;YACnB,aAAa,OAAO,WAAW;QACjC;IACF;AACF;AAcO,MAAM,mBAAmB,OAC9B,WAIA;IAEA,2DAA2D;IAC3D,MAAM,CAAC,gBAAgB,YAAY,GAAG,MAAM,QAAQ,GAAG,CAAC;QACtD,CAAA,GAAA,sIAAA,CAAA,6BAA0B,AAAD,EAAE,WAAW;QACtC,CAAA,GAAA,qKAAA,CAAA,0BAAuB,AAAD,EAAE,WAAW,QAAQ,QAAQ;KACpD;IAED,MAAM,YAAY,MAAM,CAAA,GAAA,oJAAA,CAAA,QAAK,AAAD,EAAE;QAC5B,OAAO;QACP,OAAO,QAAQ,KAAK;IACtB;IAEA,oBAAoB;IACpB,IAAI,EAAE,OAAO,EAAE,GAAG,MAAM,YAAY,KAAK,CAAC;QACxC,QAAQ,UAAU,SAAS;QAC3B,MAAM,QAAQ,IAAI;QAClB,QAAQ,QAAQ,MAAM;QACtB,iBAAiB;IACnB;IAEA,IAAI,QAAQ,QAAQ,KAAK,WAAW;QAClC,UAAU,QAAQ,MAAM,CACtB,CAAC,QAAU,MAAM,KAAK,IAAI,MAAM,KAAK,IAAI,QAAQ,QAAQ;IAE7D;IAEA,MAAM,gBAAgB,CAAA,GAAA,sIAAA,CAAA,cAAW,AAAD,EAC9B,QAAQ,GAAG,CAAC,CAAC;QACX,MAAM,cAAc,MAAM,QAAQ,EAAE;QACpC,IAAI,CAAC,aAAa,OAAO;QAEzB,IAAI;YACF,OAAO;gBACL,IAAI,MAAM,EAAE;gBACZ,OAAO,MAAM,KAAK;gBAClB,MAAM,CAAA,GAAA,wKAAA,CAAA,qBAAkB,AAAD,EAAE,MAAM,QAAQ;YACzC;QACF,EAAE,OAAO,GAAG;YACV,QAAQ,KAAK,CAAC;YACd,OAAO;QACT;IACF;IAGF,IAAI,QAAQ,MAAM,GAAG,KAAK,cAAc,MAAM,KAAK,GAAG;QACpD,OAAO;IACT;IAEA,kEAAkE;IAClE,IAAI,kBAA+C;IACnD,IAAI,QAAQ,MAAM,EAAE;QAClB,kBAAkB,MAAM,CAAA,GAAA,6IAAA,CAAA,gBAAa,AAAD,EAAE,eAAe;YACnD,OAAO,QAAQ,WAAW,IAAI,QAAQ,IAAI;YAC1C,OAAO,QAAQ,KAAK;QACtB;IACF;IAEA,OAAO;QACL,OAAO,QAAQ,KAAK;QACpB,cAAc,kBACV,cAAc,GAAG,CAAC,CAAC,SAAW,OAAO,EAAE,IACvC;QACJ,SAAS,cAAc,mBAAmB,eAAe;YACvD,iBAAiB,QAAQ,eAAe;YACxC,sBAAsB,QAAQ,oBAAoB;QACpD;IACF;AACF","debugId":null}},
    {"offset": {"line": 3537, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/services/namespaces/validate.ts"],"sourcesContent":["import { getNamespaceEmbeddingModel } from \"@/lib/embedding\";\r\nimport { getNamespaceVectorStore } from \"@/lib/vector-store\";\r\nimport { embed } from \"ai\";\r\n\r\nimport type { Namespace } from \"@agentset/db\";\r\n\r\nconst modelToDimensions: Record<\r\n  PrismaJson.NamespaceEmbeddingConfig[\"model\"],\r\n  number\r\n> = {\r\n  // openai\r\n  \"text-embedding-3-large\": 3072,\r\n  \"text-embedding-3-small\": 1536,\r\n\r\n  // google\r\n  \"text-embedding-004\": 768,\r\n\r\n  // voyage\r\n  \"voyage-3-large\": 1024,\r\n  \"voyage-3\": 1024,\r\n  \"voyage-3-lite\": 512,\r\n  \"voyage-code-3\": 1024,\r\n  \"voyage-finance-2\": 1024,\r\n  \"voyage-law-2\": 1024,\r\n};\r\n\r\nexport const validateVectorStoreConfig = async (\r\n  vectorStoreConfig?: Namespace[\"vectorStoreConfig\"],\r\n  embeddingConfig?: Namespace[\"embeddingConfig\"],\r\n) => {\r\n  if (!vectorStoreConfig) {\r\n    return {\r\n      success: true as const,\r\n    };\r\n  }\r\n\r\n  const v = await getNamespaceVectorStore({\r\n    id: \"\",\r\n    vectorStoreConfig,\r\n    createdAt: new Date(),\r\n  });\r\n\r\n  try {\r\n    const dimensions = await v.getDimensions();\r\n    if (embeddingConfig) {\r\n      const embeddingDimensions = modelToDimensions[embeddingConfig.model];\r\n      if (dimensions !== embeddingDimensions) {\r\n        return {\r\n          success: false as const,\r\n          error: `Embedding dimensions mismatch: ${dimensions} !== ${embeddingDimensions}`,\r\n        };\r\n      }\r\n    }\r\n\r\n    return {\r\n      success: true as const,\r\n    };\r\n  } catch {\r\n    return {\r\n      success: false as const,\r\n      error:\r\n        \"Failed to validate vector store config, make sure the API key is valid\",\r\n    };\r\n  }\r\n};\r\n\r\nexport const validateEmbeddingModel = async (\r\n  embeddingConfig?: Namespace[\"embeddingConfig\"],\r\n) => {\r\n  if (!embeddingConfig) {\r\n    return {\r\n      success: true as const,\r\n    };\r\n  }\r\n\r\n  const model = await getNamespaceEmbeddingModel({ embeddingConfig });\r\n\r\n  try {\r\n    await embed({\r\n      model,\r\n      value: \"Hello, world!\",\r\n    });\r\n\r\n    return {\r\n      success: true as const,\r\n    };\r\n  } catch {\r\n    return {\r\n      success: false as const,\r\n      error:\r\n        \"Failed to validate embedding model, make sure the API key is valid\",\r\n    };\r\n  }\r\n};\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AAAA;AACA;;;;AAIA,MAAM,oBAGF;IACF,SAAS;IACT,0BAA0B;IAC1B,0BAA0B;IAE1B,SAAS;IACT,sBAAsB;IAEtB,SAAS;IACT,kBAAkB;IAClB,YAAY;IACZ,iBAAiB;IACjB,iBAAiB;IACjB,oBAAoB;IACpB,gBAAgB;AAClB;AAEO,MAAM,4BAA4B,OACvC,mBACA;IAEA,IAAI,CAAC,mBAAmB;QACtB,OAAO;YACL,SAAS;QACX;IACF;IAEA,MAAM,IAAI,MAAM,CAAA,GAAA,qKAAA,CAAA,0BAAuB,AAAD,EAAE;QACtC,IAAI;QACJ;QACA,WAAW,IAAI;IACjB;IAEA,IAAI;QACF,MAAM,aAAa,MAAM,EAAE,aAAa;QACxC,IAAI,iBAAiB;YACnB,MAAM,sBAAsB,iBAAiB,CAAC,gBAAgB,KAAK,CAAC;YACpE,IAAI,eAAe,qBAAqB;gBACtC,OAAO;oBACL,SAAS;oBACT,OAAO,CAAC,+BAA+B,EAAE,WAAW,KAAK,EAAE,qBAAqB;gBAClF;YACF;QACF;QAEA,OAAO;YACL,SAAS;QACX;IACF,EAAE,OAAM;QACN,OAAO;YACL,SAAS;YACT,OACE;QACJ;IACF;AACF;AAEO,MAAM,yBAAyB,OACpC;IAEA,IAAI,CAAC,iBAAiB;QACpB,OAAO;YACL,SAAS;QACX;IACF;IAEA,MAAM,QAAQ,MAAM,CAAA,GAAA,sIAAA,CAAA,6BAA0B,AAAD,EAAE;QAAE;IAAgB;IAEjE,IAAI;QACF,MAAM,CAAA,GAAA,oJAAA,CAAA,QAAK,AAAD,EAAE;YACV;YACA,OAAO;QACT;QAEA,OAAO;YACL,SAAS;QACX;IACF,EAAE,OAAM;QACN,OAAO;YACL,SAAS;YACT,OACE;QACJ;IACF;AACF","debugId":null}},
    {"offset": {"line": 3624, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/server/api/routers/namespaces.ts"],"sourcesContent":["import type { ProtectedProcedureContext } from \"@/server/api/trpc\";\r\nimport { createTRPCRouter, protectedProcedure } from \"@/server/api/trpc\";\r\nimport {\r\n  validateEmbeddingModel,\r\n  validateVectorStoreConfig,\r\n} from \"@/services/namespaces/validate\";\r\nimport { TRPCError } from \"@trpc/server\";\r\nimport { z } from \"zod\";\r\n\r\nimport { EmbeddingConfigSchema, VectorStoreSchema } from \"@agentset/validation\";\r\n\r\nconst validateIsMember = async (\r\n  ctx: ProtectedProcedureContext,\r\n  orgId: string,\r\n  roles?: string[],\r\n) => {\r\n  const member = await ctx.db.member.findFirst({\r\n    where: {\r\n      userId: ctx.session.user.id,\r\n      organizationId: orgId,\r\n    },\r\n    select: {\r\n      id: true,\r\n      role: true,\r\n    },\r\n  });\r\n\r\n  if (!member) {\r\n    throw new TRPCError({ code: \"UNAUTHORIZED\" });\r\n  }\r\n\r\n  if (roles && !roles.includes(member.role)) {\r\n    throw new TRPCError({ code: \"UNAUTHORIZED\" });\r\n  }\r\n};\r\n\r\nexport const namespaceRouter = createTRPCRouter({\r\n  getOrgNamespaces: protectedProcedure\r\n    .input(\r\n      z.object({\r\n        orgId: z.string(),\r\n      }),\r\n    )\r\n    .query(async ({ ctx, input }) => {\r\n      await validateIsMember(ctx, input.orgId);\r\n\r\n      const namespaces = await ctx.db.namespace.findMany({\r\n        where: {\r\n          organizationId: input.orgId,\r\n        },\r\n      });\r\n\r\n      return namespaces;\r\n    }),\r\n  getNamespaceBySlug: protectedProcedure\r\n    .input(z.object({ orgSlug: z.string(), slug: z.string() }))\r\n    .query(async ({ ctx, input }) => {\r\n      const namespace = await ctx.db.namespace.findFirst({\r\n        where: {\r\n          slug: input.slug,\r\n          organization: {\r\n            slug: input.orgSlug,\r\n            members: { some: { userId: ctx.session.user.id } },\r\n          },\r\n        },\r\n      });\r\n\r\n      return namespace;\r\n    }),\r\n  getOnboardingStatus: protectedProcedure\r\n    .input(z.object({ orgSlug: z.string(), slug: z.string() }))\r\n    .query(async ({ ctx, input }) => {\r\n      const namespace = await ctx.db.namespace.findFirst({\r\n        where: {\r\n          slug: input.slug,\r\n          organization: {\r\n            slug: input.orgSlug,\r\n            members: { some: { userId: ctx.session.user.id } },\r\n          },\r\n        },\r\n        select: {\r\n          totalIngestJobs: true,\r\n          totalPlaygroundUsage: true,\r\n          organization: {\r\n            select: {\r\n              apiKeys: {\r\n                take: 1,\r\n                select: {\r\n                  id: true,\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!namespace) {\r\n        throw new TRPCError({ code: \"NOT_FOUND\" });\r\n      }\r\n\r\n      return {\r\n        ingestDocuments: namespace.totalIngestJobs > 0,\r\n        playground: namespace.totalPlaygroundUsage > 0,\r\n        createApiKey: namespace.organization.apiKeys.length > 0,\r\n      };\r\n    }),\r\n  checkSlug: protectedProcedure\r\n    .input(\r\n      z.object({\r\n        orgId: z.string(),\r\n        slug: z.string(),\r\n      }),\r\n    )\r\n    .query(async ({ ctx, input }) => {\r\n      const namespace = await ctx.db.namespace.findUnique({\r\n        where: {\r\n          organizationId_slug: {\r\n            slug: input.slug,\r\n            organizationId: input.orgId,\r\n          },\r\n        },\r\n      });\r\n\r\n      return !!namespace;\r\n    }),\r\n  createNamespace: protectedProcedure\r\n    .input(\r\n      z.object({\r\n        orgId: z.string(),\r\n        name: z.string(),\r\n        slug: z.string(),\r\n        embeddingConfig: EmbeddingConfigSchema.optional(),\r\n        vectorStoreConfig: VectorStoreSchema.optional(),\r\n      }),\r\n    )\r\n    .mutation(async ({ ctx, input }) => {\r\n      await validateIsMember(ctx, input.orgId, [\"admin\", \"owner\"]);\r\n\r\n      const { success: isValidEmbedding, error: embeddingError } =\r\n        await validateEmbeddingModel(input.embeddingConfig);\r\n      if (!isValidEmbedding) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: embeddingError,\r\n        });\r\n      }\r\n\r\n      const { success: isValidVectorStore, error: vectorStoreError } =\r\n        await validateVectorStoreConfig(\r\n          input.vectorStoreConfig,\r\n          input.embeddingConfig,\r\n        );\r\n      if (!isValidVectorStore) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: vectorStoreError,\r\n        });\r\n      }\r\n\r\n      const [namespace] = await ctx.db.$transaction([\r\n        ctx.db.namespace.create({\r\n          data: {\r\n            name: input.name,\r\n            slug: input.slug,\r\n            organizationId: input.orgId,\r\n            embeddingConfig: input.embeddingConfig,\r\n            vectorStoreConfig: input.vectorStoreConfig,\r\n          },\r\n        }),\r\n        ctx.db.organization.update({\r\n          where: { id: input.orgId },\r\n          data: { totalNamespaces: { increment: 1 } },\r\n        }),\r\n      ]);\r\n\r\n      return namespace;\r\n    }),\r\n});\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3804, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/stripe/cancel-subscription.ts"],"sourcesContent":["import { stripe } from \".\";\r\n\r\nexport async function cancelSubscription(customer?: string) {\r\n  if (!customer) return;\r\n\r\n  try {\r\n    const subscriptionId = await stripe.subscriptions\r\n      .list({\r\n        customer,\r\n      })\r\n      .then((res) => res.data[0]?.id);\r\n\r\n    if (subscriptionId) {\r\n      return await stripe.subscriptions.update(subscriptionId, {\r\n        cancel_at_period_end: true,\r\n        cancellation_details: {\r\n          comment: \"Customer deleted their Agentset organization.\",\r\n        },\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Error cancelling Stripe subscription\", error);\r\n    return;\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;AAAA;;AAEO,eAAe,mBAAmB,QAAiB;IACxD,IAAI,CAAC,UAAU;IAEf,IAAI;QACF,MAAM,iBAAiB,MAAM,4IAAA,CAAA,SAAM,CAAC,aAAa,CAC9C,IAAI,CAAC;YACJ;QACF,GACC,IAAI,CAAC,CAAC,MAAQ,IAAI,IAAI,CAAC,EAAE,EAAE;QAE9B,IAAI,gBAAgB;YAClB,OAAO,MAAM,4IAAA,CAAA,SAAM,CAAC,aAAa,CAAC,MAAM,CAAC,gBAAgB;gBACvD,sBAAsB;gBACtB,sBAAsB;oBACpB,SAAS;gBACX;YACF;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,GAAG,CAAC,wCAAwC;QACpD;IACF;AACF","debugId":null}},
    {"offset": {"line": 3834, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/services/organizations/delete.ts"],"sourcesContent":["import { cancelSubscription } from \"@/lib/stripe/cancel-subscription\";\r\nimport { triggerDeleteNamespace } from \"@/lib/workflow\";\r\n\r\nimport { db, OrganizationStatus } from \"@agentset/db\";\r\n\r\nexport async function deleteOrganization({\r\n  organizationId,\r\n}: {\r\n  organizationId: string;\r\n}) {\r\n  const org = await db.organization.update({\r\n    where: {\r\n      id: organizationId,\r\n    },\r\n    data: {\r\n      status: OrganizationStatus.DELETING,\r\n    },\r\n    select: {\r\n      id: true,\r\n      stripeId: true,\r\n      namespaces: {\r\n        select: {\r\n          id: true,\r\n        },\r\n      },\r\n    },\r\n  });\r\n\r\n  if (org.stripeId) {\r\n    await cancelSubscription(org.stripeId);\r\n  }\r\n\r\n  if (org.namespaces.length > 0) {\r\n    await Promise.all(\r\n      org.namespaces.map((namespace) =>\r\n        triggerDeleteNamespace({\r\n          namespaceId: namespace.id,\r\n          deleteOrgWhenDone: true,\r\n        }),\r\n      ),\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;AAAA;AACA;AAEA;AAAA;AAAA;;;;AAEO,eAAe,mBAAmB,EACvC,cAAc,EAGf;IACC,MAAM,MAAM,MAAM,+HAAA,CAAA,KAAE,CAAC,YAAY,CAAC,MAAM,CAAC;QACvC,OAAO;YACL,IAAI;QACN;QACA,MAAM;YACJ,QAAQ,6HAAA,CAAA,qBAAkB,CAAC,QAAQ;QACrC;QACA,QAAQ;YACN,IAAI;YACJ,UAAU;YACV,YAAY;gBACV,QAAQ;oBACN,IAAI;gBACN;YACF;QACF;IACF;IAEA,IAAI,IAAI,QAAQ,EAAE;QAChB,MAAM,CAAA,GAAA,6JAAA,CAAA,qBAAkB,AAAD,EAAE,IAAI,QAAQ;IACvC;IAEA,IAAI,IAAI,UAAU,CAAC,MAAM,GAAG,GAAG;QAC7B,MAAM,QAAQ,GAAG,CACf,IAAI,UAAU,CAAC,GAAG,CAAC,CAAC,YAClB,CAAA,GAAA,qIAAA,CAAA,yBAAsB,AAAD,EAAE;gBACrB,aAAa,UAAU,EAAE;gBACzB,mBAAmB;YACrB;IAGN;AACF","debugId":null}},
    {"offset": {"line": 3879, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/server/api/routers/organizations.ts"],"sourcesContent":["import { deleteOrganization } from \"@/services/organizations/delete\";\r\nimport { TRPCError } from \"@trpc/server\";\r\nimport { z } from \"zod\";\r\n\r\nimport { OrganizationStatus } from \"@agentset/db\";\r\n\r\nimport { createTRPCRouter, protectedProcedure } from \"../trpc\";\r\n\r\nexport const organizationsRouter = createTRPCRouter({\r\n  all: protectedProcedure.query(async ({ ctx }) => {\r\n    const orgs = await ctx.db.organization.findMany({\r\n      where: {\r\n        members: {\r\n          some: {\r\n            userId: ctx.session.user.id,\r\n          },\r\n        },\r\n        status: OrganizationStatus.ACTIVE,\r\n      },\r\n      select: {\r\n        id: true,\r\n        name: true,\r\n        slug: true,\r\n        plan: true,\r\n        logo: true,\r\n        namespaces: {\r\n          select: {\r\n            id: true,\r\n            name: true,\r\n            slug: true,\r\n          },\r\n        },\r\n      },\r\n      orderBy: {\r\n        createdAt: \"asc\",\r\n      },\r\n    });\r\n\r\n    return orgs;\r\n  }),\r\n  members: protectedProcedure\r\n    .input(\r\n      z.object({\r\n        organizationId: z.string(),\r\n      }),\r\n    )\r\n    .query(async ({ ctx, input }) => {\r\n      const members = await ctx.db.organization.findUnique({\r\n        where: {\r\n          id: input.organizationId,\r\n          members: {\r\n            some: {\r\n              userId: ctx.session.user.id,\r\n            },\r\n          },\r\n        },\r\n        select: {\r\n          members: {\r\n            include: {\r\n              user: {\r\n                select: {\r\n                  name: true,\r\n                  email: true,\r\n                  image: true,\r\n                },\r\n              },\r\n            },\r\n            orderBy: {\r\n              createdAt: \"asc\",\r\n            },\r\n          },\r\n          invitations: {\r\n            where: {\r\n              status: \"pending\",\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      return members;\r\n    }),\r\n  delete: protectedProcedure\r\n    .input(\r\n      z.object({\r\n        organizationId: z.string(),\r\n      }),\r\n    )\r\n    .mutation(async ({ ctx, input }) => {\r\n      const org = await ctx.db.organization.findUnique({\r\n        where: {\r\n          id: input.organizationId,\r\n          members: {\r\n            some: {\r\n              userId: ctx.session.user.id,\r\n              role: { in: [\"admin\", \"owner\"] },\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!org) {\r\n        throw new TRPCError({\r\n          code: \"UNAUTHORIZED\",\r\n          message: \"You are not authorized to delete this organization\",\r\n        });\r\n      }\r\n\r\n      if (org.status === OrganizationStatus.DELETING) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"Organization is already being deleted\",\r\n        });\r\n      }\r\n\r\n      await deleteOrganization({ organizationId: org.id });\r\n    }),\r\n});\r\n"],"names":[],"mappings":";;;AAAA;AACA;AAAA;AACA;AAEA;AAAA;AAEA;;;;;;AAEO,MAAM,sBAAsB,CAAA,GAAA,2IAAA,CAAA,mBAAgB,AAAD,EAAE;IAClD,KAAK,2IAAA,CAAA,qBAAkB,CAAC,KAAK,CAAC,OAAO,EAAE,GAAG,EAAE;QAC1C,MAAM,OAAO,MAAM,IAAI,EAAE,CAAC,YAAY,CAAC,QAAQ,CAAC;YAC9C,OAAO;gBACL,SAAS;oBACP,MAAM;wBACJ,QAAQ,IAAI,OAAO,CAAC,IAAI,CAAC,EAAE;oBAC7B;gBACF;gBACA,QAAQ,6HAAA,CAAA,qBAAkB,CAAC,MAAM;YACnC;YACA,QAAQ;gBACN,IAAI;gBACJ,MAAM;gBACN,MAAM;gBACN,MAAM;gBACN,MAAM;gBACN,YAAY;oBACV,QAAQ;wBACN,IAAI;wBACJ,MAAM;wBACN,MAAM;oBACR;gBACF;YACF;YACA,SAAS;gBACP,WAAW;YACb;QACF;QAEA,OAAO;IACT;IACA,SAAS,2IAAA,CAAA,qBAAkB,CACxB,KAAK,CACJ,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;QACP,gBAAgB,oIAAA,CAAA,IAAC,CAAC,MAAM;IAC1B,IAED,KAAK,CAAC,OAAO,EAAE,GAAG,EAAE,KAAK,EAAE;QAC1B,MAAM,UAAU,MAAM,IAAI,EAAE,CAAC,YAAY,CAAC,UAAU,CAAC;YACnD,OAAO;gBACL,IAAI,MAAM,cAAc;gBACxB,SAAS;oBACP,MAAM;wBACJ,QAAQ,IAAI,OAAO,CAAC,IAAI,CAAC,EAAE;oBAC7B;gBACF;YACF;YACA,QAAQ;gBACN,SAAS;oBACP,SAAS;wBACP,MAAM;4BACJ,QAAQ;gCACN,MAAM;gCACN,OAAO;gCACP,OAAO;4BACT;wBACF;oBACF;oBACA,SAAS;wBACP,WAAW;oBACb;gBACF;gBACA,aAAa;oBACX,OAAO;wBACL,QAAQ;oBACV;gBACF;YACF;QACF;QAEA,OAAO;IACT;IACF,QAAQ,2IAAA,CAAA,qBAAkB,CACvB,KAAK,CACJ,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;QACP,gBAAgB,oIAAA,CAAA,IAAC,CAAC,MAAM;IAC1B,IAED,QAAQ,CAAC,OAAO,EAAE,GAAG,EAAE,KAAK,EAAE;QAC7B,MAAM,MAAM,MAAM,IAAI,EAAE,CAAC,YAAY,CAAC,UAAU,CAAC;YAC/C,OAAO;gBACL,IAAI,MAAM,cAAc;gBACxB,SAAS;oBACP,MAAM;wBACJ,QAAQ,IAAI,OAAO,CAAC,IAAI,CAAC,EAAE;wBAC3B,MAAM;4BAAE,IAAI;gCAAC;gCAAS;6BAAQ;wBAAC;oBACjC;gBACF;YACF;QACF;QAEA,IAAI,CAAC,KAAK;YACR,MAAM,IAAI,0MAAA,CAAA,YAAS,CAAC;gBAClB,MAAM;gBACN,SAAS;YACX;QACF;QAEA,IAAI,IAAI,MAAM,KAAK,6HAAA,CAAA,qBAAkB,CAAC,QAAQ,EAAE;YAC9C,MAAM,IAAI,0MAAA,CAAA,YAAS,CAAC;gBAClB,MAAM;gBACN,SAAS;YACX;QACF;QAEA,MAAM,CAAA,GAAA,yJAAA,CAAA,qBAAkB,AAAD,EAAE;YAAE,gBAAgB,IAAI,EAAE;QAAC;IACpD;AACJ","debugId":null}},
    {"offset": {"line": 4003, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/keyword-store/index.ts"],"sourcesContent":["import { env } from \"@/env\";\nimport { metadataDictToNode } from \"@llamaindex/core/vector-store\";\nimport { TextNode } from \"llamaindex\";\n\nimport { formatResults } from \"../vector-store/parse\";\n\nexport type KeywordSearchChunk = {\n  id: string;\n  text: string;\n  namespaceId: string;\n  tenantId?: string | null;\n  documentId: string;\n  metadata: string;\n};\n\nconst topLevelMetadataKeys = [\n  \"namespaceId\",\n  \"documentId\",\n  \"tenantId\",\n] satisfies (keyof KeywordSearchChunk)[];\n\nconst safeParse = (json: string) => {\n  try {\n    return JSON.parse(json);\n  } catch (error) {\n    return null;\n  }\n};\n\nexport class KeywordStore {\n  constructor(\n    private readonly namespaceId: string,\n    private readonly tenantId?: string,\n  ) {}\n\n  private encodeId(id: string) {\n    return id.replaceAll(\"#\", \"_\");\n  }\n\n  private decodeId(id: string) {\n    return id.replaceAll(\"_\", \"#\");\n  }\n\n  async search(\n    query: string,\n    {\n      documentId,\n      page = 1,\n      limit = 10,\n      includeMetadata,\n      includeRelationships,\n    }: {\n      documentId?: string;\n      page?: number;\n      limit?: number;\n      includeMetadata?: boolean;\n      includeRelationships?: boolean;\n    } = {},\n  ) {\n    // Temporary implementation - returns empty results\n    // TODO: Implement proper semantic search with Pinecone\n    console.log(\"KeywordStore.search called - returning empty results (Azure Search disabled)\");\n    \n    return {\n      total: 0,\n      totalPages: 1,\n      perPage: limit,\n      currentPage: page,\n      hasNextPage: false,\n      hasPreviousPage: false,\n      results: [],\n    };\n  }\n\n  async listIds({\n    page = 1,\n    limit = 1000,\n    documentId,\n  }: {\n    page?: number;\n    limit?: number;\n    documentId?: string;\n  } = {}) {\n    // Temporary implementation - returns empty array\n    console.log(\"KeywordStore.listIds called - returning empty array (Azure Search disabled)\");\n    \n    return {\n      total: 0,\n      totalPages: 1,\n      perPage: limit,\n      currentPage: page,\n      hasNextPage: false,\n      hasPreviousPage: false,\n      ids: [],\n    };\n  }\n\n  async deleteByIds(ids: string[]) {\n    // No-op implementation\n    console.log(\"KeywordStore.deleteByIds called - no-op (Azure Search disabled):\", ids.length, \"ids\");\n  }\n\n  async upsert(chunks: KeywordSearchChunk[]) {\n    // No-op implementation\n    console.log(\"KeywordStore.upsert called - no-op (Azure Search disabled):\", chunks.length, \"chunks\");\n  }\n}\n"],"names":[],"mappings":";;;AAeA,MAAM,uBAAuB;IAC3B;IACA;IACA;CACD;AAED,MAAM,YAAY,CAAC;IACjB,IAAI;QACF,OAAO,KAAK,KAAK,CAAC;IACpB,EAAE,OAAO,OAAO;QACd,OAAO;IACT;AACF;AAEO,MAAM;;;IACX,YACE,AAAiB,WAAmB,EACpC,AAAiB,QAAiB,CAClC;aAFiB,cAAA;aACA,WAAA;IAChB;IAEK,SAAS,EAAU,EAAE;QAC3B,OAAO,GAAG,UAAU,CAAC,KAAK;IAC5B;IAEQ,SAAS,EAAU,EAAE;QAC3B,OAAO,GAAG,UAAU,CAAC,KAAK;IAC5B;IAEA,MAAM,OACJ,KAAa,EACb,EACE,UAAU,EACV,OAAO,CAAC,EACR,QAAQ,EAAE,EACV,eAAe,EACf,oBAAoB,EAOrB,GAAG,CAAC,CAAC,EACN;QACA,mDAAmD;QACnD,uDAAuD;QACvD,QAAQ,GAAG,CAAC;QAEZ,OAAO;YACL,OAAO;YACP,YAAY;YACZ,SAAS;YACT,aAAa;YACb,aAAa;YACb,iBAAiB;YACjB,SAAS,EAAE;QACb;IACF;IAEA,MAAM,QAAQ,EACZ,OAAO,CAAC,EACR,QAAQ,IAAI,EACZ,UAAU,EAKX,GAAG,CAAC,CAAC,EAAE;QACN,iDAAiD;QACjD,QAAQ,GAAG,CAAC;QAEZ,OAAO;YACL,OAAO;YACP,YAAY;YACZ,SAAS;YACT,aAAa;YACb,aAAa;YACb,iBAAiB;YACjB,KAAK,EAAE;QACT;IACF;IAEA,MAAM,YAAY,GAAa,EAAE;QAC/B,uBAAuB;QACvB,QAAQ,GAAG,CAAC,oEAAoE,IAAI,MAAM,EAAE;IAC9F;IAEA,MAAM,OAAO,MAA4B,EAAE;QACzC,uBAAuB;QACvB,QAAQ,GAAG,CAAC,+DAA+D,OAAO,MAAM,EAAE;IAC5F;AACF","debugId":null}},
    {"offset": {"line": 4073, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/agentic/prompts.ts"],"sourcesContent":["export const GENERATE_QUERIES_PROMPT = `\r\nGiven a user question (or a chat history), list the appropriate search queries to find answers. \r\n\r\nThere are two apis to use: keyword search and semantic search. You should return a maximum of 10 queries.\r\n\r\nA good keyword search query contains one (or max two) words that are key to finding the result.\r\n\r\nThe results should be returned in the format: \r\n{\"queries\": [{\"type\": \"keyword\", \"query\": \"...\"}, ...]}\r\n`;\r\n\r\nexport const EVALUATE_QUERIES_PROMPT = `\r\nYou are a research assistant, you will be provided with a chat history, and a list of sources, and you will need to evaluate if the sources are able to answer the user's question.\r\n\r\nThe result should be returned in the format:\r\n{ \"canAnswer\": true | false }\r\n`;\r\n"],"names":[],"mappings":";;;;AAAO,MAAM,0BAA0B,CAAC;;;;;;;;;AASxC,CAAC;AAEM,MAAM,0BAA0B,CAAC;;;;;AAKxC,CAAC","debugId":null}},
    {"offset": {"line": 4099, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/agentic/utils.ts"],"sourcesContent":["import type { CoreMessage, LanguageModelV1 } from \"ai\";\r\nimport { generateText } from \"ai\";\r\nimport { z } from \"zod\";\r\n\r\nimport type { QueryVectorStoreResult } from \"../vector-store/parse\";\r\nimport { EVALUATE_QUERIES_PROMPT, GENERATE_QUERIES_PROMPT } from \"./prompts\";\r\n\r\nexport const formatChatHistory = (messages: CoreMessage[]) => {\r\n  return messages.map((m) => `${m.role}: ${m.content as string}`).join(\"\\n\\n\");\r\n};\r\n\r\nexport const formatSources = (sources: QueryVectorStoreResult[\"results\"]) => {\r\n  return sources\r\n    .map((s, idx) => `<source_${idx + 1}>\\n${s.text}\\n</source_${idx + 1}>`)\r\n    .join(\"\\n\\n\");\r\n};\r\n\r\nconst schema = z.object({\r\n  queries: z.array(\r\n    z.object({\r\n      type: z.enum([\"keyword\", \"semantic\"]),\r\n      query: z.string(),\r\n    }),\r\n  ),\r\n});\r\n\r\nexport type Queries = z.infer<typeof schema>[\"queries\"];\r\n\r\nexport const generateQueries = async (\r\n  model: LanguageModelV1,\r\n  messages: CoreMessage[],\r\n  oldQueries: Queries,\r\n) => {\r\n  const queriesResult = await generateText({\r\n    model,\r\n    temperature: 0,\r\n    system: GENERATE_QUERIES_PROMPT,\r\n    prompt: `\r\n${\r\n  oldQueries.length > 0\r\n    ? \"The queries you return should be different from these ones that were tried so far:\\n\" +\r\n      oldQueries.map((q) => `- ${q.query}`).join(\"\\n\")\r\n    : \"\"\r\n}\r\n\r\nChat history:\r\n${formatChatHistory(messages)}\r\n`.trim(),\r\n  });\r\n\r\n  return {\r\n    queries: schema.parse(JSON.parse(queriesResult.text)).queries,\r\n    totalTokens: queriesResult.usage.totalTokens || 0,\r\n  };\r\n};\r\n\r\nconst evalSchema = z.object({\r\n  canAnswer: z.boolean(),\r\n});\r\n\r\nexport const evaluateQueries = async (\r\n  model: LanguageModelV1,\r\n  messages: CoreMessage[],\r\n  sources: QueryVectorStoreResult[\"results\"],\r\n) => {\r\n  const evaluateQueriesResult = await generateText({\r\n    model,\r\n    temperature: 0,\r\n    system: EVALUATE_QUERIES_PROMPT,\r\n    prompt: `\r\nChat history:\r\n${formatChatHistory(messages)}\r\n\r\nRetrieved sources:\r\n${formatSources(sources)}\r\n `,\r\n  });\r\n\r\n  return {\r\n    canAnswer: evalSchema.parse(JSON.parse(evaluateQueriesResult.text))\r\n      .canAnswer,\r\n    totalTokens: evaluateQueriesResult.usage.totalTokens || 0,\r\n  };\r\n};\r\n"],"names":[],"mappings":";;;;;;AACA;AACA;AAGA;;;;AAEO,MAAM,oBAAoB,CAAC;IAChC,OAAO,SAAS,GAAG,CAAC,CAAC,IAAM,GAAG,EAAE,IAAI,CAAC,EAAE,EAAE,EAAE,OAAO,EAAY,EAAE,IAAI,CAAC;AACvE;AAEO,MAAM,gBAAgB,CAAC;IAC5B,OAAO,QACJ,GAAG,CAAC,CAAC,GAAG,MAAQ,CAAC,QAAQ,EAAE,MAAM,EAAE,GAAG,EAAE,EAAE,IAAI,CAAC,WAAW,EAAE,MAAM,EAAE,CAAC,CAAC,EACtE,IAAI,CAAC;AACV;AAEA,MAAM,SAAS,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACtB,SAAS,oIAAA,CAAA,IAAC,CAAC,KAAK,CACd,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;QACP,MAAM,oIAAA,CAAA,IAAC,CAAC,IAAI,CAAC;YAAC;YAAW;SAAW;QACpC,OAAO,oIAAA,CAAA,IAAC,CAAC,MAAM;IACjB;AAEJ;AAIO,MAAM,kBAAkB,OAC7B,OACA,UACA;IAEA,MAAM,gBAAgB,MAAM,CAAA,GAAA,oJAAA,CAAA,eAAY,AAAD,EAAE;QACvC;QACA,aAAa;QACb,QAAQ,+IAAA,CAAA,0BAAuB;QAC/B,QAAQ,CAAC;AACb,EACE,WAAW,MAAM,GAAG,IAChB,yFACA,WAAW,GAAG,CAAC,CAAC,IAAM,CAAC,EAAE,EAAE,EAAE,KAAK,EAAE,EAAE,IAAI,CAAC,QAC3C,GACL;;;AAGD,EAAE,kBAAkB,UAAU;AAC9B,CAAC,CAAC,IAAI;IACJ;IAEA,OAAO;QACL,SAAS,OAAO,KAAK,CAAC,KAAK,KAAK,CAAC,cAAc,IAAI,GAAG,OAAO;QAC7D,aAAa,cAAc,KAAK,CAAC,WAAW,IAAI;IAClD;AACF;AAEA,MAAM,aAAa,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC1B,WAAW,oIAAA,CAAA,IAAC,CAAC,OAAO;AACtB;AAEO,MAAM,kBAAkB,OAC7B,OACA,UACA;IAEA,MAAM,wBAAwB,MAAM,CAAA,GAAA,oJAAA,CAAA,eAAY,AAAD,EAAE;QAC/C;QACA,aAAa;QACb,QAAQ,+IAAA,CAAA,0BAAuB;QAC/B,QAAQ,CAAC;;AAEb,EAAE,kBAAkB,UAAU;;;AAG9B,EAAE,cAAc,SAAS;CACxB,CAAC;IACA;IAEA,OAAO;QACL,WAAW,WAAW,KAAK,CAAC,KAAK,KAAK,CAAC,sBAAsB,IAAI,GAC9D,SAAS;QACZ,aAAa,sBAAsB,KAAK,CAAC,WAAW,IAAI;IAC1D;AACF","debugId":null}},
    {"offset": {"line": 4170, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/agentic/search.ts"],"sourcesContent":["import type { CoreMessage, LanguageModelV1 } from \"ai\";\r\n\r\nimport type { Namespace } from \"@agentset/db\";\r\n\r\nimport type {\r\n  QueryVectorStoreOptions,\r\n  QueryVectorStoreResult,\r\n} from \"../vector-store/parse\";\r\nimport type { Queries } from \"./utils\";\r\nimport { KeywordStore } from \"../keyword-store\";\r\nimport { queryVectorStore } from \"../vector-store/parse\";\r\nimport { evaluateQueries, generateQueries } from \"./utils\";\r\n\r\nexport type AgenticSearchNamespace = Pick<\r\n  Namespace,\r\n  | \"id\"\r\n  | \"vectorStoreConfig\"\r\n  | \"embeddingConfig\"\r\n  | \"createdAt\"\r\n  | \"keywordEnabled\"\r\n>;\r\n\r\nexport async function agenticSearch(\r\n  namespace: AgenticSearchNamespace,\r\n  {\r\n    model,\r\n    messages,\r\n    queryOptions,\r\n    maxEvals = 3,\r\n    tokenBudget = 4096,\r\n    onQueries,\r\n  }: {\r\n    model: LanguageModelV1;\r\n    messages: CoreMessage[];\r\n    queryOptions?: Omit<QueryVectorStoreOptions, \"query\">;\r\n    maxEvals?: number;\r\n    tokenBudget?: number;\r\n    onQueries?: (queries: Queries) => void;\r\n  },\r\n) {\r\n  const queries: Queries = [];\r\n  const chunks: Record<string, QueryVectorStoreResult[\"results\"][number]> = {};\r\n  const queryToResult: Record<string, QueryVectorStoreResult> = {};\r\n  let totalQueries = 0;\r\n  let totalTokens = 0;\r\n\r\n  const lastMessage = messages[messages.length - 1]!.content as string;\r\n\r\n  for (let i = 0; i < maxEvals; i++) {\r\n    console.log(`[EVAL LOOP] ${i + 1} / ${maxEvals}`);\r\n    console.dir(messages, { depth: null });\r\n    console.dir(queries, { depth: null });\r\n\r\n    const { queries: newQueries, totalTokens: queriesTokens } =\r\n      await generateQueries(model, messages, queries);\r\n\r\n    if (i === 0) {\r\n      newQueries.unshift({\r\n        query: lastMessage,\r\n        type: \"semantic\",\r\n      });\r\n    }\r\n\r\n    newQueries.forEach((q) => {\r\n      if (queries.includes(q)) return;\r\n      queries.push(q);\r\n    });\r\n\r\n    totalTokens += queriesTokens;\r\n\r\n    if (onQueries) onQueries(newQueries);\r\n\r\n    const data = (\r\n      await Promise.all(\r\n        newQueries.map(async (query) => {\r\n          if (namespace.keywordEnabled && query.type === \"keyword\") {\r\n            const keywordStore = new KeywordStore(\r\n              namespace.id,\r\n              queryOptions?.tenantId,\r\n            );\r\n\r\n            const keywordResult = await keywordStore.search(query.query, {\r\n              limit: 15,\r\n              includeMetadata: true,\r\n            });\r\n\r\n            totalQueries++;\r\n            return {\r\n              query: query.query,\r\n              unorderedIds: keywordResult.results.map((r) => r.id),\r\n              results: keywordResult.results,\r\n            };\r\n          }\r\n\r\n          const queryResult = await queryVectorStore(namespace, {\r\n            query: query.query,\r\n            topK: 50,\r\n            rerankLimit: 15,\r\n            rerank: true,\r\n            includeMetadata: true,\r\n            ...queryOptions,\r\n          });\r\n          totalQueries++;\r\n          return queryResult;\r\n        }),\r\n      )\r\n    ).filter((d) => d !== null);\r\n\r\n    data.forEach((d) => {\r\n      queryToResult[d.query] = d;\r\n\r\n      d.results.forEach((r) => {\r\n        if (chunks[r.id]) return;\r\n        chunks[r.id] = r;\r\n      });\r\n    });\r\n\r\n    const { canAnswer, totalTokens: evalsTokens } = await evaluateQueries(\r\n      model,\r\n      messages,\r\n      Object.values(chunks),\r\n    );\r\n    totalTokens += evalsTokens;\r\n\r\n    if (canAnswer || totalTokens >= tokenBudget) break;\r\n  }\r\n\r\n  return {\r\n    queries,\r\n    chunks,\r\n    queryToResult,\r\n    totalQueries,\r\n  };\r\n}\r\n"],"names":[],"mappings":";;;AASA;AACA;AACA;;;;AAWO,eAAe,cACpB,SAAiC,EACjC,EACE,KAAK,EACL,QAAQ,EACR,YAAY,EACZ,WAAW,CAAC,EACZ,cAAc,IAAI,EAClB,SAAS,EAQV;IAED,MAAM,UAAmB,EAAE;IAC3B,MAAM,SAAoE,CAAC;IAC3E,MAAM,gBAAwD,CAAC;IAC/D,IAAI,eAAe;IACnB,IAAI,cAAc;IAElB,MAAM,cAAc,QAAQ,CAAC,SAAS,MAAM,GAAG,EAAE,CAAE,OAAO;IAE1D,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,IAAK;QACjC,QAAQ,GAAG,CAAC,CAAC,YAAY,EAAE,IAAI,EAAE,GAAG,EAAE,UAAU;QAChD,QAAQ,GAAG,CAAC,UAAU;YAAE,OAAO;QAAK;QACpC,QAAQ,GAAG,CAAC,SAAS;YAAE,OAAO;QAAK;QAEnC,MAAM,EAAE,SAAS,UAAU,EAAE,aAAa,aAAa,EAAE,GACvD,MAAM,CAAA,GAAA,6IAAA,CAAA,kBAAe,AAAD,EAAE,OAAO,UAAU;QAEzC,IAAI,MAAM,GAAG;YACX,WAAW,OAAO,CAAC;gBACjB,OAAO;gBACP,MAAM;YACR;QACF;QAEA,WAAW,OAAO,CAAC,CAAC;YAClB,IAAI,QAAQ,QAAQ,CAAC,IAAI;YACzB,QAAQ,IAAI,CAAC;QACf;QAEA,eAAe;QAEf,IAAI,WAAW,UAAU;QAEzB,MAAM,OAAO,CACX,MAAM,QAAQ,GAAG,CACf,WAAW,GAAG,CAAC,OAAO;YACpB,IAAI,UAAU,cAAc,IAAI,MAAM,IAAI,KAAK,WAAW;gBACxD,MAAM,eAAe,IAAI,sJAAA,CAAA,eAAY,CACnC,UAAU,EAAE,EACZ,cAAc;gBAGhB,MAAM,gBAAgB,MAAM,aAAa,MAAM,CAAC,MAAM,KAAK,EAAE;oBAC3D,OAAO;oBACP,iBAAiB;gBACnB;gBAEA;gBACA,OAAO;oBACL,OAAO,MAAM,KAAK;oBAClB,cAAc,cAAc,OAAO,CAAC,GAAG,CAAC,CAAC,IAAM,EAAE,EAAE;oBACnD,SAAS,cAAc,OAAO;gBAChC;YACF;YAEA,MAAM,cAAc,MAAM,CAAA,GAAA,qJAAA,CAAA,mBAAgB,AAAD,EAAE,WAAW;gBACpD,OAAO,MAAM,KAAK;gBAClB,MAAM;gBACN,aAAa;gBACb,QAAQ;gBACR,iBAAiB;gBACjB,GAAG,YAAY;YACjB;YACA;YACA,OAAO;QACT,GAEJ,EAAE,MAAM,CAAC,CAAC,IAAM,MAAM;QAEtB,KAAK,OAAO,CAAC,CAAC;YACZ,aAAa,CAAC,EAAE,KAAK,CAAC,GAAG;YAEzB,EAAE,OAAO,CAAC,OAAO,CAAC,CAAC;gBACjB,IAAI,MAAM,CAAC,EAAE,EAAE,CAAC,EAAE;gBAClB,MAAM,CAAC,EAAE,EAAE,CAAC,GAAG;YACjB;QACF;QAEA,MAAM,EAAE,SAAS,EAAE,aAAa,WAAW,EAAE,GAAG,MAAM,CAAA,GAAA,6IAAA,CAAA,kBAAe,AAAD,EAClE,OACA,UACA,OAAO,MAAM,CAAC;QAEhB,eAAe;QAEf,IAAI,aAAa,eAAe,aAAa;IAC/C;IAEA,OAAO;QACL;QACA;QACA;QACA;IACF;AACF","debugId":null}},
    {"offset": {"line": 4256, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/api/usage.ts"],"sourcesContent":["import { waitUntil } from \"@vercel/functions\";\r\n\r\nimport { db } from \"@agentset/db\";\r\n\r\nexport const incrementSearchUsage = (namespaceId: string, queries: number) => {\r\n  // track usage\r\n  waitUntil(\r\n    (async () => {\r\n      await db.namespace.update({\r\n        where: {\r\n          id: namespaceId,\r\n        },\r\n        data: {\r\n          organization: {\r\n            update: {\r\n              searchUsage: { increment: queries },\r\n            },\r\n          },\r\n        },\r\n      });\r\n    })(),\r\n  );\r\n};\r\n"],"names":[],"mappings":";;;AAAA;AAEA;AAAA;;;AAEO,MAAM,uBAAuB,CAAC,aAAqB;IACxD,cAAc;IACd,CAAA,GAAA,8IAAA,CAAA,YAAS,AAAD,EACN,CAAC;QACC,MAAM,+HAAA,CAAA,KAAE,CAAC,SAAS,CAAC,MAAM,CAAC;YACxB,OAAO;gBACL,IAAI;YACN;YACA,MAAM;gBACJ,cAAc;oBACZ,QAAQ;wBACN,aAAa;4BAAE,WAAW;wBAAQ;oBACpC;gBACF;YACF;QACF;IACF,CAAC;AAEL","debugId":null}},
    {"offset": {"line": 4289, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/llm.ts"],"sourcesContent":["import { env } from \"@/env\";\n\nimport type { LLMConfig } from \"@agentset/db\";\n\nexport const getNamespaceLanguageModel = async (config?: LLMConfig) => {\n  if (!config) {\n    const { createOpenAI } = await import(\"@ai-sdk/openai\");\n\n    const defaultOpenAI = createOpenAI({\n      apiKey: env.DEFAULT_OPENAI_API_KEY,\n    });\n\n    return defaultOpenAI.languageModel(env.DEFAULT_OPENAI_MODEL || \"gpt-4\");\n  }\n\n  switch (config.provider) {\n    case \"OPENAI\": {\n      const { createOpenAI } = await import(\"@ai-sdk/openai\");\n\n      const { apiKey, model } = config;\n      const openai = createOpenAI({ apiKey });\n      return openai.languageModel(model);\n    }\n\n    case \"AZURE_OPENAI\": {\n      const { createOpenAI } = await import(\"@ai-sdk/openai\");\n\n      const { apiKey, model } = config;\n      const openai = createOpenAI({ apiKey });\n      return openai.languageModel(model);\n    }\n\n    default: {\n      // This exhaustive check ensures TypeScript will error if a new provider\n      // is added without handling it in the switch statement\n      const _exhaustiveCheck: never = config;\n      throw new Error(`Unknown vector store provider: ${_exhaustiveCheck}`);\n    }\n  }\n};\n"],"names":[],"mappings":";;;AAAA;;AAIO,MAAM,4BAA4B,OAAO;IAC9C,IAAI,CAAC,QAAQ;QACX,MAAM,EAAE,YAAY,EAAE,GAAG;QAEzB,MAAM,gBAAgB,aAAa;YACjC,QAAQ,yHAAA,CAAA,MAAG,CAAC,sBAAsB;QACpC;QAEA,OAAO,cAAc,aAAa,CAAC,yHAAA,CAAA,MAAG,CAAC,oBAAoB,IAAI;IACjE;IAEA,OAAQ,OAAO,QAAQ;QACrB,KAAK;YAAU;gBACb,MAAM,EAAE,YAAY,EAAE,GAAG;gBAEzB,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG;gBAC1B,MAAM,SAAS,aAAa;oBAAE;gBAAO;gBACrC,OAAO,OAAO,aAAa,CAAC;YAC9B;QAEA,KAAK;YAAgB;gBACnB,MAAM,EAAE,YAAY,EAAE,GAAG;gBAEzB,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG;gBAC1B,MAAM,SAAS,aAAa;oBAAE;gBAAO;gBACrC,OAAO,OAAO,aAAa,CAAC;YAC9B;QAEA;YAAS;gBACP,wEAAwE;gBACxE,uDAAuD;gBACvD,MAAM,mBAA0B;gBAChC,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,kBAAkB;YACtE;IACF;AACF","debugId":null}},
    {"offset": {"line": 4336, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/server/api/routers/search.ts"],"sourcesContent":["import { agenticSearch } from \"@/lib/agentic/search\";\r\nimport { incrementSearchUsage } from \"@/lib/api/usage\";\r\nimport { getNamespaceLanguageModel } from \"@/lib/llm\";\r\nimport { createTRPCRouter, protectedProcedure } from \"@/server/api/trpc\";\r\nimport { TRPCError } from \"@trpc/server\";\r\nimport { z } from \"zod\";\r\n\r\nimport { getNamespaceByUser } from \"../auth\";\r\n\r\nexport const searchRouter = createTRPCRouter({\r\n  search: protectedProcedure\r\n    .input(\r\n      z.object({\r\n        namespaceId: z.string(),\r\n        query: z.string(),\r\n      }),\r\n    )\r\n    .query(async ({ ctx, input }) => {\r\n      const namespace = await getNamespaceByUser(ctx, {\r\n        id: input.namespaceId,\r\n      });\r\n\r\n      if (!namespace) {\r\n        throw new TRPCError({ code: \"NOT_FOUND\" });\r\n      }\r\n\r\n      const model = await getNamespaceLanguageModel();\r\n\r\n      const results = await agenticSearch(namespace, {\r\n        model,\r\n        messages: [\r\n          {\r\n            role: \"user\",\r\n            content: input.query,\r\n          },\r\n        ],\r\n      });\r\n\r\n      incrementSearchUsage(namespace.id, results.totalQueries);\r\n\r\n      const chunks = Object.values(results.chunks);\r\n\r\n      return {\r\n        results: chunks,\r\n        queries: results.queries,\r\n      };\r\n    }),\r\n});\r\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;;AAEO,MAAM,eAAe,CAAA,GAAA,2IAAA,CAAA,mBAAgB,AAAD,EAAE;IAC3C,QAAQ,2IAAA,CAAA,qBAAkB,CACvB,KAAK,CACJ,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;QACP,aAAa,oIAAA,CAAA,IAAC,CAAC,MAAM;QACrB,OAAO,oIAAA,CAAA,IAAC,CAAC,MAAM;IACjB,IAED,KAAK,CAAC,OAAO,EAAE,GAAG,EAAE,KAAK,EAAE;QAC1B,MAAM,YAAY,MAAM,CAAA,GAAA,2IAAA,CAAA,qBAAkB,AAAD,EAAE,KAAK;YAC9C,IAAI,MAAM,WAAW;QACvB;QAEA,IAAI,CAAC,WAAW;YACd,MAAM,IAAI,0MAAA,CAAA,YAAS,CAAC;gBAAE,MAAM;YAAY;QAC1C;QAEA,MAAM,QAAQ,MAAM,CAAA,GAAA,gIAAA,CAAA,4BAAyB,AAAD;QAE5C,MAAM,UAAU,MAAM,CAAA,GAAA,8IAAA,CAAA,gBAAa,AAAD,EAAE,WAAW;YAC7C;YACA,UAAU;gBACR;oBACE,MAAM;oBACN,SAAS,MAAM,KAAK;gBACtB;aACD;QACH;QAEA,CAAA,GAAA,yIAAA,CAAA,uBAAoB,AAAD,EAAE,UAAU,EAAE,EAAE,QAAQ,YAAY;QAEvD,MAAM,SAAS,OAAO,MAAM,CAAC,QAAQ,MAAM;QAE3C,OAAO;YACL,SAAS;YACT,SAAS,QAAQ,OAAO;QAC1B;IACF;AACJ","debugId":null}},
    {"offset": {"line": 4391, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/slug.ts"],"sourcesContent":["import _slugify from \"slugify\";\r\n\r\nexport const validSlugRegex = new RegExp(/^[a-zA-Z0-9\\-]+$/);\r\n\r\nexport const toSlug = (text: string, suffix?: string) => {\r\n  return (\r\n    _slugify(text, {\r\n      lower: true,\r\n      strict: true,\r\n      trim: true,\r\n    }) + (suffix ? `-${suffix}` : \"\")\r\n  );\r\n};\r\n"],"names":[],"mappings":";;;;AAAA;;AAEO,MAAM,iBAAiB,IAAI,OAAO;AAElC,MAAM,SAAS,CAAC,MAAc;IACnC,OACE,CAAA,GAAA,kIAAA,CAAA,UAAQ,AAAD,EAAE,MAAM;QACb,OAAO;QACP,QAAQ;QACR,MAAM;IACR,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,QAAQ,GAAG,EAAE;AAEpC","debugId":null}},
    {"offset": {"line": 4411, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/string-utils.ts"],"sourcesContent":["import { toSlug } from \"./slug\";\r\n\r\nconst tokenCharacters =\r\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\r\nconst tokenCharactersLength = tokenCharacters.length;\r\n\r\nexport function generateToken(length: number) {\r\n  let result = \"\";\r\n  for (let i = 0; i < length; i++)\r\n    result += tokenCharacters.charAt(\r\n      Math.floor(Math.random() * tokenCharactersLength),\r\n    );\r\n  return result;\r\n}\r\n\r\nexport function truncate(str: string, length: number) {\r\n  if (str.length <= length) return str;\r\n  return str.slice(0, length);\r\n}\r\n\r\nexport function filenamize(value: string, length = 20) {\r\n  const token = generateToken(4);\r\n  const slug = toSlug(value, token);\r\n  const hyphenCount = (slug.match(/-/g) || []).length;\r\n  length = length + hyphenCount + token.length;\r\n\r\n  return truncate(slug, length);\r\n}\r\n\r\nexport function capitalize(str?: string | null) {\r\n  if (!str || typeof str !== \"string\") return str;\r\n\r\n  return str\r\n    .split(\" \")\r\n    .map(\r\n      (word) =>\r\n        word.charAt(0).toUpperCase() +\r\n        (word.length > 1 ? word.slice(1).toLowerCase() : \"\"),\r\n    )\r\n    .join(\" \");\r\n}\r\n\r\nexport function camelCaseToWords(str: string) {\r\n  return str\r\n    .split(/(?=[A-Z])/)\r\n    .map(capitalize)\r\n    .join(\" \");\r\n}\r\n\r\nexport function sanitizeText(text: string) {\r\n  return text.replaceAll(\"<has_function_call>\", \"\");\r\n}\r\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAEA,MAAM,kBACJ;AACF,MAAM,wBAAwB,gBAAgB,MAAM;AAE7C,SAAS,cAAc,MAAc;IAC1C,IAAI,SAAS;IACb,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAC1B,UAAU,gBAAgB,MAAM,CAC9B,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK;IAE/B,OAAO;AACT;AAEO,SAAS,SAAS,GAAW,EAAE,MAAc;IAClD,IAAI,IAAI,MAAM,IAAI,QAAQ,OAAO;IACjC,OAAO,IAAI,KAAK,CAAC,GAAG;AACtB;AAEO,SAAS,WAAW,KAAa,EAAE,SAAS,EAAE;IACnD,MAAM,QAAQ,cAAc;IAC5B,MAAM,OAAO,CAAA,GAAA,iIAAA,CAAA,SAAM,AAAD,EAAE,OAAO;IAC3B,MAAM,cAAc,CAAC,KAAK,KAAK,CAAC,SAAS,EAAE,EAAE,MAAM;IACnD,SAAS,SAAS,cAAc,MAAM,MAAM;IAE5C,OAAO,SAAS,MAAM;AACxB;AAEO,SAAS,WAAW,GAAmB;IAC5C,IAAI,CAAC,OAAO,OAAO,QAAQ,UAAU,OAAO;IAE5C,OAAO,IACJ,KAAK,CAAC,KACN,GAAG,CACF,CAAC,OACC,KAAK,MAAM,CAAC,GAAG,WAAW,KAC1B,CAAC,KAAK,MAAM,GAAG,IAAI,KAAK,KAAK,CAAC,GAAG,WAAW,KAAK,EAAE,GAEtD,IAAI,CAAC;AACV;AAEO,SAAS,iBAAiB,GAAW;IAC1C,OAAO,IACJ,KAAK,CAAC,aACN,GAAG,CAAC,YACJ,IAAI,CAAC;AACV;AAEO,SAAS,aAAa,IAAY;IACvC,OAAO,KAAK,UAAU,CAAC,uBAAuB;AAChD","debugId":null}},
    {"offset": {"line": 4455, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/lib/upload.ts"],"sourcesContent":["export const MAX_UPLOAD_SIZE = 200 * 1024 * 1024; // 200MB\r\n"],"names":[],"mappings":";;;AAAO,MAAM,kBAAkB,MAAM,OAAO,MAAM,QAAQ","debugId":null}},
    {"offset": {"line": 4465, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/server/api/routers/uploads.ts"],"sourcesContent":["import { extname } from \"node:path\";\nimport { tryCatch } from \"@/lib/error\";\nimport { filenamize } from \"@/lib/string-utils\";\nimport { MAX_UPLOAD_SIZE } from \"@/lib/upload\";\nimport { createTRPCRouter, protectedProcedure } from \"@/server/api/trpc\";\nimport { TRPCError } from \"@trpc/server\";\nimport { z } from \"zod\";\n\nimport { getNamespaceByUser } from \"../auth\";\n\nconst supportedExtensions = [\n  \".bmp\",\n  \".csv\",\n  \".doc\",\n  \".docx\",\n  \".eml\",\n  \".epub\",\n  \".heic\",\n  \".html\",\n  \".jpeg\",\n  \".png\",\n  \".md\",\n  \".msg\",\n  \".odt\",\n  \".org\",\n  \".p7s\",\n  \".pdf\",\n  \".png\",\n  \".ppt\",\n  \".pptx\",\n  \".rst\",\n  \".rtf\",\n  \".tiff\",\n  \".txt\",\n  \".tsv\",\n  \".xls\",\n  \".xlsx\",\n  \".xml\",\n];\n\n// Helper function to generate upload URL for Uploadthing\n// In practice, this would be handled by the Uploadthing component on the frontend\nconst presignUploadUrl = async (key: string, contentType: string, fileSize: number) => {\n  // Uploadthing handles presigned URLs internally\n  // This is a placeholder - actual upload should use Uploadthing components\n  return {\n    data: `/api/uploadthing`,\n    error: null,\n  };\n};\n\nexport const uploadsRouter = createTRPCRouter({\n  getPresignedUrl: protectedProcedure\n    .input(\n      z.object({\n        namespaceId: z.string(),\n        fileName: z.string(),\n        contentType: z.string(),\n        fileSize: z.number().min(1).max(MAX_UPLOAD_SIZE),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      const ext = extname(input.fileName);\n      const filename = filenamize(input.fileName.replace(ext, \"\"));\n\n      if (!supportedExtensions.includes(ext)) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Unsupported file type\",\n        });\n      }\n\n      const ns = await getNamespaceByUser(ctx, { id: input.namespaceId });\n\n      if (!ns) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Namespace not found\",\n        });\n      }\n\n      const key = `namespaces/${ns.id}/${filename}${ext}`;\n      const url = await tryCatch(\n        presignUploadUrl(key, input.contentType, input.fileSize),\n      );\n\n      if (url.error) {\n        throw new TRPCError({ code: \"INTERNAL_SERVER_ERROR\" });\n      }\n\n      return {\n        url: url.data,\n        key,\n      };\n    }),\n  getPresignedUrls: protectedProcedure\n    .input(\n      z.object({\n        namespaceId: z.string(),\n        files: z\n          .array(\n            z.object({\n              fileName: z.string(),\n              contentType: z.string(),\n              fileSize: z.number().min(1).max(MAX_UPLOAD_SIZE),\n            }),\n          )\n          .min(1, { message: \"At least one file is required\" })\n          .max(100, { message: \"Maximum 100 files\" }),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      const ns = await getNamespaceByUser(ctx, { id: input.namespaceId });\n\n      if (!ns) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Namespace not found\",\n        });\n      }\n\n      const preparedFiles = input.files.map((file) => {\n        const ext = extname(file.fileName);\n        const filename = filenamize(file.fileName.replace(ext, \"\"));\n\n        return {\n          ext,\n          contentType: file.contentType,\n          fileSize: file.fileSize,\n          key: `namespaces/${ns.id}/${filename}${ext}`,\n        };\n      });\n\n      if (\n        preparedFiles.some((file) => !supportedExtensions.includes(file.ext))\n      ) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Unsupported file type\",\n        });\n      }\n\n      const urls = await Promise.all(\n        preparedFiles.map(async (file) => {\n          const urlResult = await tryCatch(\n            presignUploadUrl(file.key, file.contentType, file.fileSize),\n          );\n\n          return {\n            url: urlResult,\n            key: file.key,\n          };\n        }),\n      );\n\n      if (urls.some((url) => url.url.error)) {\n        throw new TRPCError({ code: \"INTERNAL_SERVER_ERROR\" });\n      }\n\n      return urls.map((url) => ({\n        url: url.url.data!,\n        key: url.key,\n      }));\n    }),\n});\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 4621, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/server/api/root.ts"],"sourcesContent":["import { createCallerFactory, createTRPCRouter } from \"@/server/api/trpc\";\r\n\r\nimport { apiKeysRouter } from \"./routers/api-keys\";\r\nimport { billingRouter } from \"./routers/billing\";\r\nimport { documentsRouter } from \"./routers/documents\";\r\nimport { domainsRouter } from \"./routers/domains\";\r\nimport { hostingRouter } from \"./routers/hosting\";\r\nimport { ingestJobRouter } from \"./routers/ingest-jobs\";\r\nimport { namespaceRouter } from \"./routers/namespaces\";\r\nimport { organizationsRouter } from \"./routers/organizations\";\r\nimport { searchRouter } from \"./routers/search\";\r\nimport { uploadsRouter } from \"./routers/uploads\";\r\n\r\nexport const appRouter = createTRPCRouter({\r\n  namespace: namespaceRouter,\r\n  apiKey: apiKeysRouter,\r\n  ingestJob: ingestJobRouter,\r\n  document: documentsRouter,\r\n  upload: uploadsRouter,\r\n  billing: billingRouter,\r\n  organization: organizationsRouter,\r\n  hosting: hostingRouter,\r\n  domain: domainsRouter,\r\n  search: searchRouter,\r\n});\r\n\r\n// export type definition of API\r\nexport type AppRouter = typeof appRouter;\r\nexport const createCaller = createCallerFactory(appRouter);\r\n"],"names":[],"mappings":";;;;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAEO,MAAM,YAAY,CAAA,GAAA,2IAAA,CAAA,mBAAgB,AAAD,EAAE;IACxC,WAAW,4JAAA,CAAA,kBAAe;IAC1B,QAAQ,6JAAA,CAAA,gBAAa;IACrB,WAAW,gKAAA,CAAA,kBAAe;IAC1B,UAAU,2JAAA,CAAA,kBAAe;IACzB,QAAQ,yJAAA,CAAA,gBAAa;IACrB,SAAS,yJAAA,CAAA,gBAAa;IACtB,cAAc,+JAAA,CAAA,sBAAmB;IACjC,SAAS,yJAAA,CAAA,gBAAa;IACtB,QAAQ,yJAAA,CAAA,gBAAa;IACrB,QAAQ,wJAAA,CAAA,eAAY;AACtB;AAIO,MAAM,eAAe,CAAA,GAAA,2IAAA,CAAA,sBAAmB,AAAD,EAAE","debugId":null}},
    {"offset": {"line": 4666, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/trpc/query-client.ts"],"sourcesContent":["import {\r\n  defaultShouldDehydrateQuery,\r\n  QueryClient,\r\n} from \"@tanstack/react-query\";\r\nimport SuperJSON from \"superjson\";\r\n\r\nexport const createQueryClient = () =>\r\n  new QueryClient({\r\n    defaultOptions: {\r\n      queries: {\r\n        // With SSR, we usually want to set some default staleTime\r\n        // above 0 to avoid refetching immediately on the client\r\n        staleTime: 30 * 1000,\r\n      },\r\n      dehydrate: {\r\n        serializeData: SuperJSON.serialize,\r\n        shouldDehydrateQuery: (query) =>\r\n          defaultShouldDehydrateQuery(query) ||\r\n          query.state.status === \"pending\",\r\n        shouldRedactErrors: () => {\r\n          // We should not catch Next.js server errors\r\n          // as that's how Next.js detects dynamic pages\r\n          // so we cannot redact them.\r\n          // Next.js also automatically redacts errors for us\r\n          // with better digests.\r\n          return false;\r\n        },\r\n      },\r\n      hydrate: {\r\n        deserializeData: SuperJSON.deserialize,\r\n      },\r\n    },\r\n  });\r\n"],"names":[],"mappings":";;;AAAA;AAAA;AAIA;;;AAEO,MAAM,oBAAoB,IAC/B,IAAI,6KAAA,CAAA,cAAW,CAAC;QACd,gBAAgB;YACd,SAAS;gBACP,0DAA0D;gBAC1D,wDAAwD;gBACxD,WAAW,KAAK;YAClB;YACA,WAAW;gBACT,eAAe,0IAAA,CAAA,UAAS,CAAC,SAAS;gBAClC,sBAAsB,CAAC,QACrB,CAAA,GAAA,2KAAA,CAAA,8BAA2B,AAAD,EAAE,UAC5B,MAAM,KAAK,CAAC,MAAM,KAAK;gBACzB,oBAAoB;oBAClB,4CAA4C;oBAC5C,8CAA8C;oBAC9C,4BAA4B;oBAC5B,mDAAmD;oBACnD,uBAAuB;oBACvB,OAAO;gBACT;YACF;YACA,SAAS;gBACP,iBAAiB,0IAAA,CAAA,UAAS,CAAC,WAAW;YACxC;QACF;IACF","debugId":null}},
    {"offset": {"line": 4704, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/trpc/server.tsx"],"sourcesContent":["import \"server-only\";\r\n\r\nimport type { AppRouter } from \"@/server/api/root\";\r\nimport type { TRPCQueryOptions } from \"@trpc/tanstack-react-query\";\r\nimport { cache } from \"react\";\r\nimport { headers } from \"next/headers\";\r\nimport { appRouter, createCaller } from \"@/server/api/root\";\r\nimport { createTRPCContext } from \"@/server/api/trpc\";\r\nimport { dehydrate, HydrationBoundary } from \"@tanstack/react-query\";\r\nimport { createTRPCOptionsProxy } from \"@trpc/tanstack-react-query\";\r\n\r\nimport { createQueryClient } from \"./query-client\";\r\n\r\n/**\r\n * This wraps the `createTRPCContext` helper and provides the required context for the tRPC API when\r\n * handling a tRPC call from a React Server Component.\r\n */\r\nconst createContext = cache(async () => {\r\n  const heads = new Headers(await headers());\r\n  heads.set(\"x-trpc-source\", \"rsc\");\r\n\r\n  return createTRPCContext({\r\n    headers: heads,\r\n  });\r\n});\r\n\r\nconst getQueryClient = cache(createQueryClient);\r\nexport const trpc = createTRPCOptionsProxy<AppRouter>({\r\n  router: appRouter,\r\n  ctx: createContext,\r\n  queryClient: getQueryClient,\r\n});\r\n\r\nexport const trpcApi = createCaller(createContext);\r\n\r\nexport function HydrateClient(props: { children: React.ReactNode }) {\r\n  const queryClient = getQueryClient();\r\n  return (\r\n    <HydrationBoundary state={dehydrate(queryClient)}>\r\n      {props.children}\r\n    </HydrationBoundary>\r\n  );\r\n}\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport function prefetch<T extends ReturnType<TRPCQueryOptions<any>>>(\r\n  queryOptions: T,\r\n) {\r\n  const queryClient = getQueryClient();\r\n  if (queryOptions.queryKey[1]?.type === \"infinite\") {\r\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any\r\n    void queryClient.prefetchInfiniteQuery(queryOptions as any);\r\n  } else {\r\n    void queryClient.prefetchQuery(queryOptions);\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;AAAA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;;;;;;;;;;AAEA;;;CAGC,GACD,MAAM,gBAAgB,CAAA,GAAA,qMAAA,CAAA,QAAK,AAAD,EAAE;IAC1B,MAAM,QAAQ,IAAI,QAAQ,MAAM,CAAA,GAAA,+HAAA,CAAA,UAAO,AAAD;IACtC,MAAM,GAAG,CAAC,iBAAiB;IAE3B,OAAO,CAAA,GAAA,2IAAA,CAAA,oBAAiB,AAAD,EAAE;QACvB,SAAS;IACX;AACF;AAEA,MAAM,iBAAiB,CAAA,GAAA,qMAAA,CAAA,QAAK,AAAD,EAAE,6IAAA,CAAA,oBAAiB;AACvC,MAAM,OAAO,CAAA,GAAA,gMAAA,CAAA,yBAAsB,AAAD,EAAa;IACpD,QAAQ,2IAAA,CAAA,YAAS;IACjB,KAAK;IACL,aAAa;AACf;AAEO,MAAM,UAAU,CAAA,GAAA,2IAAA,CAAA,eAAY,AAAD,EAAE;AAE7B,SAAS,cAAc,KAAoC;IAChE,MAAM,cAAc;IACpB,qBACE,8OAAC,oLAAA,CAAA,oBAAiB;QAAC,OAAO,CAAA,GAAA,2KAAA,CAAA,YAAS,AAAD,EAAE;kBACjC,MAAM,QAAQ;;;;;;AAGrB;AAEO,SAAS,SACd,YAAe;IAEf,MAAM,cAAc;IACpB,IAAI,aAAa,QAAQ,CAAC,EAAE,EAAE,SAAS,YAAY;QACjD,qGAAqG;QACrG,KAAK,YAAY,qBAAqB,CAAC;IACzC,OAAO;QACL,KAAK,YAAY,aAAa,CAAC;IACjC;AACF","debugId":null}},
    {"offset": {"line": 4773, "column": 0}, "map": {"version":3,"sources":["file:///C:/app/agentset/apps/web/src/app/app.agentset.ai/%28dashboard%29/%5Bslug%5D/%5BnamespaceSlug%5D/layout.tsx"],"sourcesContent":["import { notFound } from \"next/navigation\";\r\nimport { NamespaceProvider } from \"@/contexts/namespace-context\";\r\nimport { trpcApi } from \"@/trpc/server\";\r\n\r\nexport default async function NamespaceLayout({\r\n  params,\r\n  children,\r\n}: {\r\n  params: Promise<{ slug: string; namespaceSlug: string }>;\r\n  children: React.ReactNode;\r\n}) {\r\n  const { slug, namespaceSlug } = await params;\r\n  const namespace = await trpcApi.namespace.getNamespaceBySlug({\r\n    slug: namespaceSlug,\r\n    orgSlug: slug,\r\n  });\r\n\r\n  if (!namespace) {\r\n    notFound();\r\n  }\r\n\r\n  return (\r\n    <NamespaceProvider activeNamespace={namespace}>\r\n      {children}\r\n    </NamespaceProvider>\r\n  );\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AACA;;;;;AAEe,eAAe,gBAAgB,EAC5C,MAAM,EACN,QAAQ,EAIT;IACC,MAAM,EAAE,IAAI,EAAE,aAAa,EAAE,GAAG,MAAM;IACtC,MAAM,YAAY,MAAM,qIAAA,CAAA,UAAO,CAAC,SAAS,CAAC,kBAAkB,CAAC;QAC3D,MAAM;QACN,SAAS;IACX;IAEA,IAAI,CAAC,WAAW;QACd,CAAA,GAAA,qLAAA,CAAA,WAAQ,AAAD;IACT;IAEA,qBACE,8OAAC,uJAAA,CAAA,oBAAiB;QAAC,iBAAiB;kBACjC;;;;;;AAGP","debugId":null}}]
}